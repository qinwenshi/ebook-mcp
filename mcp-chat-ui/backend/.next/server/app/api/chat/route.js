/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/chat/route";
exports.ids = ["app/api/chat/route"];
exports.modules = {

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fchat%2Froute&page=%2Fapi%2Fchat%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fchat%2Froute.ts&appDir=%2FUsers%2Fonebird%2Fgithub%2Febook-mcp%2Fmcp-chat-ui%2Fbackend%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fonebird%2Fgithub%2Febook-mcp%2Fmcp-chat-ui%2Fbackend&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fchat%2Froute&page=%2Fapi%2Fchat%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fchat%2Froute.ts&appDir=%2FUsers%2Fonebird%2Fgithub%2Febook-mcp%2Fmcp-chat-ui%2Fbackend%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fonebird%2Fgithub%2Febook-mcp%2Fmcp-chat-ui%2Fbackend&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=! ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handler: () => (/* binding */ handler),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/server/request-meta */ \"(rsc)/./node_modules/next/dist/server/request-meta.js\");\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(rsc)/./node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/shared/lib/router/utils/app-paths */ \"next/dist/shared/lib/router/utils/app-paths\");\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/base-http/node */ \"(rsc)/./node_modules/next/dist/server/base-http/node.js\");\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/dist/server/web/spec-extension/adapters/next-request */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/adapters/next-request.js\");\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(rsc)/./node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/dist/server/instrumentation/utils */ \"(rsc)/./node_modules/next/dist/server/instrumentation/utils.js\");\n/* harmony import */ var next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! next/dist/server/send-response */ \"(rsc)/./node_modules/next/dist/server/send-response.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! next/dist/server/web/utils */ \"(rsc)/./node_modules/next/dist/server/web/utils.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! next/dist/server/lib/cache-control */ \"(rsc)/./node_modules/next/dist/server/lib/cache-control.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! next/dist/lib/constants */ \"(rsc)/./node_modules/next/dist/lib/constants.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! next/dist/shared/lib/no-fallback-error.external */ \"next/dist/shared/lib/no-fallback-error.external\");\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! next/dist/server/response-cache */ \"(rsc)/./node_modules/next/dist/server/response-cache/index.js\");\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var _Users_onebird_github_ebook_mcp_mcp_chat_ui_backend_src_app_api_chat_route_ts__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/app/api/chat/route.ts */ \"(rsc)/./src/app/api/chat/route.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/chat/route\",\n        pathname: \"/api/chat\",\n        filename: \"route\",\n        bundlePath: \"app/api/chat/route\"\n    },\n    distDir: \".next\" || 0,\n    projectDir:  false || '',\n    resolvedPagePath: \"/Users/onebird/github/ebook-mcp/mcp-chat-ui/backend/src/app/api/chat/route.ts\",\n    nextConfigOutput,\n    userland: _Users_onebird_github_ebook_mcp_mcp_chat_ui_backend_src_app_api_chat_route_ts__WEBPACK_IMPORTED_MODULE_16__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\nasync function handler(req, res, ctx) {\n    var _nextConfig_experimental;\n    let srcPage = \"/api/chat/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {} else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = \"false\";\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname } = prepareResult;\n    const normalizedSrcPage = (0,next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__.normalizeAppPath)(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                throw new next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isRevalidate = isIsr && !supportsDynamicResponse;\n    const method = req.method || 'GET';\n    const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.getTracer)();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                dynamicIO: Boolean(nextConfig.experimental.dynamicIO),\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            supportsDynamicResponse,\n            incrementalCache: (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'incrementalCache'),\n            cacheLifeProfiles: (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.cacheLife,\n            isRevalidate,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextRequest(req);\n    const nodeNextRes = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextResponse(res);\n    const nextReq = next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.NextRequestAdapter.fromNodeNextRequest(nodeNextReq, (0,next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.signalFromNodeResponse)(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.toNodeOutgoingHttpHeaders)(response.headers);\n                        if (cacheTags) {\n                            headers[next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                                isRevalidate,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode')) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.fromNodeOutgoingHttpHeaders)(cacheEntry.value.headers);\n            if (!((0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isIsr)) {\n                headers.delete(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', (0,next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__.getCacheControlHeader)(cacheEntry.cacheControl));\n            }\n            await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        // if we aren't wrapped by base-server handle here\n        if (!activeSpan && !(err instanceof next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                    isRevalidate,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIvaW5kZXguanM/bmFtZT1hcHAlMkZhcGklMkZjaGF0JTJGcm91dGUmcGFnZT0lMkZhcGklMkZjaGF0JTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGY2hhdCUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRm9uZWJpcmQlMkZnaXRodWIlMkZlYm9vay1tY3AlMkZtY3AtY2hhdC11aSUyRmJhY2tlbmQlMkZzcmMlMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRlVzZXJzJTJGb25lYmlyZCUyRmdpdGh1YiUyRmVib29rLW1jcCUyRm1jcC1jaGF0LXVpJTJGYmFja2VuZCZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCZpc0dsb2JhbE5vdEZvdW5kRW5hYmxlZD0hIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStGO0FBQ3ZDO0FBQ3FCO0FBQ2Q7QUFDUztBQUNPO0FBQ0s7QUFDbUM7QUFDakQ7QUFDTztBQUNmO0FBQ3NDO0FBQ3pCO0FBQ007QUFDQztBQUNoQjtBQUN3QztBQUMxRztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUdBQW1CO0FBQzNDO0FBQ0EsY0FBYyxrRUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhLE9BQW9DLElBQUksQ0FBRTtBQUN2RCxnQkFBZ0IsTUFBdUM7QUFDdkQ7QUFDQTtBQUNBLFlBQVk7QUFDWixD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QUFrQiw2RUFBWTtBQUM5QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2RUFBNkUsZ0ZBQWM7QUFDM0YsaUNBQWlDLFFBQVEsRUFBRSxRQUFRO0FBQ25ELDBCQUEwQix1RUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTjtBQUNBLDRDQUE0Qyw2RkFBZTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyRkFBbUI7QUFDckQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkVBQVk7QUFDMUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0IHsgZ2V0UmVxdWVzdE1ldGEgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yZXF1ZXN0LW1ldGFcIjtcbmltcG9ydCB7IGdldFRyYWNlciwgU3BhbktpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvdHJhY2VyXCI7XG5pbXBvcnQgeyBub3JtYWxpemVBcHBQYXRoIH0gZnJvbSBcIm5leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hcHAtcGF0aHNcIjtcbmltcG9ydCB7IE5vZGVOZXh0UmVxdWVzdCwgTm9kZU5leHRSZXNwb25zZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Jhc2UtaHR0cC9ub2RlXCI7XG5pbXBvcnQgeyBOZXh0UmVxdWVzdEFkYXB0ZXIsIHNpZ25hbEZyb21Ob2RlUmVzcG9uc2UgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvbmV4dC1yZXF1ZXN0XCI7XG5pbXBvcnQgeyBCYXNlU2VydmVyU3BhbiB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi90cmFjZS9jb25zdGFudHNcIjtcbmltcG9ydCB7IGdldFJldmFsaWRhdGVSZWFzb24gfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9pbnN0cnVtZW50YXRpb24vdXRpbHNcIjtcbmltcG9ydCB7IHNlbmRSZXNwb25zZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3NlbmQtcmVzcG9uc2VcIjtcbmltcG9ydCB7IGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycywgdG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3dlYi91dGlsc1wiO1xuaW1wb3J0IHsgZ2V0Q2FjaGVDb250cm9sSGVhZGVyIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL2NhY2hlLWNvbnRyb2xcIjtcbmltcG9ydCB7IElORklOSVRFX0NBQ0hFLCBORVhUX0NBQ0hFX1RBR1NfSEVBREVSIH0gZnJvbSBcIm5leHQvZGlzdC9saWIvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBOb0ZhbGxiYWNrRXJyb3IgfSBmcm9tIFwibmV4dC9kaXN0L3NoYXJlZC9saWIvbm8tZmFsbGJhY2stZXJyb3IuZXh0ZXJuYWxcIjtcbmltcG9ydCB7IENhY2hlZFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3Jlc3BvbnNlLWNhY2hlXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL1VzZXJzL29uZWJpcmQvZ2l0aHViL2Vib29rLW1jcC9tY3AtY2hhdC11aS9iYWNrZW5kL3NyYy9hcHAvYXBpL2NoYXQvcm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2NoYXQvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9jaGF0XCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9jaGF0L3JvdXRlXCJcbiAgICB9LFxuICAgIGRpc3REaXI6IHByb2Nlc3MuZW52Ll9fTkVYVF9SRUxBVElWRV9ESVNUX0RJUiB8fCAnJyxcbiAgICBwcm9qZWN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfUFJPSkVDVF9ESVIgfHwgJycsXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCIvVXNlcnMvb25lYmlyZC9naXRodWIvZWJvb2stbWNwL21jcC1jaGF0LXVpL2JhY2tlbmQvc3JjL2FwcC9hcGkvY2hhdC9yb3V0ZS50c1wiLFxuICAgIG5leHRDb25maWdPdXRwdXQsXG4gICAgdXNlcmxhbmRcbn0pO1xuLy8gUHVsbCBvdXQgdGhlIGV4cG9ydHMgdGhhdCB3ZSBuZWVkIHRvIGV4cG9zZSBmcm9tIHRoZSBtb2R1bGUuIFRoaXMgc2hvdWxkXG4vLyBiZSBlbGltaW5hdGVkIHdoZW4gd2UndmUgbW92ZWQgdGhlIG90aGVyIHJvdXRlcyB0byB0aGUgbmV3IGZvcm1hdC4gVGhlc2Vcbi8vIGFyZSB1c2VkIHRvIGhvb2sgaW50byB0aGUgcm91dGUuXG5jb25zdCB7IHdvcmtBc3luY1N0b3JhZ2UsIHdvcmtVbml0QXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5mdW5jdGlvbiBwYXRjaEZldGNoKCkge1xuICAgIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgICAgIHdvcmtBc3luY1N0b3JhZ2UsXG4gICAgICAgIHdvcmtVbml0QXN5bmNTdG9yYWdlXG4gICAgfSk7XG59XG5leHBvcnQgeyByb3V0ZU1vZHVsZSwgd29ya0FzeW5jU3RvcmFnZSwgd29ya1VuaXRBc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBwYXRjaEZldGNoLCAgfTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKHJlcSwgcmVzLCBjdHgpIHtcbiAgICB2YXIgX25leHRDb25maWdfZXhwZXJpbWVudGFsO1xuICAgIGxldCBzcmNQYWdlID0gXCIvYXBpL2NoYXQvcm91dGVcIjtcbiAgICAvLyB0dXJib3BhY2sgZG9lc24ndCBub3JtYWxpemUgYC9pbmRleGAgaW4gdGhlIHBhZ2UgbmFtZVxuICAgIC8vIHNvIHdlIG5lZWQgdG8gdG8gcHJvY2VzcyBkeW5hbWljIHJvdXRlcyBwcm9wZXJseVxuICAgIC8vIFRPRE86IGZpeCB0dXJib3BhY2sgcHJvdmlkaW5nIGRpZmZlcmluZyB2YWx1ZSBmcm9tIHdlYnBhY2tcbiAgICBpZiAocHJvY2Vzcy5lbnYuVFVSQk9QQUNLKSB7XG4gICAgICAgIHNyY1BhZ2UgPSBzcmNQYWdlLnJlcGxhY2UoL1xcL2luZGV4JC8sICcnKSB8fCAnLyc7XG4gICAgfSBlbHNlIGlmIChzcmNQYWdlID09PSAnL2luZGV4Jykge1xuICAgICAgICAvLyB3ZSBhbHdheXMgbm9ybWFsaXplIC9pbmRleCBzcGVjaWZpY2FsbHlcbiAgICAgICAgc3JjUGFnZSA9ICcvJztcbiAgICB9XG4gICAgY29uc3QgbXVsdGlab25lRHJhZnRNb2RlID0gcHJvY2Vzcy5lbnYuX19ORVhUX01VTFRJX1pPTkVfRFJBRlRfTU9ERTtcbiAgICBjb25zdCBwcmVwYXJlUmVzdWx0ID0gYXdhaXQgcm91dGVNb2R1bGUucHJlcGFyZShyZXEsIHJlcywge1xuICAgICAgICBzcmNQYWdlLFxuICAgICAgICBtdWx0aVpvbmVEcmFmdE1vZGVcbiAgICB9KTtcbiAgICBpZiAoIXByZXBhcmVSZXN1bHQpIHtcbiAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDA7XG4gICAgICAgIHJlcy5lbmQoJ0JhZCBSZXF1ZXN0Jyk7XG4gICAgICAgIGN0eC53YWl0VW50aWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC53YWl0VW50aWwuY2FsbChjdHgsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgYnVpbGRJZCwgcGFyYW1zLCBuZXh0Q29uZmlnLCBpc0RyYWZ0TW9kZSwgcHJlcmVuZGVyTWFuaWZlc3QsIHJvdXRlclNlcnZlckNvbnRleHQsIGlzT25EZW1hbmRSZXZhbGlkYXRlLCByZXZhbGlkYXRlT25seUdlbmVyYXRlZCwgcmVzb2x2ZWRQYXRobmFtZSB9ID0gcHJlcGFyZVJlc3VsdDtcbiAgICBjb25zdCBub3JtYWxpemVkU3JjUGFnZSA9IG5vcm1hbGl6ZUFwcFBhdGgoc3JjUGFnZSk7XG4gICAgbGV0IGlzSXNyID0gQm9vbGVhbihwcmVyZW5kZXJNYW5pZmVzdC5keW5hbWljUm91dGVzW25vcm1hbGl6ZWRTcmNQYWdlXSB8fCBwcmVyZW5kZXJNYW5pZmVzdC5yb3V0ZXNbcmVzb2x2ZWRQYXRobmFtZV0pO1xuICAgIGlmIChpc0lzciAmJiAhaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgY29uc3QgaXNQcmVyZW5kZXJlZCA9IEJvb2xlYW4ocHJlcmVuZGVyTWFuaWZlc3Qucm91dGVzW3Jlc29sdmVkUGF0aG5hbWVdKTtcbiAgICAgICAgY29uc3QgcHJlcmVuZGVySW5mbyA9IHByZXJlbmRlck1hbmlmZXN0LmR5bmFtaWNSb3V0ZXNbbm9ybWFsaXplZFNyY1BhZ2VdO1xuICAgICAgICBpZiAocHJlcmVuZGVySW5mbykge1xuICAgICAgICAgICAgaWYgKHByZXJlbmRlckluZm8uZmFsbGJhY2sgPT09IGZhbHNlICYmICFpc1ByZXJlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vRmFsbGJhY2tFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjYWNoZUtleSA9IG51bGw7XG4gICAgaWYgKGlzSXNyICYmICFyb3V0ZU1vZHVsZS5pc0RldiAmJiAhaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgY2FjaGVLZXkgPSByZXNvbHZlZFBhdGhuYW1lO1xuICAgICAgICAvLyBlbnN1cmUgL2luZGV4IGFuZCAvIGlzIG5vcm1hbGl6ZWQgdG8gb25lIGtleVxuICAgICAgICBjYWNoZUtleSA9IGNhY2hlS2V5ID09PSAnL2luZGV4JyA/ICcvJyA6IGNhY2hlS2V5O1xuICAgIH1cbiAgICBjb25zdCBzdXBwb3J0c0R5bmFtaWNSZXNwb25zZSA9IC8vIElmIHdlJ3JlIGluIGRldmVsb3BtZW50LCB3ZSBhbHdheXMgc3VwcG9ydCBkeW5hbWljIEhUTUxcbiAgICByb3V0ZU1vZHVsZS5pc0RldiA9PT0gdHJ1ZSB8fCAvLyBJZiB0aGlzIGlzIG5vdCBTU0cgb3IgZG9lcyBub3QgaGF2ZSBzdGF0aWMgcGF0aHMsIHRoZW4gaXQgc3VwcG9ydHNcbiAgICAvLyBkeW5hbWljIEhUTUwuXG4gICAgIWlzSXNyO1xuICAgIC8vIFRoaXMgaXMgYSByZXZhbGlkYXRpb24gcmVxdWVzdCBpZiB0aGUgcmVxdWVzdCBpcyBmb3IgYSBzdGF0aWNcbiAgICAvLyBwYWdlIGFuZCBpdCBpcyBub3QgYmVpbmcgcmVzdW1lZCBmcm9tIGEgcG9zdHBvbmVkIHJlbmRlciBhbmRcbiAgICAvLyBpdCBpcyBub3QgYSBkeW5hbWljIFJTQyByZXF1ZXN0IHRoZW4gaXQgaXMgYSByZXZhbGlkYXRpb25cbiAgICAvLyByZXF1ZXN0LlxuICAgIGNvbnN0IGlzUmV2YWxpZGF0ZSA9IGlzSXNyICYmICFzdXBwb3J0c0R5bmFtaWNSZXNwb25zZTtcbiAgICBjb25zdCBtZXRob2QgPSByZXEubWV0aG9kIHx8ICdHRVQnO1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSB0cmFjZXIuZ2V0QWN0aXZlU2NvcGVTcGFuKCk7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBwcmVyZW5kZXJNYW5pZmVzdCxcbiAgICAgICAgcmVuZGVyT3B0czoge1xuICAgICAgICAgICAgZXhwZXJpbWVudGFsOiB7XG4gICAgICAgICAgICAgICAgZHluYW1pY0lPOiBCb29sZWFuKG5leHRDb25maWcuZXhwZXJpbWVudGFsLmR5bmFtaWNJTyksXG4gICAgICAgICAgICAgICAgYXV0aEludGVycnVwdHM6IEJvb2xlYW4obmV4dENvbmZpZy5leHBlcmltZW50YWwuYXV0aEludGVycnVwdHMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VwcG9ydHNEeW5hbWljUmVzcG9uc2UsXG4gICAgICAgICAgICBpbmNyZW1lbnRhbENhY2hlOiBnZXRSZXF1ZXN0TWV0YShyZXEsICdpbmNyZW1lbnRhbENhY2hlJyksXG4gICAgICAgICAgICBjYWNoZUxpZmVQcm9maWxlczogKF9uZXh0Q29uZmlnX2V4cGVyaW1lbnRhbCA9IG5leHRDb25maWcuZXhwZXJpbWVudGFsKSA9PSBudWxsID8gdm9pZCAwIDogX25leHRDb25maWdfZXhwZXJpbWVudGFsLmNhY2hlTGlmZSxcbiAgICAgICAgICAgIGlzUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbCxcbiAgICAgICAgICAgIG9uQ2xvc2U6IChjYik9PntcbiAgICAgICAgICAgICAgICByZXMub24oJ2Nsb3NlJywgY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQWZ0ZXJUYXNrRXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9uSW5zdHJ1bWVudGF0aW9uUmVxdWVzdEVycm9yOiAoZXJyb3IsIF9yZXF1ZXN0LCBlcnJvckNvbnRleHQpPT5yb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVycm9yLCBlcnJvckNvbnRleHQsIHJvdXRlclNlcnZlckNvbnRleHQpXG4gICAgICAgIH0sXG4gICAgICAgIHNoYXJlZENvbnRleHQ6IHtcbiAgICAgICAgICAgIGJ1aWxkSWRcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9kZU5leHRSZXEgPSBuZXcgTm9kZU5leHRSZXF1ZXN0KHJlcSk7XG4gICAgY29uc3Qgbm9kZU5leHRSZXMgPSBuZXcgTm9kZU5leHRSZXNwb25zZShyZXMpO1xuICAgIGNvbnN0IG5leHRSZXEgPSBOZXh0UmVxdWVzdEFkYXB0ZXIuZnJvbU5vZGVOZXh0UmVxdWVzdChub2RlTmV4dFJlcSwgc2lnbmFsRnJvbU5vZGVSZXNwb25zZShyZXMpKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBpbnZva2VSb3V0ZU1vZHVsZSA9IGFzeW5jIChzcGFuKT0+e1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlTW9kdWxlLmhhbmRsZShuZXh0UmVxLCBjb250ZXh0KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzcGFuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHAuc3RhdHVzX2NvZGUnOiByZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgJ25leHQucnNjJzogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByb290U3BhbkF0dHJpYnV0ZXMgPSB0cmFjZXIuZ2V0Um9vdFNwYW5BdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGF0dHJpYnV0ZXMsIHByb2JhYmx5IE9URUwgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RTcGFuQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpICE9PSBCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5leHBlY3RlZCByb290IHNwYW4gdHlwZSAnJHtyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpfScuIFBsZWFzZSByZXBvcnQgdGhpcyBOZXh0LmpzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qc2ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5yb3V0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7bWV0aG9kfSAke3JvdXRlfWA7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAucm91dGUnOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXh0LnNwYW5fbmFtZSc6IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUoYCR7bWV0aG9kfSAke3JlcS51cmx9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gYXN5bmMgKGN1cnJlbnRTcGFuKT0+e1xuICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VHZW5lcmF0b3IgPSBhc3luYyAoeyBwcmV2aW91c0NhY2hlRW50cnkgfSk9PntcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdldFJlcXVlc3RNZXRhKHJlcSwgJ21pbmltYWxNb2RlJykgJiYgaXNPbkRlbWFuZFJldmFsaWRhdGUgJiYgcmV2YWxpZGF0ZU9ubHlHZW5lcmF0ZWQgJiYgIXByZXZpb3VzQ2FjaGVFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbi1kZW1hbmQgcmV2YWxpZGF0ZSBhbHdheXMgc2V0cyB0aGlzIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCAnUkVWQUxJREFURUQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoJ1RoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaW52b2tlUm91dGVNb2R1bGUoY3VycmVudFNwYW4pO1xuICAgICAgICAgICAgICAgICAgICByZXEuZmV0Y2hNZXRyaWNzID0gY29udGV4dC5yZW5kZXJPcHRzLmZldGNoTWV0cmljcztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBlbmRpbmdXYWl0VW50aWwgPSBjb250ZXh0LnJlbmRlck9wdHMucGVuZGluZ1dhaXRVbnRpbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB1c2luZyBwcm92aWRlZCB3YWl0VW50aWwgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IHdlIGZhbGxiYWNrIHRvIHNlbmRSZXNwb25zZSdzIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nV2FpdFVudGlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4LndhaXRVbnRpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC53YWl0VW50aWwocGVuZGluZ1dhaXRVbnRpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1dhaXRVbnRpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZVRhZ3MgPSBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkVGFncztcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaXMgZm9yIGEgc3RhdGljIHJlc3BvbnNlLCB3ZSBjYW4gY2FjaGUgaXQgc28gbG9uZ1xuICAgICAgICAgICAgICAgICAgICAvLyBhcyBpdCdzIG5vdCBlZGdlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJc3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBoZWFkZXJzIGZyb20gdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tORVhUX0NBQ0hFX1RBR1NfSEVBREVSXSA9IGNhY2hlVGFncztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyc1snY29udGVudC10eXBlJ10gJiYgYmxvYi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBibG9iLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXZhbGlkYXRlID0gdHlwZW9mIGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRSZXZhbGlkYXRlID09PSAndW5kZWZpbmVkJyB8fCBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkUmV2YWxpZGF0ZSA+PSBJTkZJTklURV9DQUNIRSA/IGZhbHNlIDogY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZFJldmFsaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBpcmUgPSB0eXBlb2YgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZSA9PT0gJ3VuZGVmaW5lZCcgfHwgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZSA+PSBJTkZJTklURV9DQUNIRSA/IHVuZGVmaW5lZCA6IGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRFeHBpcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGNhY2hlIGVudHJ5IGZvciB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBCdWZmZXIuZnJvbShhd2FpdCBibG9iLmFycmF5QnVmZmVyKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2w6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VuZCByZXNwb25zZSB3aXRob3V0IGNhY2hpbmcgaWYgbm90IElTUlxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2VuZFJlc3BvbnNlKG5vZGVOZXh0UmVxLCBub2RlTmV4dFJlcywgcmVzcG9uc2UsIGNvbnRleHQucmVuZGVyT3B0cy5wZW5kaW5nV2FpdFVudGlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBiYWNrZ3JvdW5kIHJldmFsaWRhdGUgd2UgbmVlZCB0byByZXBvcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QgZXJyb3IgaGVyZSBhcyBpdCB3b24ndCBiZSBidWJibGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0NhY2hlRW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzQ2FjaGVFbnRyeS5pc1N0YWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVyciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcktpbmQ6ICdBcHAgUm91dGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVBhdGg6IHNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVUeXBlOiAncm91dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGVSZWFzb246IGdldFJldmFsaWRhdGVSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJvdXRlclNlcnZlckNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2FjaGVFbnRyeSA9IGF3YWl0IHJvdXRlTW9kdWxlLmhhbmRsZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICByb3V0ZUtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgICAgICAgICAgaXNGYWxsYmFjazogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJlcmVuZGVyTWFuaWZlc3QsXG4gICAgICAgICAgICAgICAgaXNSb3V0ZVBQUkVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVPbmx5R2VuZXJhdGVkLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlR2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBjcmVhdGUgYSBjYWNoZUVudHJ5IGZvciBJU1JcbiAgICAgICAgICAgIGlmICghaXNJc3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoY2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9jYWNoZUVudHJ5X3ZhbHVlID0gY2FjaGVFbnRyeS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYWNoZUVudHJ5X3ZhbHVlLmtpbmQpICE9PSBDYWNoZWRSb3V0ZUtpbmQuQVBQX1JPVVRFKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlMTtcbiAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKGBJbnZhcmlhbnQ6IGFwcC1yb3V0ZSByZWNlaXZlZCBpbnZhbGlkIGNhY2hlIGVudHJ5ICR7Y2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9jYWNoZUVudHJ5X3ZhbHVlMSA9IGNhY2hlRW50cnkudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfY2FjaGVFbnRyeV92YWx1ZTEua2luZH1gKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkU3MDFcIixcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnZXRSZXF1ZXN0TWV0YShyZXEsICdtaW5pbWFsTW9kZScpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCBpc09uRGVtYW5kUmV2YWxpZGF0ZSA/ICdSRVZBTElEQVRFRCcgOiBjYWNoZUVudHJ5LmlzTWlzcyA/ICdNSVNTJyA6IGNhY2hlRW50cnkuaXNTdGFsZSA/ICdTVEFMRScgOiAnSElUJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEcmFmdCBtb2RlIHNob3VsZCBuZXZlciBiZSBjYWNoZWRcbiAgICAgICAgICAgIGlmIChpc0RyYWZ0TW9kZSkge1xuICAgICAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnLCAncHJpdmF0ZSwgbm8tY2FjaGUsIG5vLXN0b3JlLCBtYXgtYWdlPTAsIG11c3QtcmV2YWxpZGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyhjYWNoZUVudHJ5LnZhbHVlLmhlYWRlcnMpO1xuICAgICAgICAgICAgaWYgKCEoZ2V0UmVxdWVzdE1ldGEocmVxLCAnbWluaW1hbE1vZGUnKSAmJiBpc0lzcikpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmRlbGV0ZShORVhUX0NBQ0hFX1RBR1NfSEVBREVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGNhY2hlIGNvbnRyb2wgaXMgYWxyZWFkeSBzZXQgb24gdGhlIHJlc3BvbnNlIHdlIGRvbid0XG4gICAgICAgICAgICAvLyBvdmVycmlkZSBpdCB0byBhbGxvdyB1c2VycyB0byBjdXN0b21pemUgaXQgdmlhIG5leHQuY29uZmlnXG4gICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2wgJiYgIXJlcy5nZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnKSAmJiAhaGVhZGVycy5nZXQoJ0NhY2hlLUNvbnRyb2wnKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdDYWNoZS1Db250cm9sJywgZ2V0Q2FjaGVDb250cm9sSGVhZGVyKGNhY2hlRW50cnkuY2FjaGVDb250cm9sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCBuZXcgUmVzcG9uc2UoY2FjaGVFbnRyeS52YWx1ZS5ib2R5LCB7XG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGNhY2hlRW50cnkudmFsdWUuc3RhdHVzIHx8IDIwMFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE86IGFjdGl2ZVNwYW4gY29kZSBwYXRoIGlzIGZvciB3aGVuIHdyYXBwZWQgYnlcbiAgICAgICAgLy8gbmV4dC1zZXJ2ZXIgY2FuIGJlIHJlbW92ZWQgd2hlbiB0aGlzIGlzIG5vIGxvbmdlciB1c2VkXG4gICAgICAgIGlmIChhY3RpdmVTcGFuKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVSZXNwb25zZShhY3RpdmVTcGFuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRyYWNlci53aXRoUHJvcGFnYXRlZENvbnRleHQocmVxLmhlYWRlcnMsICgpPT50cmFjZXIudHJhY2UoQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICBzcGFuTmFtZTogYCR7bWV0aG9kfSAke3JlcS51cmx9YCxcbiAgICAgICAgICAgICAgICAgICAga2luZDogU3BhbktpbmQuU0VSVkVSLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC5tZXRob2QnOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC50YXJnZXQnOiByZXEudXJsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBoYW5kbGVSZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGlmIHdlIGFyZW4ndCB3cmFwcGVkIGJ5IGJhc2Utc2VydmVyIGhhbmRsZSBoZXJlXG4gICAgICAgIGlmICghYWN0aXZlU3BhbiAmJiAhKGVyciBpbnN0YW5jZW9mIE5vRmFsbGJhY2tFcnJvcikpIHtcbiAgICAgICAgICAgIGF3YWl0IHJvdXRlTW9kdWxlLm9uUmVxdWVzdEVycm9yKHJlcSwgZXJyLCB7XG4gICAgICAgICAgICAgICAgcm91dGVyS2luZDogJ0FwcCBSb3V0ZXInLFxuICAgICAgICAgICAgICAgIHJvdXRlUGF0aDogbm9ybWFsaXplZFNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgcm91dGVUeXBlOiAncm91dGUnLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVSZWFzb246IGdldFJldmFsaWRhdGVSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldGhyb3cgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIHNlcnZpbmcgZXJyb3IgcGFnZVxuICAgICAgICAvLyBJZiB0aGlzIGlzIGR1cmluZyBzdGF0aWMgZ2VuZXJhdGlvbiwgdGhyb3cgdGhlIGVycm9yIGFnYWluLlxuICAgICAgICBpZiAoaXNJc3IpIHRocm93IGVycjtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzZW5kIGEgNTAwIHJlc3BvbnNlLlxuICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fchat%2Froute&page=%2Fapi%2Fchat%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fchat%2Froute.ts&appDir=%2FUsers%2Fonebird%2Fgithub%2Febook-mcp%2Fmcp-chat-ui%2Fbackend%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fonebird%2Fgithub%2Febook-mcp%2Fmcp-chat-ui%2Fbackend&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(rsc)/./src/app/api/chat/route.ts":
/*!***********************************!*\
  !*** ./src/app/api/chat/route.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OPTIONS: () => (/* binding */ OPTIONS),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_security__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/security */ \"(rsc)/./src/lib/security.ts\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/errors */ \"(rsc)/./src/lib/errors.ts\");\n/* harmony import */ var _lib_validation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/validation */ \"(rsc)/./src/lib/validation.ts\");\n/* harmony import */ var _lib_initialization__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/initialization */ \"(rsc)/./src/lib/initialization.ts\");\n/* harmony import */ var _services_LLMService__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/services/LLMService */ \"(rsc)/./src/services/LLMService.ts\");\n/* harmony import */ var _services_SessionManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/services/SessionManager */ \"(rsc)/./src/services/SessionManager.ts\");\n/* harmony import */ var _services_ChatProcessor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/services/ChatProcessor */ \"(rsc)/./src/services/ChatProcessor.ts\");\n\n\n\n\n\n\n\n\nasync function chatHandler(request) {\n    if (request.method !== 'POST') {\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: 'Method not allowed',\n            sessionId: '',\n            message: 'Only POST method is allowed'\n        }, {\n            status: 405\n        });\n    }\n    console.log('Processing chat request');\n    // Ensure backend is initialized\n    await (0,_lib_initialization__WEBPACK_IMPORTED_MODULE_4__.ensureInitialized)();\n    const body = await request.json();\n    const chatRequest = (0,_lib_validation__WEBPACK_IMPORTED_MODULE_3__.validateChatRequest)(body);\n    // Extract additional parameters from request body\n    const { apiKey, baseUrl, systemPrompt, temperature, maxTokens, availableTools } = body;\n    // Note: API key is now retrieved securely from backend storage, not from frontend\n    console.log(' Backend received provider:', chatRequest.provider);\n    console.log(' Backend received model:', chatRequest.model);\n    // Get API key from secure settings manager (never from frontend)\n    let actualApiKey;\n    try {\n        const { getSecureSettingsManager } = await __webpack_require__.e(/*! import() */ \"_rsc_src_services_SecureSettingsManager_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/services/SecureSettingsManager */ \"(rsc)/./src/services/SecureSettingsManager.ts\"));\n        const settingsManager = getSecureSettingsManager();\n        await settingsManager.initialize();\n        // Find the provider configuration by matching provider name\n        const settings = await settingsManager.getSettings();\n        const provider = settings.llmProviders.find((p)=>p.name === chatRequest.provider && p.enabled);\n        if (!provider) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.ValidationError(`No enabled ${chatRequest.provider} provider found. Please configure and enable a provider in settings.`);\n        }\n        actualApiKey = await settingsManager.getDecryptedApiKey(provider.id);\n        console.log(' Retrieved API key from secure storage for provider:', chatRequest.provider);\n    } catch (error) {\n        console.error(' Failed to retrieve API key from secure storage:', error);\n        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.ValidationError('API key not found in secure storage. Please configure your API key in settings.');\n    }\n    // Validate API key\n    if (!actualApiKey || typeof actualApiKey !== 'string' || actualApiKey.trim().length === 0) {\n        console.error(' API key validation failed: missing or empty');\n        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.ValidationError('API key is required for chat requests');\n    }\n    // Basic API key format validation\n    if (actualApiKey.length < 10) {\n        console.error(' API key validation failed: too short');\n        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.ValidationError('API key appears to be invalid (too short)');\n    }\n    try {\n        // Create LLM service with user's configuration\n        const defaultConfig = (0,_services_LLMService__WEBPACK_IMPORTED_MODULE_5__.getDefaultProviderConfig)(chatRequest.provider);\n        const llmService = (0,_services_LLMService__WEBPACK_IMPORTED_MODULE_5__.createLLMService)({\n            provider: chatRequest.provider,\n            apiKey: actualApiKey,\n            baseUrl: baseUrl || defaultConfig.baseUrl,\n            model: chatRequest.model,\n            maxRetries: defaultConfig.maxRetries,\n            retryDelay: defaultConfig.retryDelay,\n            timeout: defaultConfig.timeout\n        });\n        // Get session manager\n        const sessionManager = (0,_services_SessionManager__WEBPACK_IMPORTED_MODULE_6__.getSessionManager)();\n        // Create chat processor\n        const chatProcessor = (0,_services_ChatProcessor__WEBPACK_IMPORTED_MODULE_7__.createChatProcessor)(llmService, sessionManager);\n        // Process the chat query\n        const response = await chatProcessor.processQuery({\n            messages: chatRequest.messages,\n            sessionId: chatRequest.sessionId,\n            provider: chatRequest.provider,\n            model: chatRequest.model,\n            availableTools: availableTools || [],\n            systemPrompt,\n            temperature,\n            maxTokens\n        });\n        const chatResponse = {\n            reply: response.reply,\n            toolCalls: response.toolCalls,\n            sessionId: response.sessionId\n        };\n        console.log(`Chat request processed successfully for session: ${response.sessionId}`);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(chatResponse);\n    } catch (error) {\n        console.error('Chat processing error:', error);\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n        const statusCode = error instanceof _lib_errors__WEBPACK_IMPORTED_MODULE_2__.ValidationError ? 400 : 500;\n        const chatResponse = {\n            sessionId: chatRequest.sessionId,\n            error: errorMessage\n        };\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(chatResponse, {\n            status: statusCode\n        });\n    }\n}\nconst POST = (0,_lib_security__WEBPACK_IMPORTED_MODULE_1__.withSecurity)(chatHandler);\nconst OPTIONS = (0,_lib_security__WEBPACK_IMPORTED_MODULE_1__.withSecurity)(async ()=>new next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse(null, {\n        status: 200\n    }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ekIsTUFBTUUsV0FBVyxNQUFNRCxjQUFjRSxZQUFZLENBQUM7WUFDaERDLFVBQVVqQyxZQUFZaUMsUUFBUTtZQUM5QnZDLFdBQVdNLFlBQVlOLFNBQVM7WUFDaENhLFVBQVVQLFlBQVlPLFFBQVE7WUFDOUJDLE9BQU9SLFlBQVlRLEtBQUs7WUFDeEJGLGdCQUFnQkEsa0JBQWtCLEVBQUU7WUFDcENIO1lBQ0FDO1lBQ0FDO1FBQ0Y7UUFFQSxNQUFNNkIsZUFBNkI7WUFDakNDLE9BQU9KLFNBQVNJLEtBQUs7WUFDckJDLFdBQVdMLFNBQVNLLFNBQVM7WUFDN0IxQyxXQUFXcUMsU0FBU3JDLFNBQVM7UUFDL0I7UUFFQUcsUUFBUUMsR0FBRyxDQUFDLENBQUMsaURBQWlELEVBQUVpQyxTQUFTckMsU0FBUyxFQUFFO1FBQ3BGLE9BQU9kLHFEQUFZQSxDQUFDWSxJQUFJLENBQUMwQztJQUMzQixFQUFFLE9BQU96QyxPQUFPO1FBQ2RJLFFBQVFKLEtBQUssQ0FBQywwQkFBMEJBO1FBRXhDLE1BQU00QyxlQUFlNUMsaUJBQWlCNkMsUUFBUTdDLE1BQU1FLE9BQU8sR0FBRztRQUM5RCxNQUFNNEMsYUFBYTlDLGlCQUFpQlgsd0RBQWVBLEdBQUcsTUFBTTtRQUU1RCxNQUFNb0QsZUFBNkI7WUFDakN4QyxXQUFXTSxZQUFZTixTQUFTO1lBQ2hDRCxPQUFPNEM7UUFDVDtRQUVBLE9BQU96RCxxREFBWUEsQ0FBQ1ksSUFBSSxDQUFDMEMsY0FBYztZQUFFdEMsUUFBUTJDO1FBQVc7SUFDOUQ7QUFDRjtBQUVPLE1BQU1DLE9BQU8zRCwyREFBWUEsQ0FBQ1EsYUFBYTtBQUN2QyxNQUFNb0QsVUFBVTVELDJEQUFZQSxDQUFDLFVBQVksSUFBSUQscURBQVlBLENBQUMsTUFBTTtRQUFFZ0IsUUFBUTtJQUFJLElBQUkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9vbmViaXJkL2dpdGh1Yi9lYm9vay1tY3AvbWNwLWNoYXQtdWkvYmFja2VuZC9zcmMvYXBwL2FwaS9jaGF0L3JvdXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IHdpdGhTZWN1cml0eSB9IGZyb20gJ0AvbGliL3NlY3VyaXR5JztcbmltcG9ydCB7IFZhbGlkYXRpb25FcnJvciB9IGZyb20gJ0AvbGliL2Vycm9ycyc7XG5pbXBvcnQgeyB2YWxpZGF0ZUNoYXRSZXF1ZXN0IH0gZnJvbSAnQC9saWIvdmFsaWRhdGlvbic7XG5pbXBvcnQgeyBlbnN1cmVJbml0aWFsaXplZCB9IGZyb20gJ0AvbGliL2luaXRpYWxpemF0aW9uJztcbmltcG9ydCB7IENoYXRSZXF1ZXN0LCBDaGF0UmVzcG9uc2UgfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IGNyZWF0ZUxMTVNlcnZpY2UsIGdldERlZmF1bHRQcm92aWRlckNvbmZpZyB9IGZyb20gJ0Avc2VydmljZXMvTExNU2VydmljZSc7XG5pbXBvcnQgeyBnZXRTZXNzaW9uTWFuYWdlciB9IGZyb20gJ0Avc2VydmljZXMvU2Vzc2lvbk1hbmFnZXInO1xuaW1wb3J0IHsgY3JlYXRlQ2hhdFByb2Nlc3NvciB9IGZyb20gJ0Avc2VydmljZXMvQ2hhdFByb2Nlc3Nvcic7XG5cbmFzeW5jIGZ1bmN0aW9uIGNoYXRIYW5kbGVyKHJlcXVlc3Q6IFJlcXVlc3QpOiBQcm9taXNlPE5leHRSZXNwb25zZT4ge1xuICBpZiAocmVxdWVzdC5tZXRob2QgIT09ICdQT1NUJykge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6ICdNZXRob2Qgbm90IGFsbG93ZWQnLCBzZXNzaW9uSWQ6ICcnLCBtZXNzYWdlOiAnT25seSBQT1NUIG1ldGhvZCBpcyBhbGxvd2VkJyB9LFxuICAgICAgeyBzdGF0dXM6IDQwNSB9XG4gICAgKTtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIGNoYXQgcmVxdWVzdCcpO1xuXG4gIC8vIEVuc3VyZSBiYWNrZW5kIGlzIGluaXRpYWxpemVkXG4gIGF3YWl0IGVuc3VyZUluaXRpYWxpemVkKCk7XG5cbiAgY29uc3QgYm9keSA9IGF3YWl0IHJlcXVlc3QuanNvbigpO1xuICBjb25zdCBjaGF0UmVxdWVzdCA9IHZhbGlkYXRlQ2hhdFJlcXVlc3QoYm9keSk7XG5cbiAgLy8gRXh0cmFjdCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZnJvbSByZXF1ZXN0IGJvZHlcbiAgY29uc3QgeyBcbiAgICBhcGlLZXksIFxuICAgIGJhc2VVcmwsIFxuICAgIHN5c3RlbVByb21wdCwgXG4gICAgdGVtcGVyYXR1cmUsIFxuICAgIG1heFRva2VucyxcbiAgICBhdmFpbGFibGVUb29scyBcbiAgfSA9IGJvZHk7XG5cbiAgLy8gTm90ZTogQVBJIGtleSBpcyBub3cgcmV0cmlldmVkIHNlY3VyZWx5IGZyb20gYmFja2VuZCBzdG9yYWdlLCBub3QgZnJvbSBmcm9udGVuZFxuICBjb25zb2xlLmxvZygn8J+UpyBCYWNrZW5kIHJlY2VpdmVkIHByb3ZpZGVyOicsIGNoYXRSZXF1ZXN0LnByb3ZpZGVyKTtcbiAgY29uc29sZS5sb2coJ/CfpJYgQmFja2VuZCByZWNlaXZlZCBtb2RlbDonLCBjaGF0UmVxdWVzdC5tb2RlbCk7XG5cbiAgLy8gR2V0IEFQSSBrZXkgZnJvbSBzZWN1cmUgc2V0dGluZ3MgbWFuYWdlciAobmV2ZXIgZnJvbSBmcm9udGVuZClcbiAgbGV0IGFjdHVhbEFwaUtleTogc3RyaW5nO1xuICB0cnkge1xuICAgIGNvbnN0IHsgZ2V0U2VjdXJlU2V0dGluZ3NNYW5hZ2VyIH0gPSBhd2FpdCBpbXBvcnQoJ0Avc2VydmljZXMvU2VjdXJlU2V0dGluZ3NNYW5hZ2VyJyk7XG4gICAgY29uc3Qgc2V0dGluZ3NNYW5hZ2VyID0gZ2V0U2VjdXJlU2V0dGluZ3NNYW5hZ2VyKCk7XG4gICAgYXdhaXQgc2V0dGluZ3NNYW5hZ2VyLmluaXRpYWxpemUoKTtcbiAgICBcbiAgICAvLyBGaW5kIHRoZSBwcm92aWRlciBjb25maWd1cmF0aW9uIGJ5IG1hdGNoaW5nIHByb3ZpZGVyIG5hbWVcbiAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHNldHRpbmdzTWFuYWdlci5nZXRTZXR0aW5ncygpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gc2V0dGluZ3MubGxtUHJvdmlkZXJzLmZpbmQocCA9PiBwLm5hbWUgPT09IGNoYXRSZXF1ZXN0LnByb3ZpZGVyICYmIHAuZW5hYmxlZCk7XG4gICAgXG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgTm8gZW5hYmxlZCAke2NoYXRSZXF1ZXN0LnByb3ZpZGVyfSBwcm92aWRlciBmb3VuZC4gUGxlYXNlIGNvbmZpZ3VyZSBhbmQgZW5hYmxlIGEgcHJvdmlkZXIgaW4gc2V0dGluZ3MuYCk7XG4gICAgfVxuICAgIFxuICAgIGFjdHVhbEFwaUtleSA9IGF3YWl0IHNldHRpbmdzTWFuYWdlci5nZXREZWNyeXB0ZWRBcGlLZXkocHJvdmlkZXIuaWQpO1xuICAgIGNvbnNvbGUubG9nKCfwn5SRIFJldHJpZXZlZCBBUEkga2V5IGZyb20gc2VjdXJlIHN0b3JhZ2UgZm9yIHByb3ZpZGVyOicsIGNoYXRSZXF1ZXN0LnByb3ZpZGVyKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIHJldHJpZXZlIEFQSSBrZXkgZnJvbSBzZWN1cmUgc3RvcmFnZTonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignQVBJIGtleSBub3QgZm91bmQgaW4gc2VjdXJlIHN0b3JhZ2UuIFBsZWFzZSBjb25maWd1cmUgeW91ciBBUEkga2V5IGluIHNldHRpbmdzLicpO1xuICB9XG5cbiAgLy8gVmFsaWRhdGUgQVBJIGtleVxuICBpZiAoIWFjdHVhbEFwaUtleSB8fCB0eXBlb2YgYWN0dWFsQXBpS2V5ICE9PSAnc3RyaW5nJyB8fCBhY3R1YWxBcGlLZXkudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBBUEkga2V5IHZhbGlkYXRpb24gZmFpbGVkOiBtaXNzaW5nIG9yIGVtcHR5Jyk7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignQVBJIGtleSBpcyByZXF1aXJlZCBmb3IgY2hhdCByZXF1ZXN0cycpO1xuICB9XG5cbiAgLy8gQmFzaWMgQVBJIGtleSBmb3JtYXQgdmFsaWRhdGlvblxuICBpZiAoYWN0dWFsQXBpS2V5Lmxlbmd0aCA8IDEwKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIEFQSSBrZXkgdmFsaWRhdGlvbiBmYWlsZWQ6IHRvbyBzaG9ydCcpO1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ0FQSSBrZXkgYXBwZWFycyB0byBiZSBpbnZhbGlkICh0b28gc2hvcnQpJyk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIENyZWF0ZSBMTE0gc2VydmljZSB3aXRoIHVzZXIncyBjb25maWd1cmF0aW9uXG4gICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IGdldERlZmF1bHRQcm92aWRlckNvbmZpZyhjaGF0UmVxdWVzdC5wcm92aWRlcik7XG4gICAgY29uc3QgbGxtU2VydmljZSA9IGNyZWF0ZUxMTVNlcnZpY2Uoe1xuICAgICAgcHJvdmlkZXI6IGNoYXRSZXF1ZXN0LnByb3ZpZGVyLFxuICAgICAgYXBpS2V5OiBhY3R1YWxBcGlLZXksXG4gICAgICBiYXNlVXJsOiBiYXNlVXJsIHx8IGRlZmF1bHRDb25maWcuYmFzZVVybCxcbiAgICAgIG1vZGVsOiBjaGF0UmVxdWVzdC5tb2RlbCxcbiAgICAgIG1heFJldHJpZXM6IGRlZmF1bHRDb25maWcubWF4UmV0cmllcyxcbiAgICAgIHJldHJ5RGVsYXk6IGRlZmF1bHRDb25maWcucmV0cnlEZWxheSxcbiAgICAgIHRpbWVvdXQ6IGRlZmF1bHRDb25maWcudGltZW91dCxcbiAgICB9KTtcblxuICAgIC8vIEdldCBzZXNzaW9uIG1hbmFnZXJcbiAgICBjb25zdCBzZXNzaW9uTWFuYWdlciA9IGdldFNlc3Npb25NYW5hZ2VyKCk7XG5cbiAgICAvLyBDcmVhdGUgY2hhdCBwcm9jZXNzb3JcbiAgICBjb25zdCBjaGF0UHJvY2Vzc29yID0gY3JlYXRlQ2hhdFByb2Nlc3NvcihsbG1TZXJ2aWNlLCBzZXNzaW9uTWFuYWdlcik7XG5cbiAgICAvLyBQcm9jZXNzIHRoZSBjaGF0IHF1ZXJ5XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjaGF0UHJvY2Vzc29yLnByb2Nlc3NRdWVyeSh7XG4gICAgICBtZXNzYWdlczogY2hhdFJlcXVlc3QubWVzc2FnZXMsXG4gICAgICBzZXNzaW9uSWQ6IGNoYXRSZXF1ZXN0LnNlc3Npb25JZCxcbiAgICAgIHByb3ZpZGVyOiBjaGF0UmVxdWVzdC5wcm92aWRlcixcbiAgICAgIG1vZGVsOiBjaGF0UmVxdWVzdC5tb2RlbCxcbiAgICAgIGF2YWlsYWJsZVRvb2xzOiBhdmFpbGFibGVUb29scyB8fCBbXSxcbiAgICAgIHN5c3RlbVByb21wdCxcbiAgICAgIHRlbXBlcmF0dXJlLFxuICAgICAgbWF4VG9rZW5zLFxuICAgIH0pO1xuXG4gICAgY29uc3QgY2hhdFJlc3BvbnNlOiBDaGF0UmVzcG9uc2UgPSB7XG4gICAgICByZXBseTogcmVzcG9uc2UucmVwbHksXG4gICAgICB0b29sQ2FsbHM6IHJlc3BvbnNlLnRvb2xDYWxscyxcbiAgICAgIHNlc3Npb25JZDogcmVzcG9uc2Uuc2Vzc2lvbklkLFxuICAgIH07XG5cbiAgICBjb25zb2xlLmxvZyhgQ2hhdCByZXF1ZXN0IHByb2Nlc3NlZCBzdWNjZXNzZnVsbHkgZm9yIHNlc3Npb246ICR7cmVzcG9uc2Uuc2Vzc2lvbklkfWApO1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihjaGF0UmVzcG9uc2UpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0NoYXQgcHJvY2Vzc2luZyBlcnJvcjonLCBlcnJvcik7XG4gICAgXG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvciBvY2N1cnJlZCc7XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IGVycm9yIGluc3RhbmNlb2YgVmFsaWRhdGlvbkVycm9yID8gNDAwIDogNTAwO1xuICAgIFxuICAgIGNvbnN0IGNoYXRSZXNwb25zZTogQ2hhdFJlc3BvbnNlID0ge1xuICAgICAgc2Vzc2lvbklkOiBjaGF0UmVxdWVzdC5zZXNzaW9uSWQsXG4gICAgICBlcnJvcjogZXJyb3JNZXNzYWdlLFxuICAgIH07XG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oY2hhdFJlc3BvbnNlLCB7IHN0YXR1czogc3RhdHVzQ29kZSB9KTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgUE9TVCA9IHdpdGhTZWN1cml0eShjaGF0SGFuZGxlcik7XG5leHBvcnQgY29uc3QgT1BUSU9OUyA9IHdpdGhTZWN1cml0eShhc3luYyAoKSA9PiBuZXcgTmV4dFJlc3BvbnNlKG51bGwsIHsgc3RhdHVzOiAyMDAgfSkpOyJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJ3aXRoU2VjdXJpdHkiLCJWYWxpZGF0aW9uRXJyb3IiLCJ2YWxpZGF0ZUNoYXRSZXF1ZXN0IiwiZW5zdXJlSW5pdGlhbGl6ZWQiLCJjcmVhdGVMTE1TZXJ2aWNlIiwiZ2V0RGVmYXVsdFByb3ZpZGVyQ29uZmlnIiwiZ2V0U2Vzc2lvbk1hbmFnZXIiLCJjcmVhdGVDaGF0UHJvY2Vzc29yIiwiY2hhdEhhbmRsZXIiLCJyZXF1ZXN0IiwibWV0aG9kIiwianNvbiIsImVycm9yIiwic2Vzc2lvbklkIiwibWVzc2FnZSIsInN0YXR1cyIsImNvbnNvbGUiLCJsb2ciLCJib2R5IiwiY2hhdFJlcXVlc3QiLCJhcGlLZXkiLCJiYXNlVXJsIiwic3lzdGVtUHJvbXB0IiwidGVtcGVyYXR1cmUiLCJtYXhUb2tlbnMiLCJhdmFpbGFibGVUb29scyIsInByb3ZpZGVyIiwibW9kZWwiLCJhY3R1YWxBcGlLZXkiLCJnZXRTZWN1cmVTZXR0aW5nc01hbmFnZXIiLCJzZXR0aW5nc01hbmFnZXIiLCJpbml0aWFsaXplIiwic2V0dGluZ3MiLCJnZXRTZXR0aW5ncyIsImxsbVByb3ZpZGVycyIsImZpbmQiLCJwIiwibmFtZSIsImVuYWJsZWQiLCJnZXREZWNyeXB0ZWRBcGlLZXkiLCJpZCIsInRyaW0iLCJsZW5ndGgiLCJkZWZhdWx0Q29uZmlnIiwibGxtU2VydmljZSIsIm1heFJldHJpZXMiLCJyZXRyeURlbGF5IiwidGltZW91dCIsInNlc3Npb25NYW5hZ2VyIiwiY2hhdFByb2Nlc3NvciIsInJlc3BvbnNlIiwicHJvY2Vzc1F1ZXJ5IiwibWVzc2FnZXMiLCJjaGF0UmVzcG9uc2UiLCJyZXBseSIsInRvb2xDYWxscyIsImVycm9yTWVzc2FnZSIsIkVycm9yIiwic3RhdHVzQ29kZSIsIlBPU1QiLCJPUFRJT05TIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/chat/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/cors.ts":
/*!*************************!*\
  !*** ./src/lib/cors.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   corsHeaders: () => (/* binding */ corsHeaders),\n/* harmony export */   getSecurityHeaders: () => (/* binding */ getSecurityHeaders),\n/* harmony export */   handleCors: () => (/* binding */ handleCors),\n/* harmony export */   withCors: () => (/* binding */ withCors)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n\n// Development: Allow localhost with any port\n// Production: Use specific allowed origins\nconst isDevelopment = \"development\" !== 'production';\nconst LOCALHOST_PATTERN = /^http:\\/\\/localhost:\\d+$/;\nconst ALLOWED_PORTS = [\n    3000,\n    4173,\n    5173,\n    5174,\n    5175,\n    5176,\n    5177,\n    5178,\n    5179,\n    8080\n]; // Common dev ports\nconst PRODUCTION_ORIGINS = [\n    'https://your-domain.com'\n];\nfunction corsHeaders(origin) {\n    let allowedOrigin;\n    if (isDevelopment) {\n        if (origin && LOCALHOST_PATTERN.test(origin)) {\n            // In development, allow any localhost port\n            allowedOrigin = origin;\n        } else {\n            // Default to common dev server port\n            allowedOrigin = 'http://localhost:5173';\n        }\n    } else {\n        // In production, use strict origin checking\n        if (origin && PRODUCTION_ORIGINS.includes(origin)) {\n            allowedOrigin = origin;\n        } else {\n            allowedOrigin = PRODUCTION_ORIGINS[0] || 'http://localhost:5173';\n        }\n    }\n    const headers = {\n        // CORS headers\n        'Access-Control-Allow-Origin': allowedOrigin,\n        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n        'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',\n        'Access-Control-Allow-Credentials': 'true',\n        'Access-Control-Max-Age': '86400'\n    };\n    // Add security headers if enabled\n    if (process.env.SECURITY_HEADERS_ENABLED !== 'false') {\n        Object.assign(headers, getSecurityHeaders());\n    }\n    return headers;\n}\nfunction getSecurityHeaders() {\n    return {\n        // Prevent XSS attacks\n        'X-XSS-Protection': '1; mode=block',\n        // Prevent MIME type sniffing\n        'X-Content-Type-Options': 'nosniff',\n        // Prevent clickjacking\n        'X-Frame-Options': 'DENY',\n        // Referrer policy\n        'Referrer-Policy': 'strict-origin-when-cross-origin',\n        // Content Security Policy (restrictive for API)\n        'Content-Security-Policy': \"default-src 'none'; frame-ancestors 'none';\",\n        // Permissions policy\n        'Permissions-Policy': 'camera=(), microphone=(), geolocation=(), payment=()',\n        // HSTS (only in production with HTTPS)\n        ... false && 0\n    };\n}\nfunction handleCors(request) {\n    const origin = request.headers.get('origin');\n    return corsHeaders(origin || undefined);\n}\nfunction withCors(handler) {\n    return async (request, context)=>{\n        // Convert Request to NextRequest for CORS handling\n        const nextRequest = request;\n        const corsHeadersObj = handleCors(nextRequest);\n        if (request.method === 'OPTIONS') {\n            return new next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse(null, {\n                status: 200,\n                headers: corsHeadersObj\n            });\n        }\n        try {\n            const response = await handler(request, context);\n            // Add CORS headers to the response\n            Object.entries(corsHeadersObj).forEach(([key, value])=>{\n                response.headers.set(key, value);\n            });\n            return response;\n        } catch (error) {\n            console.error('CORS Handler Error:', error);\n            // Return proper JSON error response\n            const statusCode = error instanceof Error && 'statusCode' in error ? error.statusCode : 500;\n            const errorMessage = error instanceof Error ? error.message : 'Internal Server Error';\n            const response = next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: error instanceof Error ? error.name : 'Error',\n                message: errorMessage,\n                statusCode\n            }, {\n                status: statusCode\n            });\n            // Add CORS headers to error response\n            Object.entries(corsHeadersObj).forEach(([key, value])=>{\n                response.headers.set(key, value);\n            });\n            return response;\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL2NvcnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBd0Q7QUFFeEQsNkNBQTZDO0FBQzdDLDJDQUEyQztBQUMzQyxNQUFNQyxnQkFBZ0JDLGtCQUF5QjtBQUUvQyxNQUFNQyxvQkFBb0I7QUFDMUIsTUFBTUMsZ0JBQWdCO0lBQUM7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FBSyxFQUFFLG1CQUFtQjtBQUV2RyxNQUFNQyxxQkFBcUI7SUFDekI7Q0FDRDtBQUVNLFNBQVNDLFlBQVlDLE1BQWU7SUFDekMsSUFBSUM7SUFFSixJQUFJUCxlQUFlO1FBQ2pCLElBQUlNLFVBQVVKLGtCQUFrQk0sSUFBSSxDQUFDRixTQUFTO1lBQzVDLDJDQUEyQztZQUMzQ0MsZ0JBQWdCRDtRQUNsQixPQUFPO1lBQ0wsb0NBQW9DO1lBQ3BDQyxnQkFBZ0I7UUFDbEI7SUFDRixPQUFPO1FBQ0wsNENBQTRDO1FBQzVDLElBQUlELFVBQVVGLG1CQUFtQkssUUFBUSxDQUFDSCxTQUFTO1lBQ2pEQyxnQkFBZ0JEO1FBQ2xCLE9BQU87WUFDTEMsZ0JBQWdCSCxrQkFBa0IsQ0FBQyxFQUFFLElBQUk7UUFDM0M7SUFDRjtJQUVBLE1BQU1NLFVBQWtDO1FBQ3RDLGVBQWU7UUFDZiwrQkFBK0JIO1FBQy9CLGdDQUFnQztRQUNoQyxnQ0FBZ0M7UUFDaEMsb0NBQW9DO1FBQ3BDLDBCQUEwQjtJQUM1QjtJQUVBLGtDQUFrQztJQUNsQyxJQUFJTixRQUFRVSxHQUFHLENBQUNDLHdCQUF3QixLQUFLLFNBQVM7UUFDcERDLE9BQU9DLE1BQU0sQ0FBQ0osU0FBU0s7SUFDekI7SUFFQSxPQUFPTDtBQUNUO0FBRU8sU0FBU0s7SUFDZCxPQUFPO1FBQ0wsc0JBQXNCO1FBQ3RCLG9CQUFvQjtRQUVwQiw2QkFBNkI7UUFDN0IsMEJBQTBCO1FBRTFCLHVCQUF1QjtRQUN2QixtQkFBbUI7UUFFbkIsa0JBQWtCO1FBQ2xCLG1CQUFtQjtRQUVuQixnREFBZ0Q7UUFDaEQsMkJBQTJCO1FBRTNCLHFCQUFxQjtRQUNyQixzQkFBc0I7UUFFdEIsdUNBQXVDO1FBQ3ZDLEdBQUlkLE1BQXFDLElBQUksQ0FFNUM7SUFDSDtBQUNGO0FBRU8sU0FBU2UsV0FBV0MsT0FBb0I7SUFDN0MsTUFBTVgsU0FBU1csUUFBUVAsT0FBTyxDQUFDUSxHQUFHLENBQUM7SUFDbkMsT0FBT2IsWUFBWUMsVUFBVWE7QUFDL0I7QUFFTyxTQUFTQyxTQUFTQyxPQUFtRTtJQUMxRixPQUFPLE9BQU9KLFNBQWtCSztRQUM5QixtREFBbUQ7UUFDbkQsTUFBTUMsY0FBY047UUFDcEIsTUFBTU8saUJBQWlCUixXQUFXTztRQUVsQyxJQUFJTixRQUFRUSxNQUFNLEtBQUssV0FBVztZQUNoQyxPQUFPLElBQUkxQixxREFBWUEsQ0FBQyxNQUFNO2dCQUFFMkIsUUFBUTtnQkFBS2hCLFNBQVNjO1lBQWU7UUFDdkU7UUFFQSxJQUFJO1lBQ0YsTUFBTUcsV0FBVyxNQUFNTixRQUFRSixTQUFTSztZQUV4QyxtQ0FBbUM7WUFDbkNULE9BQU9lLE9BQU8sQ0FBQ0osZ0JBQWdCSyxPQUFPLENBQUMsQ0FBQyxDQUFDQyxLQUFLQyxNQUFNO2dCQUNsREosU0FBU2pCLE9BQU8sQ0FBQ3NCLEdBQUcsQ0FBQ0YsS0FBS0M7WUFDNUI7WUFFQSxPQUFPSjtRQUNULEVBQUUsT0FBT00sT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsdUJBQXVCQTtZQUVyQyxvQ0FBb0M7WUFDcEMsTUFBTUUsYUFBYUYsaUJBQWlCRyxTQUFTLGdCQUFnQkgsUUFDM0QsTUFBZUUsVUFBVSxHQUFHO1lBQzlCLE1BQU1FLGVBQWVKLGlCQUFpQkcsUUFBUUgsTUFBTUssT0FBTyxHQUFHO1lBRTlELE1BQU1YLFdBQVc1QixxREFBWUEsQ0FBQ3dDLElBQUksQ0FDaEM7Z0JBQ0VOLE9BQU9BLGlCQUFpQkcsUUFBUUgsTUFBTU8sSUFBSSxHQUFHO2dCQUM3Q0YsU0FBU0Q7Z0JBQ1RGO1lBQ0YsR0FDQTtnQkFBRVQsUUFBUVM7WUFBVztZQUd2QixxQ0FBcUM7WUFDckN0QixPQUFPZSxPQUFPLENBQUNKLGdCQUFnQkssT0FBTyxDQUFDLENBQUMsQ0FBQ0MsS0FBS0MsTUFBTTtnQkFDbERKLFNBQVNqQixPQUFPLENBQUNzQixHQUFHLENBQUNGLEtBQUtDO1lBQzVCO1lBRUEsT0FBT0o7UUFDVDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9vbmViaXJkL2dpdGh1Yi9lYm9vay1tY3AvbWNwLWNoYXQtdWkvYmFja2VuZC9zcmMvbGliL2NvcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcblxuLy8gRGV2ZWxvcG1lbnQ6IEFsbG93IGxvY2FsaG9zdCB3aXRoIGFueSBwb3J0XG4vLyBQcm9kdWN0aW9uOiBVc2Ugc3BlY2lmaWMgYWxsb3dlZCBvcmlnaW5zXG5jb25zdCBpc0RldmVsb3BtZW50ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJztcblxuY29uc3QgTE9DQUxIT1NUX1BBVFRFUk4gPSAvXmh0dHA6XFwvXFwvbG9jYWxob3N0OlxcZCskLztcbmNvbnN0IEFMTE9XRURfUE9SVFMgPSBbMzAwMCwgNDE3MywgNTE3MywgNTE3NCwgNTE3NSwgNTE3NiwgNTE3NywgNTE3OCwgNTE3OSwgODA4MF07IC8vIENvbW1vbiBkZXYgcG9ydHNcblxuY29uc3QgUFJPRFVDVElPTl9PUklHSU5TID0gW1xuICAnaHR0cHM6Ly95b3VyLWRvbWFpbi5jb20nLCAvLyBBZGQgeW91ciBwcm9kdWN0aW9uIGRvbWFpbiBoZXJlXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gY29yc0hlYWRlcnMob3JpZ2luPzogc3RyaW5nKSB7XG4gIGxldCBhbGxvd2VkT3JpZ2luOiBzdHJpbmc7XG4gIFxuICBpZiAoaXNEZXZlbG9wbWVudCkge1xuICAgIGlmIChvcmlnaW4gJiYgTE9DQUxIT1NUX1BBVFRFUk4udGVzdChvcmlnaW4pKSB7XG4gICAgICAvLyBJbiBkZXZlbG9wbWVudCwgYWxsb3cgYW55IGxvY2FsaG9zdCBwb3J0XG4gICAgICBhbGxvd2VkT3JpZ2luID0gb3JpZ2luO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IHRvIGNvbW1vbiBkZXYgc2VydmVyIHBvcnRcbiAgICAgIGFsbG93ZWRPcmlnaW4gPSAnaHR0cDovL2xvY2FsaG9zdDo1MTczJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdXNlIHN0cmljdCBvcmlnaW4gY2hlY2tpbmdcbiAgICBpZiAob3JpZ2luICYmIFBST0RVQ1RJT05fT1JJR0lOUy5pbmNsdWRlcyhvcmlnaW4pKSB7XG4gICAgICBhbGxvd2VkT3JpZ2luID0gb3JpZ2luO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbGxvd2VkT3JpZ2luID0gUFJPRFVDVElPTl9PUklHSU5TWzBdIHx8ICdodHRwOi8vbG9jYWxob3N0OjUxNzMnO1xuICAgIH1cbiAgfVxuICBcbiAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAvLyBDT1JTIGhlYWRlcnNcbiAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogYWxsb3dlZE9yaWdpbixcbiAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctTWV0aG9kcyc6ICdHRVQsIFBPU1QsIFBVVCwgREVMRVRFLCBPUFRJT05TJyxcbiAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVycyc6ICdDb250ZW50LVR5cGUsIEF1dGhvcml6YXRpb24sIFgtUmVxdWVzdGVkLVdpdGgnLFxuICAgICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFscyc6ICd0cnVlJyxcbiAgICAnQWNjZXNzLUNvbnRyb2wtTWF4LUFnZSc6ICc4NjQwMCcsIC8vIDI0IGhvdXJzXG4gIH07XG5cbiAgLy8gQWRkIHNlY3VyaXR5IGhlYWRlcnMgaWYgZW5hYmxlZFxuICBpZiAocHJvY2Vzcy5lbnYuU0VDVVJJVFlfSEVBREVSU19FTkFCTEVEICE9PSAnZmFsc2UnKSB7XG4gICAgT2JqZWN0LmFzc2lnbihoZWFkZXJzLCBnZXRTZWN1cml0eUhlYWRlcnMoKSk7XG4gIH1cblxuICByZXR1cm4gaGVhZGVycztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlY3VyaXR5SGVhZGVycygpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgcmV0dXJuIHtcbiAgICAvLyBQcmV2ZW50IFhTUyBhdHRhY2tzXG4gICAgJ1gtWFNTLVByb3RlY3Rpb24nOiAnMTsgbW9kZT1ibG9jaycsXG4gICAgXG4gICAgLy8gUHJldmVudCBNSU1FIHR5cGUgc25pZmZpbmdcbiAgICAnWC1Db250ZW50LVR5cGUtT3B0aW9ucyc6ICdub3NuaWZmJyxcbiAgICBcbiAgICAvLyBQcmV2ZW50IGNsaWNramFja2luZ1xuICAgICdYLUZyYW1lLU9wdGlvbnMnOiAnREVOWScsXG4gICAgXG4gICAgLy8gUmVmZXJyZXIgcG9saWN5XG4gICAgJ1JlZmVycmVyLVBvbGljeSc6ICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJyxcbiAgICBcbiAgICAvLyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSAocmVzdHJpY3RpdmUgZm9yIEFQSSlcbiAgICAnQ29udGVudC1TZWN1cml0eS1Qb2xpY3knOiBcImRlZmF1bHQtc3JjICdub25lJzsgZnJhbWUtYW5jZXN0b3JzICdub25lJztcIixcbiAgICBcbiAgICAvLyBQZXJtaXNzaW9ucyBwb2xpY3lcbiAgICAnUGVybWlzc2lvbnMtUG9saWN5JzogJ2NhbWVyYT0oKSwgbWljcm9waG9uZT0oKSwgZ2VvbG9jYXRpb249KCksIHBheW1lbnQ9KCknLFxuICAgIFxuICAgIC8vIEhTVFMgKG9ubHkgaW4gcHJvZHVjdGlvbiB3aXRoIEhUVFBTKVxuICAgIC4uLihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmIHtcbiAgICAgICdTdHJpY3QtVHJhbnNwb3J0LVNlY3VyaXR5JzogJ21heC1hZ2U9MzE1MzYwMDA7IGluY2x1ZGVTdWJEb21haW5zOyBwcmVsb2FkJ1xuICAgIH0pLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlQ29ycyhyZXF1ZXN0OiBOZXh0UmVxdWVzdCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICBjb25zdCBvcmlnaW4gPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KCdvcmlnaW4nKTtcbiAgcmV0dXJuIGNvcnNIZWFkZXJzKG9yaWdpbiB8fCB1bmRlZmluZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2l0aENvcnMoaGFuZGxlcjogKHJlcXVlc3Q6IFJlcXVlc3QsIGNvbnRleHQ/OiBhbnkpID0+IFByb21pc2U8TmV4dFJlc3BvbnNlPikge1xuICByZXR1cm4gYXN5bmMgKHJlcXVlc3Q6IFJlcXVlc3QsIGNvbnRleHQ/OiBhbnkpID0+IHtcbiAgICAvLyBDb252ZXJ0IFJlcXVlc3QgdG8gTmV4dFJlcXVlc3QgZm9yIENPUlMgaGFuZGxpbmdcbiAgICBjb25zdCBuZXh0UmVxdWVzdCA9IHJlcXVlc3QgYXMgTmV4dFJlcXVlc3Q7XG4gICAgY29uc3QgY29yc0hlYWRlcnNPYmogPSBoYW5kbGVDb3JzKG5leHRSZXF1ZXN0KTtcbiAgICBcbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09ICdPUFRJT05TJykge1xuICAgICAgcmV0dXJuIG5ldyBOZXh0UmVzcG9uc2UobnVsbCwgeyBzdGF0dXM6IDIwMCwgaGVhZGVyczogY29yc0hlYWRlcnNPYmogfSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlcihyZXF1ZXN0LCBjb250ZXh0KTtcbiAgICAgIFxuICAgICAgLy8gQWRkIENPUlMgaGVhZGVycyB0byB0aGUgcmVzcG9uc2VcbiAgICAgIE9iamVjdC5lbnRyaWVzKGNvcnNIZWFkZXJzT2JqKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDT1JTIEhhbmRsZXIgRXJyb3I6JywgZXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBSZXR1cm4gcHJvcGVyIEpTT04gZXJyb3IgcmVzcG9uc2VcbiAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICdzdGF0dXNDb2RlJyBpbiBlcnJvciA/IFxuICAgICAgICAoZXJyb3IgYXMgYW55KS5zdGF0dXNDb2RlIDogNTAwO1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yJztcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAge1xuICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubmFtZSA6ICdFcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgIH0sXG4gICAgICAgIHsgc3RhdHVzOiBzdGF0dXNDb2RlIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBDT1JTIGhlYWRlcnMgdG8gZXJyb3IgcmVzcG9uc2VcbiAgICAgIE9iamVjdC5lbnRyaWVzKGNvcnNIZWFkZXJzT2JqKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgfTtcbn0iXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwiaXNEZXZlbG9wbWVudCIsInByb2Nlc3MiLCJMT0NBTEhPU1RfUEFUVEVSTiIsIkFMTE9XRURfUE9SVFMiLCJQUk9EVUNUSU9OX09SSUdJTlMiLCJjb3JzSGVhZGVycyIsIm9yaWdpbiIsImFsbG93ZWRPcmlnaW4iLCJ0ZXN0IiwiaW5jbHVkZXMiLCJoZWFkZXJzIiwiZW52IiwiU0VDVVJJVFlfSEVBREVSU19FTkFCTEVEIiwiT2JqZWN0IiwiYXNzaWduIiwiZ2V0U2VjdXJpdHlIZWFkZXJzIiwiaGFuZGxlQ29ycyIsInJlcXVlc3QiLCJnZXQiLCJ1bmRlZmluZWQiLCJ3aXRoQ29ycyIsImhhbmRsZXIiLCJjb250ZXh0IiwibmV4dFJlcXVlc3QiLCJjb3JzSGVhZGVyc09iaiIsIm1ldGhvZCIsInN0YXR1cyIsInJlc3BvbnNlIiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsInNldCIsImVycm9yIiwiY29uc29sZSIsInN0YXR1c0NvZGUiLCJFcnJvciIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJqc29uIiwibmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/cors.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/encryption.ts":
/*!*******************************!*\
  !*** ./src/lib/encryption.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EncryptionService: () => (/* binding */ EncryptionService),\n/* harmony export */   getEncryptionService: () => (/* binding */ getEncryptionService)\n/* harmony export */ });\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto-js */ \"(rsc)/./node_modules/crypto-js/index.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(rsc)/./src/lib/errors.ts\");\n\n\n/**\n * Encryption utility for securing sensitive data like API keys\n */ class EncryptionService {\n    constructor(){\n        // Get encryption key from environment or generate a default one\n        this.secretKey = process.env.ENCRYPTION_KEY || this.generateDefaultKey();\n        if (!process.env.ENCRYPTION_KEY) {\n            console.warn('ENCRYPTION_KEY not set in environment. Using generated key. This is not secure for production!');\n        }\n    }\n    /**\n   * Encrypt sensitive data\n   */ encrypt(data) {\n        try {\n            if (!data) return '';\n            const encrypted = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.encrypt(data, this.secretKey).toString();\n            return encrypted;\n        } catch (error) {\n            console.error('Encryption failed:', error);\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.InternalServerError('Failed to encrypt data');\n        }\n    }\n    /**\n   * Decrypt sensitive data\n   */ decrypt(encryptedData) {\n        try {\n            if (!encryptedData) return '';\n            const bytes = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.decrypt(encryptedData, this.secretKey);\n            const decrypted = bytes.toString((crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc).Utf8);\n            if (!decrypted) {\n                throw new Error('Failed to decrypt data - invalid key or corrupted data');\n            }\n            return decrypted;\n        } catch (error) {\n            console.error('Decryption failed:', error);\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.InternalServerError('Failed to decrypt data');\n        }\n    }\n    /**\n   * Hash data for secure comparison (one-way)\n   */ hash(data) {\n        try {\n            return crypto_js__WEBPACK_IMPORTED_MODULE_0___default().SHA256(data).toString();\n        } catch (error) {\n            console.error('Hashing failed:', error);\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.InternalServerError('Failed to hash data');\n        }\n    }\n    /**\n   * Generate a secure random key\n   */ generateSecureKey() {\n        return crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.random(256 / 8).toString();\n    }\n    /**\n   * Mask sensitive data for display (show only last 4 characters with limited mask length)\n   */ maskApiKey(apiKey) {\n        if (!apiKey || apiKey.length < 8) {\n            return '';\n        }\n        const visibleChars = 4;\n        const maxMaskLength = 8; // Limit mask length to prevent UI overflow\n        const actualMaskLength = Math.min(maxMaskLength, Math.max(0, apiKey.length - visibleChars));\n        const maskedPart = ''.repeat(actualMaskLength);\n        const visiblePart = apiKey.slice(-visibleChars);\n        return maskedPart + visiblePart;\n    }\n    /**\n   * Validate if a string appears to be encrypted\n   */ isEncrypted(data) {\n        try {\n            // Try to decrypt - if it fails, it's likely not encrypted\n            this.decrypt(data);\n            return true;\n        } catch  {\n            return false;\n        }\n    }\n    generateDefaultKey() {\n        // Generate a consistent but unique key based on system info\n        // This is NOT secure for production - should use proper environment variable\n        const systemInfo = process.platform + process.arch + (process.env.HOME || process.env.USERPROFILE || 'default');\n        return crypto_js__WEBPACK_IMPORTED_MODULE_0___default().SHA256(systemInfo + 'mcp-chat-ui-default-key').toString();\n    }\n}\n// Singleton instance\nlet encryptionService = null;\nfunction getEncryptionService() {\n    if (!encryptionService) {\n        encryptionService = new EncryptionService();\n    }\n    return encryptionService;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDRjtBQUVBLHFCQUFxQjtBQUNyQixJQUFJa0Msb0JBQThDO0FBRTNDLFNBQVNDO0lBQ2QsSUFBSSxDQUFDRCxtQkFBbUI7UUFDdEJBLG9CQUFvQixJQUFJOUM7SUFDMUI7SUFDQSxPQUFPOEM7QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL29uZWJpcmQvZ2l0aHViL2Vib29rLW1jcC9tY3AtY2hhdC11aS9iYWNrZW5kL3NyYy9saWIvZW5jcnlwdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ3J5cHRvSlMgZnJvbSAnY3J5cHRvLWpzJztcbmltcG9ydCB7IEludGVybmFsU2VydmVyRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5cbi8qKlxuICogRW5jcnlwdGlvbiB1dGlsaXR5IGZvciBzZWN1cmluZyBzZW5zaXRpdmUgZGF0YSBsaWtlIEFQSSBrZXlzXG4gKi9cbmV4cG9ydCBjbGFzcyBFbmNyeXB0aW9uU2VydmljZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2VjcmV0S2V5OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gR2V0IGVuY3J5cHRpb24ga2V5IGZyb20gZW52aXJvbm1lbnQgb3IgZ2VuZXJhdGUgYSBkZWZhdWx0IG9uZVxuICAgIHRoaXMuc2VjcmV0S2V5ID0gcHJvY2Vzcy5lbnYuRU5DUllQVElPTl9LRVkgfHwgdGhpcy5nZW5lcmF0ZURlZmF1bHRLZXkoKTtcbiAgICBcbiAgICBpZiAoIXByb2Nlc3MuZW52LkVOQ1JZUFRJT05fS0VZKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0VOQ1JZUFRJT05fS0VZIG5vdCBzZXQgaW4gZW52aXJvbm1lbnQuIFVzaW5nIGdlbmVyYXRlZCBrZXkuIFRoaXMgaXMgbm90IHNlY3VyZSBmb3IgcHJvZHVjdGlvbiEnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5jcnlwdCBzZW5zaXRpdmUgZGF0YVxuICAgKi9cbiAgZW5jcnlwdChkYXRhOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWRhdGEpIHJldHVybiAnJztcbiAgICAgIFxuICAgICAgY29uc3QgZW5jcnlwdGVkID0gQ3J5cHRvSlMuQUVTLmVuY3J5cHQoZGF0YSwgdGhpcy5zZWNyZXRLZXkpLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gZW5jcnlwdGVkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFbmNyeXB0aW9uIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxTZXJ2ZXJFcnJvcignRmFpbGVkIHRvIGVuY3J5cHQgZGF0YScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNyeXB0IHNlbnNpdGl2ZSBkYXRhXG4gICAqL1xuICBkZWNyeXB0KGVuY3J5cHRlZERhdGE6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghZW5jcnlwdGVkRGF0YSkgcmV0dXJuICcnO1xuICAgICAgXG4gICAgICBjb25zdCBieXRlcyA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KGVuY3J5cHRlZERhdGEsIHRoaXMuc2VjcmV0S2V5KTtcbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGJ5dGVzLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcbiAgICAgIFxuICAgICAgaWYgKCFkZWNyeXB0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVjcnlwdCBkYXRhIC0gaW52YWxpZCBrZXkgb3IgY29ycnVwdGVkIGRhdGEnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGRlY3J5cHRlZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRGVjcnlwdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsU2VydmVyRXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IGRhdGEnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFzaCBkYXRhIGZvciBzZWN1cmUgY29tcGFyaXNvbiAob25lLXdheSlcbiAgICovXG4gIGhhc2goZGF0YTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIENyeXB0b0pTLlNIQTI1NihkYXRhKS50b1N0cmluZygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdIYXNoaW5nIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxTZXJ2ZXJFcnJvcignRmFpbGVkIHRvIGhhc2ggZGF0YScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHNlY3VyZSByYW5kb20ga2V5XG4gICAqL1xuICBnZW5lcmF0ZVNlY3VyZUtleSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgyNTYvOCkudG9TdHJpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXNrIHNlbnNpdGl2ZSBkYXRhIGZvciBkaXNwbGF5IChzaG93IG9ubHkgbGFzdCA0IGNoYXJhY3RlcnMgd2l0aCBsaW1pdGVkIG1hc2sgbGVuZ3RoKVxuICAgKi9cbiAgbWFza0FwaUtleShhcGlLZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKCFhcGlLZXkgfHwgYXBpS2V5Lmxlbmd0aCA8IDgpIHtcbiAgICAgIHJldHVybiAn4oCi4oCi4oCi4oCiJztcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdmlzaWJsZUNoYXJzID0gNDtcbiAgICBjb25zdCBtYXhNYXNrTGVuZ3RoID0gODsgLy8gTGltaXQgbWFzayBsZW5ndGggdG8gcHJldmVudCBVSSBvdmVyZmxvd1xuICAgIGNvbnN0IGFjdHVhbE1hc2tMZW5ndGggPSBNYXRoLm1pbihtYXhNYXNrTGVuZ3RoLCBNYXRoLm1heCgwLCBhcGlLZXkubGVuZ3RoIC0gdmlzaWJsZUNoYXJzKSk7XG4gICAgY29uc3QgbWFza2VkUGFydCA9ICfigKInLnJlcGVhdChhY3R1YWxNYXNrTGVuZ3RoKTtcbiAgICBjb25zdCB2aXNpYmxlUGFydCA9IGFwaUtleS5zbGljZSgtdmlzaWJsZUNoYXJzKTtcbiAgICBcbiAgICByZXR1cm4gbWFza2VkUGFydCArIHZpc2libGVQYXJ0O1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGlmIGEgc3RyaW5nIGFwcGVhcnMgdG8gYmUgZW5jcnlwdGVkXG4gICAqL1xuICBpc0VuY3J5cHRlZChkYXRhOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgLy8gVHJ5IHRvIGRlY3J5cHQgLSBpZiBpdCBmYWlscywgaXQncyBsaWtlbHkgbm90IGVuY3J5cHRlZFxuICAgICAgdGhpcy5kZWNyeXB0KGRhdGEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZURlZmF1bHRLZXkoKTogc3RyaW5nIHtcbiAgICAvLyBHZW5lcmF0ZSBhIGNvbnNpc3RlbnQgYnV0IHVuaXF1ZSBrZXkgYmFzZWQgb24gc3lzdGVtIGluZm9cbiAgICAvLyBUaGlzIGlzIE5PVCBzZWN1cmUgZm9yIHByb2R1Y3Rpb24gLSBzaG91bGQgdXNlIHByb3BlciBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICAgIGNvbnN0IHN5c3RlbUluZm8gPSBwcm9jZXNzLnBsYXRmb3JtICsgcHJvY2Vzcy5hcmNoICsgKHByb2Nlc3MuZW52LkhPTUUgfHwgcHJvY2Vzcy5lbnYuVVNFUlBST0ZJTEUgfHwgJ2RlZmF1bHQnKTtcbiAgICByZXR1cm4gQ3J5cHRvSlMuU0hBMjU2KHN5c3RlbUluZm8gKyAnbWNwLWNoYXQtdWktZGVmYXVsdC1rZXknKS50b1N0cmluZygpO1xuICB9XG59XG5cbi8vIFNpbmdsZXRvbiBpbnN0YW5jZVxubGV0IGVuY3J5cHRpb25TZXJ2aWNlOiBFbmNyeXB0aW9uU2VydmljZSB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW5jcnlwdGlvblNlcnZpY2UoKTogRW5jcnlwdGlvblNlcnZpY2Uge1xuICBpZiAoIWVuY3J5cHRpb25TZXJ2aWNlKSB7XG4gICAgZW5jcnlwdGlvblNlcnZpY2UgPSBuZXcgRW5jcnlwdGlvblNlcnZpY2UoKTtcbiAgfVxuICByZXR1cm4gZW5jcnlwdGlvblNlcnZpY2U7XG59Il0sIm5hbWVzIjpbIkNyeXB0b0pTIiwiSW50ZXJuYWxTZXJ2ZXJFcnJvciIsIkVuY3J5cHRpb25TZXJ2aWNlIiwic2VjcmV0S2V5IiwicHJvY2VzcyIsImVudiIsIkVOQ1JZUFRJT05fS0VZIiwiZ2VuZXJhdGVEZWZhdWx0S2V5IiwiY29uc29sZSIsIndhcm4iLCJlbmNyeXB0IiwiZGF0YSIsImVuY3J5cHRlZCIsIkFFUyIsInRvU3RyaW5nIiwiZXJyb3IiLCJkZWNyeXB0IiwiZW5jcnlwdGVkRGF0YSIsImJ5dGVzIiwiZGVjcnlwdGVkIiwiZW5jIiwiVXRmOCIsIkVycm9yIiwiaGFzaCIsIlNIQTI1NiIsImdlbmVyYXRlU2VjdXJlS2V5IiwibGliIiwiV29yZEFycmF5IiwicmFuZG9tIiwibWFza0FwaUtleSIsImFwaUtleSIsImxlbmd0aCIsInZpc2libGVDaGFycyIsIm1heE1hc2tMZW5ndGgiLCJhY3R1YWxNYXNrTGVuZ3RoIiwiTWF0aCIsIm1pbiIsIm1heCIsIm1hc2tlZFBhcnQiLCJyZXBlYXQiLCJ2aXNpYmxlUGFydCIsInNsaWNlIiwiaXNFbmNyeXB0ZWQiLCJzeXN0ZW1JbmZvIiwicGxhdGZvcm0iLCJhcmNoIiwiSE9NRSIsIlVTRVJQUk9GSUxFIiwiZW5jcnlwdGlvblNlcnZpY2UiLCJnZXRFbmNyeXB0aW9uU2VydmljZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/encryption.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/errors.ts":
/*!***************************!*\
  !*** ./src/lib/errors.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppError: () => (/* binding */ AppError),\n/* harmony export */   InternalServerError: () => (/* binding */ InternalServerError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   ToolExecutionError: () => (/* binding */ ToolExecutionError),\n/* harmony export */   UnauthorizedError: () => (/* binding */ UnauthorizedError),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError),\n/* harmony export */   createErrorResponse: () => (/* binding */ createErrorResponse),\n/* harmony export */   handleAsyncRoute: () => (/* binding */ handleAsyncRoute)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n\nclass AppError extends Error {\n    constructor(message, statusCode = 500, isOperational = true){\n        super(message);\n        this.statusCode = statusCode;\n        this.isOperational = isOperational;\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\nclass ValidationError extends AppError {\n    constructor(message){\n        super(message, 400);\n    }\n}\nclass NotFoundError extends AppError {\n    constructor(message = 'Resource not found'){\n        super(message, 404);\n    }\n}\nclass UnauthorizedError extends AppError {\n    constructor(message = 'Unauthorized'){\n        super(message, 401);\n    }\n}\nclass InternalServerError extends AppError {\n    constructor(message = 'Internal server error'){\n        super(message, 500);\n    }\n}\nclass ToolExecutionError extends AppError {\n    constructor(message, statusCode = 500){\n        super(message, statusCode);\n    }\n}\nfunction createErrorResponse(error) {\n    console.error('API Error:', error);\n    if (error instanceof AppError) {\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: error.constructor.name,\n            message: error.message,\n            statusCode: error.statusCode\n        }, {\n            status: error.statusCode\n        });\n    }\n    if (error instanceof Error) {\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: 'InternalServerError',\n            message: error.message,\n            statusCode: 500\n        }, {\n            status: 500\n        });\n    }\n    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n        error: 'UnknownError',\n        message: 'An unknown error occurred',\n        statusCode: 500\n    }, {\n        status: 500\n    });\n}\nfunction handleAsyncRoute(handler) {\n    return async (request, context)=>{\n        try {\n            return await handler(request, context);\n        } catch (error) {\n            return createErrorResponse(error);\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL2Vycm9ycy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBd0Q7QUFHakQsTUFBTUMsaUJBQWlCQztJQUk1QixZQUFZQyxPQUFlLEVBQUVDLGFBQXFCLEdBQUcsRUFBRUMsZ0JBQXlCLElBQUksQ0FBRTtRQUNwRixLQUFLLENBQUNGO1FBQ04sSUFBSSxDQUFDQyxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ0MsYUFBYSxHQUFHQTtRQUVyQkgsTUFBTUksaUJBQWlCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxXQUFXO0lBQ2hEO0FBQ0Y7QUFFTyxNQUFNQyx3QkFBd0JOO0lBQ25DLFlBQVlFLE9BQWUsQ0FBRTtRQUMzQixLQUFLLENBQUNBLFNBQVM7SUFDakI7QUFDRjtBQUVPLE1BQU1LLHNCQUFzQlA7SUFDakMsWUFBWUUsVUFBa0Isb0JBQW9CLENBQUU7UUFDbEQsS0FBSyxDQUFDQSxTQUFTO0lBQ2pCO0FBQ0Y7QUFFTyxNQUFNTSwwQkFBMEJSO0lBQ3JDLFlBQVlFLFVBQWtCLGNBQWMsQ0FBRTtRQUM1QyxLQUFLLENBQUNBLFNBQVM7SUFDakI7QUFDRjtBQUVPLE1BQU1PLDRCQUE0QlQ7SUFDdkMsWUFBWUUsVUFBa0IsdUJBQXVCLENBQUU7UUFDckQsS0FBSyxDQUFDQSxTQUFTO0lBQ2pCO0FBQ0Y7QUFFTyxNQUFNUSwyQkFBMkJWO0lBQ3RDLFlBQVlFLE9BQWUsRUFBRUMsYUFBcUIsR0FBRyxDQUFFO1FBQ3JELEtBQUssQ0FBQ0QsU0FBU0M7SUFDakI7QUFDRjtBQUVPLFNBQVNRLG9CQUFvQkMsS0FBYztJQUNoREMsUUFBUUQsS0FBSyxDQUFDLGNBQWNBO0lBRTVCLElBQUlBLGlCQUFpQlosVUFBVTtRQUM3QixPQUFPRCxxREFBWUEsQ0FBQ2UsSUFBSSxDQUN0QjtZQUNFRixPQUFPQSxNQUFNLFdBQVcsQ0FBQ0csSUFBSTtZQUM3QmIsU0FBU1UsTUFBTVYsT0FBTztZQUN0QkMsWUFBWVMsTUFBTVQsVUFBVTtRQUM5QixHQUNBO1lBQUVhLFFBQVFKLE1BQU1ULFVBQVU7UUFBQztJQUUvQjtJQUVBLElBQUlTLGlCQUFpQlgsT0FBTztRQUMxQixPQUFPRixxREFBWUEsQ0FBQ2UsSUFBSSxDQUN0QjtZQUNFRixPQUFPO1lBQ1BWLFNBQVNVLE1BQU1WLE9BQU87WUFDdEJDLFlBQVk7UUFDZCxHQUNBO1lBQUVhLFFBQVE7UUFBSTtJQUVsQjtJQUVBLE9BQU9qQixxREFBWUEsQ0FBQ2UsSUFBSSxDQUN0QjtRQUNFRixPQUFPO1FBQ1BWLFNBQVM7UUFDVEMsWUFBWTtJQUNkLEdBQ0E7UUFBRWEsUUFBUTtJQUFJO0FBRWxCO0FBRU8sU0FBU0MsaUJBQ2RDLE9BQW1FO0lBRW5FLE9BQU8sT0FBT0MsU0FBa0JDO1FBQzlCLElBQUk7WUFDRixPQUFPLE1BQU1GLFFBQVFDLFNBQVNDO1FBQ2hDLEVBQUUsT0FBT1IsT0FBTztZQUNkLE9BQU9ELG9CQUFvQkM7UUFDN0I7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvb25lYmlyZC9naXRodWIvZWJvb2stbWNwL21jcC1jaGF0LXVpL2JhY2tlbmQvc3JjL2xpYi9lcnJvcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IEFwaUVycm9yIH0gZnJvbSAnQC90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBBcHBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHVibGljIHN0YXR1c0NvZGU6IG51bWJlcjtcbiAgcHVibGljIGlzT3BlcmF0aW9uYWw6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBzdGF0dXNDb2RlOiBudW1iZXIgPSA1MDAsIGlzT3BlcmF0aW9uYWw6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLmlzT3BlcmF0aW9uYWwgPSBpc09wZXJhdGlvbmFsO1xuXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEFwcEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgNDAwKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIEFwcEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nID0gJ1Jlc291cmNlIG5vdCBmb3VuZCcpIHtcbiAgICBzdXBlcihtZXNzYWdlLCA0MDQpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVbmF1dGhvcml6ZWRFcnJvciBleHRlbmRzIEFwcEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nID0gJ1VuYXV0aG9yaXplZCcpIHtcbiAgICBzdXBlcihtZXNzYWdlLCA0MDEpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJbnRlcm5hbFNlcnZlckVycm9yIGV4dGVuZHMgQXBwRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcgPSAnSW50ZXJuYWwgc2VydmVyIGVycm9yJykge1xuICAgIHN1cGVyKG1lc3NhZ2UsIDUwMCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRvb2xFeGVjdXRpb25FcnJvciBleHRlbmRzIEFwcEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBzdGF0dXNDb2RlOiBudW1iZXIgPSA1MDApIHtcbiAgICBzdXBlcihtZXNzYWdlLCBzdGF0dXNDb2RlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXJyb3JSZXNwb25zZShlcnJvcjogdW5rbm93bik6IE5leHRSZXNwb25zZTxBcGlFcnJvcj4ge1xuICBjb25zb2xlLmVycm9yKCdBUEkgRXJyb3I6JywgZXJyb3IpO1xuXG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEFwcEVycm9yKSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAge1xuICAgICAgICBlcnJvcjogZXJyb3IuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgc3RhdHVzQ29kZTogZXJyb3Iuc3RhdHVzQ29kZSxcbiAgICAgIH0sXG4gICAgICB7IHN0YXR1czogZXJyb3Iuc3RhdHVzQ29kZSB9XG4gICAgKTtcbiAgfVxuXG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAge1xuICAgICAgICBlcnJvcjogJ0ludGVybmFsU2VydmVyRXJyb3InLFxuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgICB9LFxuICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICB7XG4gICAgICBlcnJvcjogJ1Vua25vd25FcnJvcicsXG4gICAgICBtZXNzYWdlOiAnQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCcsXG4gICAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgfSxcbiAgICB7IHN0YXR1czogNTAwIH1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUFzeW5jUm91dGUoXG4gIGhhbmRsZXI6IChyZXF1ZXN0OiBSZXF1ZXN0LCBjb250ZXh0PzogYW55KSA9PiBQcm9taXNlPE5leHRSZXNwb25zZT5cbikge1xuICByZXR1cm4gYXN5bmMgKHJlcXVlc3Q6IFJlcXVlc3QsIGNvbnRleHQ/OiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZXIocmVxdWVzdCwgY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFcnJvclJlc3BvbnNlKGVycm9yKTtcbiAgICB9XG4gIH07XG59Il0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsIkFwcEVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwic3RhdHVzQ29kZSIsImlzT3BlcmF0aW9uYWwiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIlZhbGlkYXRpb25FcnJvciIsIk5vdEZvdW5kRXJyb3IiLCJVbmF1dGhvcml6ZWRFcnJvciIsIkludGVybmFsU2VydmVyRXJyb3IiLCJUb29sRXhlY3V0aW9uRXJyb3IiLCJjcmVhdGVFcnJvclJlc3BvbnNlIiwiZXJyb3IiLCJjb25zb2xlIiwianNvbiIsIm5hbWUiLCJzdGF0dXMiLCJoYW5kbGVBc3luY1JvdXRlIiwiaGFuZGxlciIsInJlcXVlc3QiLCJjb250ZXh0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/errors.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/initialization.ts":
/*!***********************************!*\
  !*** ./src/lib/initialization.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureInitialized: () => (/* binding */ ensureInitialized),\n/* harmony export */   initializeBackend: () => (/* binding */ initializeBackend),\n/* harmony export */   isBackendInitialized: () => (/* binding */ isBackendInitialized)\n/* harmony export */ });\n/* harmony import */ var _services_SessionManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/services/SessionManager */ \"(rsc)/./src/services/SessionManager.ts\");\n\nlet isInitialized = false;\n/**\n * Initialize all backend services\n */ async function initializeBackend() {\n    if (isInitialized) {\n        return;\n    }\n    try {\n        console.log('Initializing backend services...');\n        // Initialize session manager\n        await (0,_services_SessionManager__WEBPACK_IMPORTED_MODULE_0__.initializeSessionManager)();\n        console.log('Session manager initialized');\n        isInitialized = true;\n        console.log('Backend initialization complete');\n    } catch (error) {\n        console.error('Failed to initialize backend:', error);\n        throw error;\n    }\n}\n/**\n * Ensure backend is initialized before handling requests\n */ async function ensureInitialized() {\n    if (!isInitialized) {\n        await initializeBackend();\n    }\n}\n/**\n * Check if backend is initialized\n */ function isBackendInitialized() {\n    return isInitialized;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL2luaXRpYWxpemF0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBcUU7QUFFckUsSUFBSUMsZ0JBQWdCO0FBRXBCOztDQUVDLEdBQ00sZUFBZUM7SUFDcEIsSUFBSUQsZUFBZTtRQUNqQjtJQUNGO0lBRUEsSUFBSTtRQUNGRSxRQUFRQyxHQUFHLENBQUM7UUFFWiw2QkFBNkI7UUFDN0IsTUFBTUosa0ZBQXdCQTtRQUM5QkcsUUFBUUMsR0FBRyxDQUFDO1FBRVpILGdCQUFnQjtRQUNoQkUsUUFBUUMsR0FBRyxDQUFDO0lBQ2QsRUFBRSxPQUFPQyxPQUFPO1FBQ2RGLFFBQVFFLEtBQUssQ0FBQyxpQ0FBaUNBO1FBQy9DLE1BQU1BO0lBQ1I7QUFDRjtBQUVBOztDQUVDLEdBQ00sZUFBZUM7SUFDcEIsSUFBSSxDQUFDTCxlQUFlO1FBQ2xCLE1BQU1DO0lBQ1I7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU0s7SUFDZCxPQUFPTjtBQUNUIiwic291cmNlcyI6WyIvVXNlcnMvb25lYmlyZC9naXRodWIvZWJvb2stbWNwL21jcC1jaGF0LXVpL2JhY2tlbmQvc3JjL2xpYi9pbml0aWFsaXphdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbml0aWFsaXplU2Vzc2lvbk1hbmFnZXIgfSBmcm9tICdAL3NlcnZpY2VzL1Nlc3Npb25NYW5hZ2VyJztcblxubGV0IGlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGFsbCBiYWNrZW5kIHNlcnZpY2VzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplQmFja2VuZCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgaWYgKGlzSW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgYmFja2VuZCBzZXJ2aWNlcy4uLicpO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgc2Vzc2lvbiBtYW5hZ2VyXG4gICAgYXdhaXQgaW5pdGlhbGl6ZVNlc3Npb25NYW5hZ2VyKCk7XG4gICAgY29uc29sZS5sb2coJ1Nlc3Npb24gbWFuYWdlciBpbml0aWFsaXplZCcpO1xuXG4gICAgaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgY29uc29sZS5sb2coJ0JhY2tlbmQgaW5pdGlhbGl6YXRpb24gY29tcGxldGUnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBiYWNrZW5kOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBiYWNrZW5kIGlzIGluaXRpYWxpemVkIGJlZm9yZSBoYW5kbGluZyByZXF1ZXN0c1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5zdXJlSW5pdGlhbGl6ZWQoKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmICghaXNJbml0aWFsaXplZCkge1xuICAgIGF3YWl0IGluaXRpYWxpemVCYWNrZW5kKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBiYWNrZW5kIGlzIGluaXRpYWxpemVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0JhY2tlbmRJbml0aWFsaXplZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzSW5pdGlhbGl6ZWQ7XG59Il0sIm5hbWVzIjpbImluaXRpYWxpemVTZXNzaW9uTWFuYWdlciIsImlzSW5pdGlhbGl6ZWQiLCJpbml0aWFsaXplQmFja2VuZCIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsImVuc3VyZUluaXRpYWxpemVkIiwiaXNCYWNrZW5kSW5pdGlhbGl6ZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/initialization.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/rateLimit.ts":
/*!******************************!*\
  !*** ./src/lib/rateLimit.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateAndSanitizeInput: () => (/* binding */ validateAndSanitizeInput),\n/* harmony export */   validateJsonInput: () => (/* binding */ validateJsonInput),\n/* harmony export */   withRateLimit: () => (/* binding */ withRateLimit)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(rsc)/./src/lib/errors.ts\");\n\n\nclass RateLimiter {\n    constructor(windowMs = 15 * 60 * 1000, maxRequests = 100){\n        this.requests = new Map();\n        this.windowMs = windowMs;\n        this.maxRequests = maxRequests;\n        // Clean up expired entries every 5 minutes\n        this.cleanupInterval = setInterval(()=>{\n            this.cleanup();\n        }, 5 * 60 * 1000);\n    }\n    /**\n   * Check if request is within rate limit\n   */ checkLimit(identifier) {\n        const now = Date.now();\n        const entry = this.requests.get(identifier);\n        if (!entry || now > entry.resetTime) {\n            // First request or window expired\n            const resetTime = now + this.windowMs;\n            this.requests.set(identifier, {\n                count: 1,\n                resetTime\n            });\n            return {\n                allowed: true,\n                remaining: this.maxRequests - 1,\n                resetTime\n            };\n        }\n        if (entry.count >= this.maxRequests) {\n            // Rate limit exceeded\n            return {\n                allowed: false,\n                remaining: 0,\n                resetTime: entry.resetTime\n            };\n        }\n        // Increment count\n        entry.count++;\n        this.requests.set(identifier, entry);\n        return {\n            allowed: true,\n            remaining: this.maxRequests - entry.count,\n            resetTime: entry.resetTime\n        };\n    }\n    /**\n   * Clean up expired entries\n   */ cleanup() {\n        const now = Date.now();\n        for (const [key, entry] of this.requests.entries()){\n            if (now > entry.resetTime) {\n                this.requests.delete(key);\n            }\n        }\n    }\n    /**\n   * Shutdown the rate limiter\n   */ shutdown() {\n        if (this.cleanupInterval) {\n            clearInterval(this.cleanupInterval);\n            this.cleanupInterval = undefined;\n        }\n    }\n}\n// Global rate limiter instance\nlet rateLimiter = null;\nfunction getRateLimiter() {\n    if (!rateLimiter) {\n        const windowMs = parseInt(process.env.RATE_LIMIT_WINDOW_MS || '900000'); // 15 minutes\n        const maxRequests = parseInt(process.env.RATE_LIMIT_MAX_REQUESTS || '100');\n        rateLimiter = new RateLimiter(windowMs, maxRequests);\n    }\n    return rateLimiter;\n}\n/**\n * Get client identifier for rate limiting\n */ function getClientIdentifier(request) {\n    // Try to get real IP from various headers (for reverse proxy setups)\n    const forwarded = request.headers.get('x-forwarded-for');\n    const realIp = request.headers.get('x-real-ip');\n    const cfConnectingIp = request.headers.get('cf-connecting-ip');\n    const ip = forwarded?.split(',')[0] || realIp || cfConnectingIp || request.ip || 'unknown';\n    // In development, use a more permissive identifier\n    if (true) {\n        return `dev-${ip}`;\n    }\n    return ip;\n}\n/**\n * Rate limiting middleware\n */ function withRateLimit(handler, options = {}) {\n    return async (request, context)=>{\n        // Skip rate limiting if disabled\n        if (process.env.RATE_LIMIT_ENABLED === 'false') {\n            return handler(request, context);\n        }\n        const nextRequest = request;\n        const identifier = getClientIdentifier(nextRequest);\n        const limiter = getRateLimiter();\n        const { allowed, remaining, resetTime } = limiter.checkLimit(identifier);\n        if (!allowed) {\n            const resetDate = new Date(resetTime);\n            const response = next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Rate limit exceeded',\n                message: `Too many requests. Try again after ${resetDate.toISOString()}`,\n                statusCode: 429\n            }, {\n                status: 429\n            });\n            // Add rate limit headers\n            response.headers.set('X-RateLimit-Limit', limiter['maxRequests'].toString());\n            response.headers.set('X-RateLimit-Remaining', remaining.toString());\n            response.headers.set('X-RateLimit-Reset', Math.ceil(resetTime / 1000).toString());\n            response.headers.set('Retry-After', Math.ceil((resetTime - Date.now()) / 1000).toString());\n            return response;\n        }\n        try {\n            const response = await handler(request, context);\n            // Add rate limit headers to successful responses\n            response.headers.set('X-RateLimit-Limit', limiter['maxRequests'].toString());\n            response.headers.set('X-RateLimit-Remaining', remaining.toString());\n            response.headers.set('X-RateLimit-Reset', Math.ceil(resetTime / 1000).toString());\n            return response;\n        } catch (error) {\n            console.error('Rate Limited Handler Error:', error);\n            // Ensure we return a proper JSON error response\n            if (error instanceof Error && 'statusCode' in error) {\n                const statusCode = error.statusCode || 500;\n                const response = next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: error.name || 'Error',\n                    message: error.message,\n                    statusCode\n                }, {\n                    status: statusCode\n                });\n                // Add rate limit headers to error responses too\n                response.headers.set('X-RateLimit-Limit', limiter['maxRequests'].toString());\n                response.headers.set('X-RateLimit-Remaining', remaining.toString());\n                response.headers.set('X-RateLimit-Reset', Math.ceil(resetTime / 1000).toString());\n                return response;\n            }\n            throw error;\n        }\n    };\n}\n/**\n * Enhanced input validation with rate limiting considerations\n */ function validateAndSanitizeInput(input, maxLength = 10000) {\n    if (typeof input !== 'string') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.ValidationError('Input must be a string');\n    }\n    if (input.length > maxLength) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.ValidationError(`Input too long. Maximum length is ${maxLength} characters`);\n    }\n    // Basic XSS prevention\n    const sanitized = input.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '').replace(/javascript:/gi, '').replace(/on\\w+\\s*=/gi, '').replace(/data:text\\/html/gi, '').trim();\n    return sanitized;\n}\n/**\n * Validate JSON input with size limits\n */ function validateJsonInput(input, maxSize = 1024 * 1024) {\n    if (input.length > maxSize) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.ValidationError(`JSON input too large. Maximum size is ${maxSize} bytes`);\n    }\n    try {\n        return JSON.parse(input);\n    } catch (error) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.ValidationError('Invalid JSON format');\n    }\n}\n// Cleanup on process exit\nprocess.on('SIGTERM', ()=>{\n    if (rateLimiter) {\n        rateLimiter.shutdown();\n    }\n});\nprocess.on('SIGINT', ()=>{\n    if (rateLimiter) {\n        rateLimiter.shutdown();\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFVLEVBQUVDLFlBQW9CLEtBQUs7SUFDNUUsSUFBSSxPQUFPRCxVQUFVLFVBQVU7UUFDN0IsTUFBTSxJQUFJL0Qsb0RBQWVBLENBQUM7SUFDNUI7SUFFQSxJQUFJK0QsTUFBTUUsTUFBTSxHQUFHRCxXQUFXO1FBQzVCLE1BQU0sSUFBSWhFLG9EQUFlQSxDQUFDLENBQUMsa0NBQWtDLEVBQUVnRSxVQUFVLFdBQVcsQ0FBQztJQUN2RjtJQUVBLHVCQUF1QjtJQUN2QixNQUFNRSxZQUFZSCxNQUNmSSxPQUFPLENBQUMsdURBQXVELElBQy9EQSxPQUFPLENBQUMsaUJBQWlCLElBQ3pCQSxPQUFPLENBQUMsZUFBZSxJQUN2QkEsT0FBTyxDQUFDLHFCQUFxQixJQUM3QkMsSUFBSTtJQUVQLE9BQU9GO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNHLGtCQUFrQk4sS0FBYSxFQUFFTyxVQUFrQixPQUFPLElBQUk7SUFDNUUsSUFBSVAsTUFBTUUsTUFBTSxHQUFHSyxTQUFTO1FBQzFCLE1BQU0sSUFBSXRFLG9EQUFlQSxDQUFDLENBQUMsc0NBQXNDLEVBQUVzRSxRQUFRLE1BQU0sQ0FBQztJQUNwRjtJQUVBLElBQUk7UUFDRixPQUFPQyxLQUFLQyxLQUFLLENBQUNUO0lBQ3BCLEVBQUUsT0FBT1osT0FBTztRQUNkLE1BQU0sSUFBSW5ELG9EQUFlQSxDQUFDO0lBQzVCO0FBQ0Y7QUFFQSwwQkFBMEI7QUFDMUI2QixRQUFRNEMsRUFBRSxDQUFDLFdBQVc7SUFDcEIsSUFBSS9DLGFBQWE7UUFDZkEsWUFBWUgsUUFBUTtJQUN0QjtBQUNGO0FBRUFNLFFBQVE0QyxFQUFFLENBQUMsVUFBVTtJQUNuQixJQUFJL0MsYUFBYTtRQUNmQSxZQUFZSCxRQUFRO0lBQ3RCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9vbmViaXJkL2dpdGh1Yi9lYm9vay1tY3AvbWNwLWNoYXQtdWkvYmFja2VuZC9zcmMvbGliL3JhdGVMaW1pdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgVmFsaWRhdGlvbkVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuXG5pbnRlcmZhY2UgUmF0ZUxpbWl0RW50cnkge1xuICBjb3VudDogbnVtYmVyO1xuICByZXNldFRpbWU6IG51bWJlcjtcbn1cblxuY2xhc3MgUmF0ZUxpbWl0ZXIge1xuICBwcml2YXRlIHJlcXVlc3RzID0gbmV3IE1hcDxzdHJpbmcsIFJhdGVMaW1pdEVudHJ5PigpO1xuICBwcml2YXRlIHJlYWRvbmx5IHdpbmRvd01zOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgbWF4UmVxdWVzdHM6IG51bWJlcjtcbiAgcHJpdmF0ZSBjbGVhbnVwSW50ZXJ2YWw/OiBOb2RlSlMuVGltZW91dDtcblxuICBjb25zdHJ1Y3Rvcih3aW5kb3dNczogbnVtYmVyID0gMTUgKiA2MCAqIDEwMDAsIG1heFJlcXVlc3RzOiBudW1iZXIgPSAxMDApIHtcbiAgICB0aGlzLndpbmRvd01zID0gd2luZG93TXM7XG4gICAgdGhpcy5tYXhSZXF1ZXN0cyA9IG1heFJlcXVlc3RzO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIGV4cGlyZWQgZW50cmllcyBldmVyeSA1IG1pbnV0ZXNcbiAgICB0aGlzLmNsZWFudXBJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH0sIDUgKiA2MCAqIDEwMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHJlcXVlc3QgaXMgd2l0aGluIHJhdGUgbGltaXRcbiAgICovXG4gIGNoZWNrTGltaXQoaWRlbnRpZmllcjogc3RyaW5nKTogeyBhbGxvd2VkOiBib29sZWFuOyByZW1haW5pbmc6IG51bWJlcjsgcmVzZXRUaW1lOiBudW1iZXIgfSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMucmVxdWVzdHMuZ2V0KGlkZW50aWZpZXIpO1xuXG4gICAgaWYgKCFlbnRyeSB8fCBub3cgPiBlbnRyeS5yZXNldFRpbWUpIHtcbiAgICAgIC8vIEZpcnN0IHJlcXVlc3Qgb3Igd2luZG93IGV4cGlyZWRcbiAgICAgIGNvbnN0IHJlc2V0VGltZSA9IG5vdyArIHRoaXMud2luZG93TXM7XG4gICAgICB0aGlzLnJlcXVlc3RzLnNldChpZGVudGlmaWVyLCB7IGNvdW50OiAxLCByZXNldFRpbWUgfSk7XG4gICAgICByZXR1cm4geyBhbGxvd2VkOiB0cnVlLCByZW1haW5pbmc6IHRoaXMubWF4UmVxdWVzdHMgLSAxLCByZXNldFRpbWUgfTtcbiAgICB9XG5cbiAgICBpZiAoZW50cnkuY291bnQgPj0gdGhpcy5tYXhSZXF1ZXN0cykge1xuICAgICAgLy8gUmF0ZSBsaW1pdCBleGNlZWRlZFxuICAgICAgcmV0dXJuIHsgYWxsb3dlZDogZmFsc2UsIHJlbWFpbmluZzogMCwgcmVzZXRUaW1lOiBlbnRyeS5yZXNldFRpbWUgfTtcbiAgICB9XG5cbiAgICAvLyBJbmNyZW1lbnQgY291bnRcbiAgICBlbnRyeS5jb3VudCsrO1xuICAgIHRoaXMucmVxdWVzdHMuc2V0KGlkZW50aWZpZXIsIGVudHJ5KTtcbiAgICByZXR1cm4geyBhbGxvd2VkOiB0cnVlLCByZW1haW5pbmc6IHRoaXMubWF4UmVxdWVzdHMgLSBlbnRyeS5jb3VudCwgcmVzZXRUaW1lOiBlbnRyeS5yZXNldFRpbWUgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCBleHBpcmVkIGVudHJpZXNcbiAgICovXG4gIHByaXZhdGUgY2xlYW51cCgpOiB2b2lkIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIHRoaXMucmVxdWVzdHMuZW50cmllcygpKSB7XG4gICAgICBpZiAobm93ID4gZW50cnkucmVzZXRUaW1lKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdHMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNodXRkb3duIHRoZSByYXRlIGxpbWl0ZXJcbiAgICovXG4gIHNodXRkb3duKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNsZWFudXBJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNsZWFudXBJbnRlcnZhbCk7XG4gICAgICB0aGlzLmNsZWFudXBJbnRlcnZhbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuLy8gR2xvYmFsIHJhdGUgbGltaXRlciBpbnN0YW5jZVxubGV0IHJhdGVMaW1pdGVyOiBSYXRlTGltaXRlciB8IG51bGwgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRSYXRlTGltaXRlcigpOiBSYXRlTGltaXRlciB7XG4gIGlmICghcmF0ZUxpbWl0ZXIpIHtcbiAgICBjb25zdCB3aW5kb3dNcyA9IHBhcnNlSW50KHByb2Nlc3MuZW52LlJBVEVfTElNSVRfV0lORE9XX01TIHx8ICc5MDAwMDAnKTsgLy8gMTUgbWludXRlc1xuICAgIGNvbnN0IG1heFJlcXVlc3RzID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuUkFURV9MSU1JVF9NQVhfUkVRVUVTVFMgfHwgJzEwMCcpO1xuICAgIHJhdGVMaW1pdGVyID0gbmV3IFJhdGVMaW1pdGVyKHdpbmRvd01zLCBtYXhSZXF1ZXN0cyk7XG4gIH1cbiAgcmV0dXJuIHJhdGVMaW1pdGVyO1xufVxuXG4vKipcbiAqIEdldCBjbGllbnQgaWRlbnRpZmllciBmb3IgcmF0ZSBsaW1pdGluZ1xuICovXG5mdW5jdGlvbiBnZXRDbGllbnRJZGVudGlmaWVyKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KTogc3RyaW5nIHtcbiAgLy8gVHJ5IHRvIGdldCByZWFsIElQIGZyb20gdmFyaW91cyBoZWFkZXJzIChmb3IgcmV2ZXJzZSBwcm94eSBzZXR1cHMpXG4gIGNvbnN0IGZvcndhcmRlZCA9IHJlcXVlc3QuaGVhZGVycy5nZXQoJ3gtZm9yd2FyZGVkLWZvcicpO1xuICBjb25zdCByZWFsSXAgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KCd4LXJlYWwtaXAnKTtcbiAgY29uc3QgY2ZDb25uZWN0aW5nSXAgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KCdjZi1jb25uZWN0aW5nLWlwJyk7XG4gIFxuICBjb25zdCBpcCA9IGZvcndhcmRlZD8uc3BsaXQoJywnKVswXSB8fCByZWFsSXAgfHwgY2ZDb25uZWN0aW5nSXAgfHwgXG4gICAgICAgICAgICAgcmVxdWVzdC5pcCB8fCAndW5rbm93bic7XG4gIFxuICAvLyBJbiBkZXZlbG9wbWVudCwgdXNlIGEgbW9yZSBwZXJtaXNzaXZlIGlkZW50aWZpZXJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgcmV0dXJuIGBkZXYtJHtpcH1gO1xuICB9XG4gIFxuICByZXR1cm4gaXA7XG59XG5cbi8qKlxuICogUmF0ZSBsaW1pdGluZyBtaWRkbGV3YXJlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoUmF0ZUxpbWl0KFxuICBoYW5kbGVyOiAocmVxdWVzdDogUmVxdWVzdCwgY29udGV4dD86IGFueSkgPT4gUHJvbWlzZTxOZXh0UmVzcG9uc2U+LFxuICBvcHRpb25zOiB7IHdpbmRvd01zPzogbnVtYmVyOyBtYXhSZXF1ZXN0cz86IG51bWJlciB9ID0ge31cbikge1xuICByZXR1cm4gYXN5bmMgKHJlcXVlc3Q6IFJlcXVlc3QsIGNvbnRleHQ/OiBhbnkpID0+IHtcbiAgICAvLyBTa2lwIHJhdGUgbGltaXRpbmcgaWYgZGlzYWJsZWRcbiAgICBpZiAocHJvY2Vzcy5lbnYuUkFURV9MSU1JVF9FTkFCTEVEID09PSAnZmFsc2UnKSB7XG4gICAgICByZXR1cm4gaGFuZGxlcihyZXF1ZXN0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXh0UmVxdWVzdCA9IHJlcXVlc3QgYXMgTmV4dFJlcXVlc3Q7XG4gICAgY29uc3QgaWRlbnRpZmllciA9IGdldENsaWVudElkZW50aWZpZXIobmV4dFJlcXVlc3QpO1xuICAgIGNvbnN0IGxpbWl0ZXIgPSBnZXRSYXRlTGltaXRlcigpO1xuICAgIFxuICAgIGNvbnN0IHsgYWxsb3dlZCwgcmVtYWluaW5nLCByZXNldFRpbWUgfSA9IGxpbWl0ZXIuY2hlY2tMaW1pdChpZGVudGlmaWVyKTtcbiAgICBcbiAgICBpZiAoIWFsbG93ZWQpIHtcbiAgICAgIGNvbnN0IHJlc2V0RGF0ZSA9IG5ldyBEYXRlKHJlc2V0VGltZSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7XG4gICAgICAgICAgZXJyb3I6ICdSYXRlIGxpbWl0IGV4Y2VlZGVkJyxcbiAgICAgICAgICBtZXNzYWdlOiBgVG9vIG1hbnkgcmVxdWVzdHMuIFRyeSBhZ2FpbiBhZnRlciAke3Jlc2V0RGF0ZS50b0lTT1N0cmluZygpfWAsXG4gICAgICAgICAgc3RhdHVzQ29kZTogNDI5LFxuICAgICAgICB9LFxuICAgICAgICB7IHN0YXR1czogNDI5IH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIEFkZCByYXRlIGxpbWl0IGhlYWRlcnNcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMuc2V0KCdYLVJhdGVMaW1pdC1MaW1pdCcsIGxpbWl0ZXJbJ21heFJlcXVlc3RzJ10udG9TdHJpbmcoKSk7XG4gICAgICByZXNwb25zZS5oZWFkZXJzLnNldCgnWC1SYXRlTGltaXQtUmVtYWluaW5nJywgcmVtYWluaW5nLnRvU3RyaW5nKCkpO1xuICAgICAgcmVzcG9uc2UuaGVhZGVycy5zZXQoJ1gtUmF0ZUxpbWl0LVJlc2V0JywgTWF0aC5jZWlsKHJlc2V0VGltZSAvIDEwMDApLnRvU3RyaW5nKCkpO1xuICAgICAgcmVzcG9uc2UuaGVhZGVycy5zZXQoJ1JldHJ5LUFmdGVyJywgTWF0aC5jZWlsKChyZXNldFRpbWUgLSBEYXRlLm5vdygpKSAvIDEwMDApLnRvU3RyaW5nKCkpO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlcihyZXF1ZXN0LCBjb250ZXh0KTtcbiAgICAgIFxuICAgICAgLy8gQWRkIHJhdGUgbGltaXQgaGVhZGVycyB0byBzdWNjZXNzZnVsIHJlc3BvbnNlc1xuICAgICAgcmVzcG9uc2UuaGVhZGVycy5zZXQoJ1gtUmF0ZUxpbWl0LUxpbWl0JywgbGltaXRlclsnbWF4UmVxdWVzdHMnXS50b1N0cmluZygpKTtcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMuc2V0KCdYLVJhdGVMaW1pdC1SZW1haW5pbmcnLCByZW1haW5pbmcudG9TdHJpbmcoKSk7XG4gICAgICByZXNwb25zZS5oZWFkZXJzLnNldCgnWC1SYXRlTGltaXQtUmVzZXQnLCBNYXRoLmNlaWwocmVzZXRUaW1lIC8gMTAwMCkudG9TdHJpbmcoKSk7XG4gICAgICBcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignUmF0ZSBMaW1pdGVkIEhhbmRsZXIgRXJyb3I6JywgZXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBFbnN1cmUgd2UgcmV0dXJuIGEgcHJvcGVyIEpTT04gZXJyb3IgcmVzcG9uc2VcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICdzdGF0dXNDb2RlJyBpbiBlcnJvcikge1xuICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gKGVycm9yIGFzIGFueSkuc3RhdHVzQ29kZSB8fCA1MDA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAge1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yLm5hbWUgfHwgJ0Vycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBzdGF0dXM6IHN0YXR1c0NvZGUgfVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHJhdGUgbGltaXQgaGVhZGVycyB0byBlcnJvciByZXNwb25zZXMgdG9vXG4gICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuc2V0KCdYLVJhdGVMaW1pdC1MaW1pdCcsIGxpbWl0ZXJbJ21heFJlcXVlc3RzJ10udG9TdHJpbmcoKSk7XG4gICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuc2V0KCdYLVJhdGVMaW1pdC1SZW1haW5pbmcnLCByZW1haW5pbmcudG9TdHJpbmcoKSk7XG4gICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuc2V0KCdYLVJhdGVMaW1pdC1SZXNldCcsIE1hdGguY2VpbChyZXNldFRpbWUgLyAxMDAwKS50b1N0cmluZygpKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEVuaGFuY2VkIGlucHV0IHZhbGlkYXRpb24gd2l0aCByYXRlIGxpbWl0aW5nIGNvbnNpZGVyYXRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFuZFNhbml0aXplSW5wdXQoaW5wdXQ6IGFueSwgbWF4TGVuZ3RoOiBudW1iZXIgPSAxMDAwMCk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignSW5wdXQgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG4gIFxuICBpZiAoaW5wdXQubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgSW5wdXQgdG9vIGxvbmcuIE1heGltdW0gbGVuZ3RoIGlzICR7bWF4TGVuZ3RofSBjaGFyYWN0ZXJzYCk7XG4gIH1cbiAgXG4gIC8vIEJhc2ljIFhTUyBwcmV2ZW50aW9uXG4gIGNvbnN0IHNhbml0aXplZCA9IGlucHV0XG4gICAgLnJlcGxhY2UoLzxzY3JpcHRcXGJbXjxdKig/Oig/ITxcXC9zY3JpcHQ+KTxbXjxdKikqPFxcL3NjcmlwdD4vZ2ksICcnKVxuICAgIC5yZXBsYWNlKC9qYXZhc2NyaXB0Oi9naSwgJycpXG4gICAgLnJlcGxhY2UoL29uXFx3K1xccyo9L2dpLCAnJylcbiAgICAucmVwbGFjZSgvZGF0YTp0ZXh0XFwvaHRtbC9naSwgJycpXG4gICAgLnRyaW0oKTtcbiAgXG4gIHJldHVybiBzYW5pdGl6ZWQ7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgSlNPTiBpbnB1dCB3aXRoIHNpemUgbGltaXRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUpzb25JbnB1dChpbnB1dDogc3RyaW5nLCBtYXhTaXplOiBudW1iZXIgPSAxMDI0ICogMTAyNCk6IGFueSB7XG4gIGlmIChpbnB1dC5sZW5ndGggPiBtYXhTaXplKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgSlNPTiBpbnB1dCB0b28gbGFyZ2UuIE1heGltdW0gc2l6ZSBpcyAke21heFNpemV9IGJ5dGVzYCk7XG4gIH1cbiAgXG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoaW5wdXQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ0ludmFsaWQgSlNPTiBmb3JtYXQnKTtcbiAgfVxufVxuXG4vLyBDbGVhbnVwIG9uIHByb2Nlc3MgZXhpdFxucHJvY2Vzcy5vbignU0lHVEVSTScsICgpID0+IHtcbiAgaWYgKHJhdGVMaW1pdGVyKSB7XG4gICAgcmF0ZUxpbWl0ZXIuc2h1dGRvd24oKTtcbiAgfVxufSk7XG5cbnByb2Nlc3Mub24oJ1NJR0lOVCcsICgpID0+IHtcbiAgaWYgKHJhdGVMaW1pdGVyKSB7XG4gICAgcmF0ZUxpbWl0ZXIuc2h1dGRvd24oKTtcbiAgfVxufSk7Il0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsIlZhbGlkYXRpb25FcnJvciIsIlJhdGVMaW1pdGVyIiwid2luZG93TXMiLCJtYXhSZXF1ZXN0cyIsInJlcXVlc3RzIiwiTWFwIiwiY2xlYW51cEludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhbnVwIiwiY2hlY2tMaW1pdCIsImlkZW50aWZpZXIiLCJub3ciLCJEYXRlIiwiZW50cnkiLCJnZXQiLCJyZXNldFRpbWUiLCJzZXQiLCJjb3VudCIsImFsbG93ZWQiLCJyZW1haW5pbmciLCJrZXkiLCJlbnRyaWVzIiwiZGVsZXRlIiwic2h1dGRvd24iLCJjbGVhckludGVydmFsIiwidW5kZWZpbmVkIiwicmF0ZUxpbWl0ZXIiLCJnZXRSYXRlTGltaXRlciIsInBhcnNlSW50IiwicHJvY2VzcyIsImVudiIsIlJBVEVfTElNSVRfV0lORE9XX01TIiwiUkFURV9MSU1JVF9NQVhfUkVRVUVTVFMiLCJnZXRDbGllbnRJZGVudGlmaWVyIiwicmVxdWVzdCIsImZvcndhcmRlZCIsImhlYWRlcnMiLCJyZWFsSXAiLCJjZkNvbm5lY3RpbmdJcCIsImlwIiwic3BsaXQiLCJ3aXRoUmF0ZUxpbWl0IiwiaGFuZGxlciIsIm9wdGlvbnMiLCJjb250ZXh0IiwiUkFURV9MSU1JVF9FTkFCTEVEIiwibmV4dFJlcXVlc3QiLCJsaW1pdGVyIiwicmVzZXREYXRlIiwicmVzcG9uc2UiLCJqc29uIiwiZXJyb3IiLCJtZXNzYWdlIiwidG9JU09TdHJpbmciLCJzdGF0dXNDb2RlIiwic3RhdHVzIiwidG9TdHJpbmciLCJNYXRoIiwiY2VpbCIsImNvbnNvbGUiLCJFcnJvciIsIm5hbWUiLCJ2YWxpZGF0ZUFuZFNhbml0aXplSW5wdXQiLCJpbnB1dCIsIm1heExlbmd0aCIsImxlbmd0aCIsInNhbml0aXplZCIsInJlcGxhY2UiLCJ0cmltIiwidmFsaWRhdGVKc29uSW5wdXQiLCJtYXhTaXplIiwiSlNPTiIsInBhcnNlIiwib24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/rateLimit.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/security.ts":
/*!*****************************!*\
  !*** ./src/lib/security.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addSecurityHeaders: () => (/* binding */ addSecurityHeaders),\n/* harmony export */   generateSecureToken: () => (/* binding */ generateSecureToken),\n/* harmony export */   logSecurityEvent: () => (/* binding */ logSecurityEvent),\n/* harmony export */   sanitizeRequestBody: () => (/* binding */ sanitizeRequestBody),\n/* harmony export */   validateFileUpload: () => (/* binding */ validateFileUpload),\n/* harmony export */   withSecurity: () => (/* binding */ withSecurity)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _cors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cors */ \"(rsc)/./src/lib/cors.ts\");\n/* harmony import */ var _rateLimit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rateLimit */ \"(rsc)/./src/lib/rateLimit.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors */ \"(rsc)/./src/lib/errors.ts\");\n\n\n\n\n/**\n * Comprehensive security middleware that combines all security features\n */ function withSecurity(handler, options = {}) {\n    const { rateLimit = true, cors = true, validation = true, maxBodySize = 1024 * 1024 } = options;\n    let secureHandler = handler;\n    // Apply validation middleware\n    if (validation) {\n        secureHandler = withValidation(secureHandler, {\n            maxBodySize\n        });\n    }\n    // Apply rate limiting\n    if (rateLimit) {\n        secureHandler = (0,_rateLimit__WEBPACK_IMPORTED_MODULE_2__.withRateLimit)(secureHandler);\n    }\n    // Apply CORS\n    if (cors) {\n        secureHandler = (0,_cors__WEBPACK_IMPORTED_MODULE_1__.withCors)(secureHandler);\n    }\n    // Apply error handling\n    secureHandler = (0,_errors__WEBPACK_IMPORTED_MODULE_3__.handleAsyncRoute)(secureHandler);\n    return secureHandler;\n}\n/**\n * Input validation middleware\n */ function withValidation(handler, options) {\n    return async (request, context)=>{\n        const nextRequest = request;\n        // Check content length\n        const contentLength = nextRequest.headers.get('content-length');\n        if (contentLength && parseInt(contentLength) > options.maxBodySize) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Payload too large',\n                message: `Request body exceeds maximum size of ${options.maxBodySize} bytes`,\n                statusCode: 413\n            }, {\n                status: 413\n            });\n        }\n        // Validate content type for POST/PUT requests\n        if ([\n            'POST',\n            'PUT',\n            'PATCH'\n        ].includes(request.method)) {\n            const contentType = nextRequest.headers.get('content-type');\n            if (contentType && !contentType.includes('application/json')) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: 'Invalid content type',\n                    message: 'Content-Type must be application/json',\n                    statusCode: 415\n                }, {\n                    status: 415\n                });\n            }\n        }\n        // Check for suspicious headers\n        const suspiciousHeaders = [\n            'x-forwarded-host',\n            'x-original-url',\n            'x-rewrite-url'\n        ];\n        for (const header of suspiciousHeaders){\n            if (nextRequest.headers.get(header)) {\n                console.warn(` Suspicious header detected: ${header}`, {\n                    url: request.url,\n                    ip: nextRequest.headers.get('x-forwarded-for') || 'unknown',\n                    userAgent: nextRequest.headers.get('user-agent') || 'unknown'\n                });\n            }\n        }\n        // Validate URL path\n        const url = new URL(request.url);\n        if (containsSuspiciousPatterns(url.pathname)) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Invalid request',\n                message: 'Request contains suspicious patterns',\n                statusCode: 400\n            }, {\n                status: 400\n            });\n        }\n        return handler(request, context);\n    };\n}\n/**\n * Check for suspicious patterns in URL paths\n */ function containsSuspiciousPatterns(path) {\n    const suspiciousPatterns = [\n        /\\.\\./,\n        /\\/\\//,\n        /%2e%2e/i,\n        /%00/i,\n        /\\x00/,\n        /<script/i,\n        /javascript:/i,\n        /vbscript:/i,\n        /data:text\\/html/i,\n        /on\\w+=/i\n    ];\n    return suspiciousPatterns.some((pattern)=>pattern.test(path));\n}\n/**\n * Security headers for API responses\n */ function addSecurityHeaders(response) {\n    // Remove server information\n    response.headers.delete('server');\n    response.headers.delete('x-powered-by');\n    // Add security headers\n    response.headers.set('X-Content-Type-Options', 'nosniff');\n    response.headers.set('X-Frame-Options', 'DENY');\n    response.headers.set('X-XSS-Protection', '1; mode=block');\n    response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');\n    response.headers.set('Permissions-Policy', 'camera=(), microphone=(), geolocation=()');\n    // Content Security Policy for API\n    response.headers.set('Content-Security-Policy', \"default-src 'none'; frame-ancestors 'none';\");\n    // HSTS in production\n    if (false) {}\n    return response;\n}\n/**\n * Sanitize request body to prevent injection attacks\n */ function sanitizeRequestBody(body) {\n    if (typeof body === 'string') {\n        return sanitizeString(body);\n    }\n    if (Array.isArray(body)) {\n        return body.map((item)=>sanitizeRequestBody(item));\n    }\n    if (body && typeof body === 'object') {\n        const sanitized = {};\n        for (const [key, value] of Object.entries(body)){\n            // Sanitize keys\n            const sanitizedKey = sanitizeString(key);\n            sanitized[sanitizedKey] = sanitizeRequestBody(value);\n        }\n        return sanitized;\n    }\n    return body;\n}\n/**\n * Sanitize string values\n */ function sanitizeString(str) {\n    if (typeof str !== 'string') {\n        return str;\n    }\n    // Remove dangerous patterns\n    return str.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '').replace(/<iframe\\b[^<]*(?:(?!<\\/iframe>)<[^<]*)*<\\/iframe>/gi, '').replace(/javascript:/gi, '').replace(/vbscript:/gi, '').replace(/data:text\\/html/gi, '').replace(/on\\w+\\s*=/gi, '').trim();\n}\n/**\n * Log security events\n */ function logSecurityEvent(event, details) {\n    const logEntry = {\n        timestamp: new Date().toISOString(),\n        event,\n        severity: details.severity || 'medium',\n        ip: details.ip || 'unknown',\n        userAgent: details.userAgent || 'unknown',\n        ...details\n    };\n    // In production, this would go to a proper logging service\n    if (details.severity === 'high') {\n        console.error(' HIGH SEVERITY SECURITY EVENT:', logEntry);\n    } else if (details.severity === 'medium') {\n        console.warn(' SECURITY EVENT:', logEntry);\n    } else {\n        console.info(' Security event:', logEntry);\n    }\n}\n/**\n * Validate file upload (if needed in the future)\n */ function validateFileUpload(file, options = {}) {\n    const { maxSize = 10 * 1024 * 1024, allowedTypes = [\n        'application/json',\n        'text/plain'\n    ], allowedExtensions = [\n        '.json',\n        '.txt'\n    ] } = options;\n    if (file.size > maxSize) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.ValidationError(`File size exceeds maximum of ${maxSize} bytes`);\n    }\n    if (!allowedTypes.includes(file.type)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.ValidationError(`File type ${file.type} is not allowed`);\n    }\n    const extension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));\n    if (!allowedExtensions.includes(extension)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.ValidationError(`File extension ${extension} is not allowed`);\n    }\n}\n/**\n * Generate secure random tokens\n */ function generateSecureToken(length = 32) {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let result = '';\n    // Use crypto.getRandomValues if available (browser/Node.js)\n    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n        const array = new Uint8Array(length);\n        crypto.getRandomValues(array);\n        for(let i = 0; i < length; i++){\n            result += chars[array[i] % chars.length];\n        }\n    } else {\n        // Fallback to Math.random (less secure)\n        for(let i = 0; i < length; i++){\n            result += chars[Math.floor(Math.random() * chars.length)];\n        }\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZC9naXRodWIvZWJvb2stbWNwL21jcC1jaGF0LXVpL2JhY2tlbmQvc3JjL2xpYi9zZWN1cml0eS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgd2l0aENvcnMgfSBmcm9tICcuL2NvcnMnO1xuaW1wb3J0IHsgd2l0aFJhdGVMaW1pdCB9IGZyb20gJy4vcmF0ZUxpbWl0JztcbmltcG9ydCB7IGhhbmRsZUFzeW5jUm91dGUsIFZhbGlkYXRpb25FcnJvciB9IGZyb20gJy4vZXJyb3JzJztcblxuLyoqXG4gKiBDb21wcmVoZW5zaXZlIHNlY3VyaXR5IG1pZGRsZXdhcmUgdGhhdCBjb21iaW5lcyBhbGwgc2VjdXJpdHkgZmVhdHVyZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhTZWN1cml0eShcbiAgaGFuZGxlcjogKHJlcXVlc3Q6IFJlcXVlc3QsIGNvbnRleHQ/OiBhbnkpID0+IFByb21pc2U8TmV4dFJlc3BvbnNlPixcbiAgb3B0aW9uczoge1xuICAgIHJhdGVMaW1pdD86IGJvb2xlYW47XG4gICAgY29ycz86IGJvb2xlYW47XG4gICAgdmFsaWRhdGlvbj86IGJvb2xlYW47XG4gICAgbWF4Qm9keVNpemU/OiBudW1iZXI7XG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IHtcbiAgICByYXRlTGltaXQgPSB0cnVlLFxuICAgIGNvcnMgPSB0cnVlLFxuICAgIHZhbGlkYXRpb24gPSB0cnVlLFxuICAgIG1heEJvZHlTaXplID0gMTAyNCAqIDEwMjQsIC8vIDFNQiBkZWZhdWx0XG4gIH0gPSBvcHRpb25zO1xuXG4gIGxldCBzZWN1cmVIYW5kbGVyID0gaGFuZGxlcjtcblxuICAvLyBBcHBseSB2YWxpZGF0aW9uIG1pZGRsZXdhcmVcbiAgaWYgKHZhbGlkYXRpb24pIHtcbiAgICBzZWN1cmVIYW5kbGVyID0gd2l0aFZhbGlkYXRpb24oc2VjdXJlSGFuZGxlciwgeyBtYXhCb2R5U2l6ZSB9KTtcbiAgfVxuXG4gIC8vIEFwcGx5IHJhdGUgbGltaXRpbmdcbiAgaWYgKHJhdGVMaW1pdCkge1xuICAgIHNlY3VyZUhhbmRsZXIgPSB3aXRoUmF0ZUxpbWl0KHNlY3VyZUhhbmRsZXIpO1xuICB9XG5cbiAgLy8gQXBwbHkgQ09SU1xuICBpZiAoY29ycykge1xuICAgIHNlY3VyZUhhbmRsZXIgPSB3aXRoQ29ycyhzZWN1cmVIYW5kbGVyKTtcbiAgfVxuXG4gIC8vIEFwcGx5IGVycm9yIGhhbmRsaW5nXG4gIHNlY3VyZUhhbmRsZXIgPSBoYW5kbGVBc3luY1JvdXRlKHNlY3VyZUhhbmRsZXIpO1xuXG4gIHJldHVybiBzZWN1cmVIYW5kbGVyO1xufVxuXG4vKipcbiAqIElucHV0IHZhbGlkYXRpb24gbWlkZGxld2FyZVxuICovXG5mdW5jdGlvbiB3aXRoVmFsaWRhdGlvbihcbiAgaGFuZGxlcjogKHJlcXVlc3Q6IFJlcXVlc3QsIGNvbnRleHQ/OiBhbnkpID0+IFByb21pc2U8TmV4dFJlc3BvbnNlPixcbiAgb3B0aW9uczogeyBtYXhCb2R5U2l6ZTogbnVtYmVyIH1cbikge1xuICByZXR1cm4gYXN5bmMgKHJlcXVlc3Q6IFJlcXVlc3QsIGNvbnRleHQ/OiBhbnkpID0+IHtcbiAgICBjb25zdCBuZXh0UmVxdWVzdCA9IHJlcXVlc3QgYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAvLyBDaGVjayBjb250ZW50IGxlbmd0aFxuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBuZXh0UmVxdWVzdC5oZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKTtcbiAgICBpZiAoY29udGVudExlbmd0aCAmJiBwYXJzZUludChjb250ZW50TGVuZ3RoKSA+IG9wdGlvbnMubWF4Qm9keVNpemUpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAge1xuICAgICAgICAgIGVycm9yOiAnUGF5bG9hZCB0b28gbGFyZ2UnLFxuICAgICAgICAgIG1lc3NhZ2U6IGBSZXF1ZXN0IGJvZHkgZXhjZWVkcyBtYXhpbXVtIHNpemUgb2YgJHtvcHRpb25zLm1heEJvZHlTaXplfSBieXRlc2AsXG4gICAgICAgICAgc3RhdHVzQ29kZTogNDEzLFxuICAgICAgICB9LFxuICAgICAgICB7IHN0YXR1czogNDEzIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgY29udGVudCB0eXBlIGZvciBQT1NUL1BVVCByZXF1ZXN0c1xuICAgIGlmIChbJ1BPU1QnLCAnUFVUJywgJ1BBVENIJ10uaW5jbHVkZXMocmVxdWVzdC5tZXRob2QpKSB7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IG5leHRSZXF1ZXN0LmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICAgIGlmIChjb250ZW50VHlwZSAmJiAhY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAge1xuICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIGNvbnRlbnQgdHlwZScsXG4gICAgICAgICAgICBtZXNzYWdlOiAnQ29udGVudC1UeXBlIG11c3QgYmUgYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBzdGF0dXNDb2RlOiA0MTUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IHN0YXR1czogNDE1IH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3Igc3VzcGljaW91cyBoZWFkZXJzXG4gICAgY29uc3Qgc3VzcGljaW91c0hlYWRlcnMgPSBbXG4gICAgICAneC1mb3J3YXJkZWQtaG9zdCcsXG4gICAgICAneC1vcmlnaW5hbC11cmwnLFxuICAgICAgJ3gtcmV3cml0ZS11cmwnLFxuICAgIF07XG5cbiAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBzdXNwaWNpb3VzSGVhZGVycykge1xuICAgICAgaWYgKG5leHRSZXF1ZXN0LmhlYWRlcnMuZ2V0KGhlYWRlcikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGDwn5qoIFN1c3BpY2lvdXMgaGVhZGVyIGRldGVjdGVkOiAke2hlYWRlcn1gLCB7XG4gICAgICAgICAgdXJsOiByZXF1ZXN0LnVybCxcbiAgICAgICAgICBpcDogbmV4dFJlcXVlc3QuaGVhZGVycy5nZXQoJ3gtZm9yd2FyZGVkLWZvcicpIHx8ICd1bmtub3duJyxcbiAgICAgICAgICB1c2VyQWdlbnQ6IG5leHRSZXF1ZXN0LmhlYWRlcnMuZ2V0KCd1c2VyLWFnZW50JykgfHwgJ3Vua25vd24nLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBVUkwgcGF0aFxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGlmIChjb250YWluc1N1c3BpY2lvdXNQYXR0ZXJucyh1cmwucGF0aG5hbWUpKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHtcbiAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgcmVxdWVzdCcsXG4gICAgICAgICAgbWVzc2FnZTogJ1JlcXVlc3QgY29udGFpbnMgc3VzcGljaW91cyBwYXR0ZXJucycsXG4gICAgICAgICAgc3RhdHVzQ29kZTogNDAwLFxuICAgICAgICB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhbmRsZXIocmVxdWVzdCwgY29udGV4dCk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIHN1c3BpY2lvdXMgcGF0dGVybnMgaW4gVVJMIHBhdGhzXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zU3VzcGljaW91c1BhdHRlcm5zKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBzdXNwaWNpb3VzUGF0dGVybnMgPSBbXG4gICAgL1xcLlxcLi8sICAvLyBQYXRoIHRyYXZlcnNhbFxuICAgIC9cXC9cXC8vLCAgLy8gRG91YmxlIHNsYXNoZXNcbiAgICAvJTJlJTJlL2ksICAvLyBVUkwgZW5jb2RlZCBwYXRoIHRyYXZlcnNhbFxuICAgIC8lMDAvaSwgIC8vIE51bGwgYnl0ZXNcbiAgICAvXFx4MDAvLCAgLy8gTnVsbCBieXRlc1xuICAgIC88c2NyaXB0L2ksICAvLyBTY3JpcHQgdGFnc1xuICAgIC9qYXZhc2NyaXB0Oi9pLCAgLy8gSmF2YVNjcmlwdCBwcm90b2NvbFxuICAgIC92YnNjcmlwdDovaSwgIC8vIFZCU2NyaXB0IHByb3RvY29sXG4gICAgL2RhdGE6dGV4dFxcL2h0bWwvaSwgIC8vIERhdGEgVVJMcyB3aXRoIEhUTUxcbiAgICAvb25cXHcrPS9pLCAgLy8gRXZlbnQgaGFuZGxlcnNcbiAgXTtcblxuICByZXR1cm4gc3VzcGljaW91c1BhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBwYXR0ZXJuLnRlc3QocGF0aCkpO1xufVxuXG4vKipcbiAqIFNlY3VyaXR5IGhlYWRlcnMgZm9yIEFQSSByZXNwb25zZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFNlY3VyaXR5SGVhZGVycyhyZXNwb25zZTogTmV4dFJlc3BvbnNlKTogTmV4dFJlc3BvbnNlIHtcbiAgLy8gUmVtb3ZlIHNlcnZlciBpbmZvcm1hdGlvblxuICByZXNwb25zZS5oZWFkZXJzLmRlbGV0ZSgnc2VydmVyJyk7XG4gIHJlc3BvbnNlLmhlYWRlcnMuZGVsZXRlKCd4LXBvd2VyZWQtYnknKTtcblxuICAvLyBBZGQgc2VjdXJpdHkgaGVhZGVyc1xuICByZXNwb25zZS5oZWFkZXJzLnNldCgnWC1Db250ZW50LVR5cGUtT3B0aW9ucycsICdub3NuaWZmJyk7XG4gIHJlc3BvbnNlLmhlYWRlcnMuc2V0KCdYLUZyYW1lLU9wdGlvbnMnLCAnREVOWScpO1xuICByZXNwb25zZS5oZWFkZXJzLnNldCgnWC1YU1MtUHJvdGVjdGlvbicsICcxOyBtb2RlPWJsb2NrJyk7XG4gIHJlc3BvbnNlLmhlYWRlcnMuc2V0KCdSZWZlcnJlci1Qb2xpY3knLCAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbicpO1xuICByZXNwb25zZS5oZWFkZXJzLnNldCgnUGVybWlzc2lvbnMtUG9saWN5JywgJ2NhbWVyYT0oKSwgbWljcm9waG9uZT0oKSwgZ2VvbG9jYXRpb249KCknKTtcblxuICAvLyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3IgQVBJXG4gIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFxuICAgICdDb250ZW50LVNlY3VyaXR5LVBvbGljeScsXG4gICAgXCJkZWZhdWx0LXNyYyAnbm9uZSc7IGZyYW1lLWFuY2VzdG9ycyAnbm9uZSc7XCJcbiAgKTtcblxuICAvLyBIU1RTIGluIHByb2R1Y3Rpb25cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXNwb25zZS5oZWFkZXJzLnNldChcbiAgICAgICdTdHJpY3QtVHJhbnNwb3J0LVNlY3VyaXR5JyxcbiAgICAgICdtYXgtYWdlPTMxNTM2MDAwOyBpbmNsdWRlU3ViRG9tYWluczsgcHJlbG9hZCdcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuXG4vKipcbiAqIFNhbml0aXplIHJlcXVlc3QgYm9keSB0byBwcmV2ZW50IGluamVjdGlvbiBhdHRhY2tzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZVJlcXVlc3RCb2R5KGJvZHk6IGFueSk6IGFueSB7XG4gIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc2FuaXRpemVTdHJpbmcoYm9keSk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShib2R5KSkge1xuICAgIHJldHVybiBib2R5Lm1hcChpdGVtID0+IHNhbml0aXplUmVxdWVzdEJvZHkoaXRlbSkpO1xuICB9XG5cbiAgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3Qgc2FuaXRpemVkOiBhbnkgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhib2R5KSkge1xuICAgICAgLy8gU2FuaXRpemUga2V5c1xuICAgICAgY29uc3Qgc2FuaXRpemVkS2V5ID0gc2FuaXRpemVTdHJpbmcoa2V5KTtcbiAgICAgIHNhbml0aXplZFtzYW5pdGl6ZWRLZXldID0gc2FuaXRpemVSZXF1ZXN0Qm9keSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBzYW5pdGl6ZWQ7XG4gIH1cblxuICByZXR1cm4gYm9keTtcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSBzdHJpbmcgdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIHNhbml0aXplU3RyaW5nKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIC8vIFJlbW92ZSBkYW5nZXJvdXMgcGF0dGVybnNcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKC88c2NyaXB0XFxiW148XSooPzooPyE8XFwvc2NyaXB0Pik8W148XSopKjxcXC9zY3JpcHQ+L2dpLCAnJylcbiAgICAucmVwbGFjZSgvPGlmcmFtZVxcYltePF0qKD86KD8hPFxcL2lmcmFtZT4pPFtePF0qKSo8XFwvaWZyYW1lPi9naSwgJycpXG4gICAgLnJlcGxhY2UoL2phdmFzY3JpcHQ6L2dpLCAnJylcbiAgICAucmVwbGFjZSgvdmJzY3JpcHQ6L2dpLCAnJylcbiAgICAucmVwbGFjZSgvZGF0YTp0ZXh0XFwvaHRtbC9naSwgJycpXG4gICAgLnJlcGxhY2UoL29uXFx3K1xccyo9L2dpLCAnJylcbiAgICAudHJpbSgpO1xufVxuXG4vKipcbiAqIExvZyBzZWN1cml0eSBldmVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvZ1NlY3VyaXR5RXZlbnQoXG4gIGV2ZW50OiBzdHJpbmcsXG4gIGRldGFpbHM6IHtcbiAgICByZXF1ZXN0PzogUmVxdWVzdDtcbiAgICBpcD86IHN0cmluZztcbiAgICB1c2VyQWdlbnQ/OiBzdHJpbmc7XG4gICAgc2V2ZXJpdHk/OiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnO1xuICAgIFtrZXk6IHN0cmluZ106IGFueTtcbiAgfVxuKTogdm9pZCB7XG4gIGNvbnN0IGxvZ0VudHJ5ID0ge1xuICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGV2ZW50LFxuICAgIHNldmVyaXR5OiBkZXRhaWxzLnNldmVyaXR5IHx8ICdtZWRpdW0nLFxuICAgIGlwOiBkZXRhaWxzLmlwIHx8ICd1bmtub3duJyxcbiAgICB1c2VyQWdlbnQ6IGRldGFpbHMudXNlckFnZW50IHx8ICd1bmtub3duJyxcbiAgICAuLi5kZXRhaWxzLFxuICB9O1xuXG4gIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQgZ28gdG8gYSBwcm9wZXIgbG9nZ2luZyBzZXJ2aWNlXG4gIGlmIChkZXRhaWxzLnNldmVyaXR5ID09PSAnaGlnaCcpIHtcbiAgICBjb25zb2xlLmVycm9yKCfwn5qoIEhJR0ggU0VWRVJJVFkgU0VDVVJJVFkgRVZFTlQ6JywgbG9nRW50cnkpO1xuICB9IGVsc2UgaWYgKGRldGFpbHMuc2V2ZXJpdHkgPT09ICdtZWRpdW0nKSB7XG4gICAgY29uc29sZS53YXJuKCfimqDvuI8gU0VDVVJJVFkgRVZFTlQ6JywgbG9nRW50cnkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuaW5mbygn4oS577iPIFNlY3VyaXR5IGV2ZW50OicsIGxvZ0VudHJ5KTtcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGZpbGUgdXBsb2FkIChpZiBuZWVkZWQgaW4gdGhlIGZ1dHVyZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmlsZVVwbG9hZChcbiAgZmlsZTogRmlsZSxcbiAgb3B0aW9uczoge1xuICAgIG1heFNpemU/OiBudW1iZXI7XG4gICAgYWxsb3dlZFR5cGVzPzogc3RyaW5nW107XG4gICAgYWxsb3dlZEV4dGVuc2lvbnM/OiBzdHJpbmdbXTtcbiAgfSA9IHt9XG4pOiB2b2lkIHtcbiAgY29uc3Qge1xuICAgIG1heFNpemUgPSAxMCAqIDEwMjQgKiAxMDI0LCAvLyAxME1CXG4gICAgYWxsb3dlZFR5cGVzID0gWydhcHBsaWNhdGlvbi9qc29uJywgJ3RleHQvcGxhaW4nXSxcbiAgICBhbGxvd2VkRXh0ZW5zaW9ucyA9IFsnLmpzb24nLCAnLnR4dCddLFxuICB9ID0gb3B0aW9ucztcblxuICBpZiAoZmlsZS5zaXplID4gbWF4U2l6ZSkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYEZpbGUgc2l6ZSBleGNlZWRzIG1heGltdW0gb2YgJHttYXhTaXplfSBieXRlc2ApO1xuICB9XG5cbiAgaWYgKCFhbGxvd2VkVHlwZXMuaW5jbHVkZXMoZmlsZS50eXBlKSkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYEZpbGUgdHlwZSAke2ZpbGUudHlwZX0gaXMgbm90IGFsbG93ZWRgKTtcbiAgfVxuXG4gIGNvbnN0IGV4dGVuc2lvbiA9IGZpbGUubmFtZS50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZyhmaWxlLm5hbWUubGFzdEluZGV4T2YoJy4nKSk7XG4gIGlmICghYWxsb3dlZEV4dGVuc2lvbnMuaW5jbHVkZXMoZXh0ZW5zaW9uKSkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYEZpbGUgZXh0ZW5zaW9uICR7ZXh0ZW5zaW9ufSBpcyBub3QgYWxsb3dlZGApO1xuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGUgc2VjdXJlIHJhbmRvbSB0b2tlbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU2VjdXJlVG9rZW4obGVuZ3RoOiBudW1iZXIgPSAzMik6IHN0cmluZyB7XG4gIGNvbnN0IGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5JztcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBcbiAgLy8gVXNlIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgaWYgYXZhaWxhYmxlIChicm93c2VyL05vZGUuanMpXG4gIGlmICh0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSBjaGFyc1thcnJheVtpXSAlIGNoYXJzLmxlbmd0aF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrIHRvIE1hdGgucmFuZG9tIChsZXNzIHNlY3VyZSlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gY2hhcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKV07XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gcmVzdWx0O1xufSJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJ3aXRoQ29ycyIsIndpdGhSYXRlTGltaXQiLCJoYW5kbGVBc3luY1JvdXRlIiwiVmFsaWRhdGlvbkVycm9yIiwid2l0aFNlY3VyaXR5IiwiaGFuZGxlciIsIm9wdGlvbnMiLCJyYXRlTGltaXQiLCJjb3JzIiwidmFsaWRhdGlvbiIsIm1heEJvZHlTaXplIiwic2VjdXJlSGFuZGxlciIsIndpdGhWYWxpZGF0aW9uIiwicmVxdWVzdCIsImNvbnRleHQiLCJuZXh0UmVxdWVzdCIsImNvbnRlbnRMZW5ndGgiLCJoZWFkZXJzIiwiZ2V0IiwicGFyc2VJbnQiLCJqc29uIiwiZXJyb3IiLCJtZXNzYWdlIiwic3RhdHVzQ29kZSIsInN0YXR1cyIsImluY2x1ZGVzIiwibWV0aG9kIiwiY29udGVudFR5cGUiLCJzdXNwaWNpb3VzSGVhZGVycyIsImhlYWRlciIsImNvbnNvbGUiLCJ3YXJuIiwidXJsIiwiaXAiLCJ1c2VyQWdlbnQiLCJVUkwiLCJjb250YWluc1N1c3BpY2lvdXNQYXR0ZXJucyIsInBhdGhuYW1lIiwicGF0aCIsInN1c3BpY2lvdXNQYXR0ZXJucyIsInNvbWUiLCJwYXR0ZXJuIiwidGVzdCIsImFkZFNlY3VyaXR5SGVhZGVycyIsInJlc3BvbnNlIiwiZGVsZXRlIiwic2V0IiwicHJvY2VzcyIsInNhbml0aXplUmVxdWVzdEJvZHkiLCJib2R5Iiwic2FuaXRpemVTdHJpbmciLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJpdGVtIiwic2FuaXRpemVkIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwic2FuaXRpemVkS2V5Iiwic3RyIiwicmVwbGFjZSIsInRyaW0iLCJsb2dTZWN1cml0eUV2ZW50IiwiZXZlbnQiLCJkZXRhaWxzIiwibG9nRW50cnkiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzZXZlcml0eSIsImluZm8iLCJ2YWxpZGF0ZUZpbGVVcGxvYWQiLCJmaWxlIiwibWF4U2l6ZSIsImFsbG93ZWRUeXBlcyIsImFsbG93ZWRFeHRlbnNpb25zIiwic2l6ZSIsInR5cGUiLCJleHRlbnNpb24iLCJuYW1lIiwidG9Mb3dlckNhc2UiLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsImdlbmVyYXRlU2VjdXJlVG9rZW4iLCJsZW5ndGgiLCJjaGFycyIsInJlc3VsdCIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsImFycmF5IiwiVWludDhBcnJheSIsImkiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/security.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/validation.ts":
/*!*******************************!*\
  !*** ./src/lib/validation.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sanitizeInput: () => (/* binding */ sanitizeInput),\n/* harmony export */   validateApiKey: () => (/* binding */ validateApiKey),\n/* harmony export */   validateChatRequest: () => (/* binding */ validateChatRequest),\n/* harmony export */   validateEmail: () => (/* binding */ validateEmail),\n/* harmony export */   validateMCPServerConfig: () => (/* binding */ validateMCPServerConfig),\n/* harmony export */   validateRunToolRequest: () => (/* binding */ validateRunToolRequest),\n/* harmony export */   validateSettings: () => (/* binding */ validateSettings),\n/* harmony export */   validateStringLength: () => (/* binding */ validateStringLength),\n/* harmony export */   validateToolCall: () => (/* binding */ validateToolCall),\n/* harmony export */   validateUrl: () => (/* binding */ validateUrl),\n/* harmony export */   validateUserPreferences: () => (/* binding */ validateUserPreferences)\n/* harmony export */ });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors */ \"(rsc)/./src/lib/errors.ts\");\n\nfunction validateChatRequest(data) {\n    if (!data || typeof data !== 'object') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Request body must be a valid JSON object');\n    }\n    const { messages, sessionId, provider, model, apiKey, baseUrl, systemPrompt, temperature, maxTokens, availableTools } = data;\n    if (!Array.isArray(messages)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Messages must be an array');\n    }\n    if (messages.length === 0) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Messages array cannot be empty');\n    }\n    // Validate each message\n    messages.forEach((message, index)=>{\n        if (!message.id || typeof message.id !== 'string' || message.id.trim().length === 0) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`Message at index ${index} must have a valid non-empty id`);\n        }\n        // Validate message ID format (prevent injection)\n        if (!/^[a-zA-Z0-9_-]+$/.test(message.id)) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`Message at index ${index} has invalid ID format`);\n        }\n        if (!message.role || ![\n            'user',\n            'assistant',\n            'tool',\n            'system'\n        ].includes(message.role)) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`Message at index ${index} must have a valid role`);\n        }\n        if (typeof message.content !== 'string') {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`Message at index ${index} must have string content`);\n        }\n        // Validate content length\n        validateStringLength(message.content, `Message ${index} content`, 50000);\n        // Sanitize message content to prevent XSS\n        message.content = sanitizeInput(message.content);\n        // Validate timestamp if present\n        if (message.timestamp && !(message.timestamp instanceof Date) && isNaN(Date.parse(message.timestamp))) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`Message at index ${index} has invalid timestamp`);\n        }\n        // Validate tool calls if present\n        if (message.toolCalls && Array.isArray(message.toolCalls)) {\n            message.toolCalls.forEach((toolCall, toolIndex)=>{\n                validateToolCall(toolCall, `Message ${index}, tool call ${toolIndex}`);\n            });\n        }\n    });\n    if (!sessionId || typeof sessionId !== 'string') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Session ID must be a valid string');\n    }\n    // Validate session ID format\n    if (!/^[a-zA-Z0-9_-]+$/.test(sessionId)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Session ID contains invalid characters');\n    }\n    validateStringLength(sessionId, 'Session ID', 100);\n    if (!provider || ![\n        'openai',\n        'deepseek',\n        'openrouter'\n    ].includes(provider)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Provider must be one of: openai, deepseek, openrouter');\n    }\n    if (!model || typeof model !== 'string') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Model must be a valid string');\n    }\n    // Validate optional parameters\n    if (apiKey !== undefined && typeof apiKey !== 'string') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('API key must be a string');\n    }\n    if (baseUrl !== undefined && typeof baseUrl !== 'string') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Base URL must be a string');\n    }\n    if (systemPrompt !== undefined && typeof systemPrompt !== 'string') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('System prompt must be a string');\n    }\n    if (temperature !== undefined && (typeof temperature !== 'number' || temperature < 0 || temperature > 2)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Temperature must be a number between 0 and 2');\n    }\n    if (maxTokens !== undefined && (typeof maxTokens !== 'number' || maxTokens <= 0)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Max tokens must be a positive number');\n    }\n    if (availableTools !== undefined && !Array.isArray(availableTools)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Available tools must be an array');\n    }\n    return {\n        messages: messages.map((msg)=>({\n                ...msg,\n                timestamp: msg.timestamp ? new Date(msg.timestamp) : new Date()\n            })),\n        sessionId,\n        provider: provider,\n        model,\n        apiKey,\n        baseUrl,\n        systemPrompt,\n        temperature,\n        maxTokens,\n        availableTools\n    };\n}\nfunction validateRunToolRequest(data) {\n    if (!data || typeof data !== 'object') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Request body must be a valid JSON object');\n    }\n    const { toolCall, sessionId, messages } = data;\n    validateToolCall(toolCall, 'Tool call');\n    if (!sessionId || typeof sessionId !== 'string') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Session ID must be a valid string');\n    }\n    if (!Array.isArray(messages)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Messages must be an array');\n    }\n    return {\n        toolCall,\n        sessionId,\n        messages: messages.map((msg)=>({\n                ...msg,\n                timestamp: msg.timestamp ? new Date(msg.timestamp) : new Date()\n            }))\n    };\n}\nfunction validateSettings(data) {\n    if (!data || typeof data !== 'object') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Settings must be a valid JSON object');\n    }\n    // Validate LLM providers if present\n    if (data.llmProviders) {\n        if (!Array.isArray(data.llmProviders)) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('LLM providers must be an array');\n        }\n        data.llmProviders.forEach((provider, index)=>{\n            if (!provider || typeof provider !== 'object') {\n                throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`LLM provider at index ${index} must be a valid object`);\n            }\n            if (!provider.id || typeof provider.id !== 'string') {\n                throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`LLM provider at index ${index} must have a valid id`);\n            }\n            if (!/^[a-zA-Z0-9_-]+$/.test(provider.id)) {\n                throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`LLM provider at index ${index} has invalid ID format`);\n            }\n            if (!provider.name || ![\n                'openai',\n                'deepseek',\n                'openrouter'\n            ].includes(provider.name)) {\n                throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`LLM provider at index ${index} must have a valid name`);\n            }\n            // Only validate API key if it's provided, not empty, and not masked\n            if (provider.apiKey && typeof provider.apiKey === 'string' && provider.apiKey.trim() !== '' && !provider.apiKey.includes('*') && !provider.apiKey.includes('')) {\n                validateApiKey(provider.apiKey, provider.name);\n            }\n            if (provider.baseUrl && typeof provider.baseUrl === 'string') {\n                if (!validateUrl(provider.baseUrl)) {\n                    throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`LLM provider at index ${index} has invalid base URL`);\n                }\n            }\n        });\n    }\n    // Validate MCP servers if present\n    if (data.mcpServers) {\n        if (!Array.isArray(data.mcpServers)) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('MCP servers must be an array');\n        }\n        data.mcpServers.forEach((server, index)=>{\n            try {\n                validateMCPServerConfig(server);\n            } catch (error) {\n                throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`MCP server at index ${index}: ${error.message}`);\n            }\n        });\n    }\n    // Validate preferences if present\n    if (data.preferences) {\n        try {\n            validateUserPreferences(data.preferences);\n        } catch (error) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`User preferences: ${error.message}`);\n        }\n    }\n    return data;\n}\nfunction sanitizeInput(input) {\n    if (typeof input !== 'string') {\n        return '';\n    }\n    // Enhanced XSS prevention\n    return input.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '').replace(/<iframe\\b[^<]*(?:(?!<\\/iframe>)<[^<]*)*<\\/iframe>/gi, '').replace(/<object\\b[^<]*(?:(?!<\\/object>)<[^<]*)*<\\/object>/gi, '').replace(/<embed\\b[^<]*(?:(?!<\\/embed>)<[^<]*)*<\\/embed>/gi, '').replace(/javascript:/gi, '').replace(/vbscript:/gi, '').replace(/data:text\\/html/gi, '').replace(/on\\w+\\s*=/gi, '').replace(/style\\s*=\\s*[\"'][^\"']*expression\\s*\\(/gi, '').trim();\n}\nfunction validateStringLength(input, fieldName, maxLength = 1000) {\n    if (input.length > maxLength) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`${fieldName} exceeds maximum length of ${maxLength} characters`);\n    }\n}\nfunction validateEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n}\nfunction validateUrl(url) {\n    try {\n        const parsed = new URL(url);\n        return [\n            'http:',\n            'https:'\n        ].includes(parsed.protocol);\n    } catch  {\n        return false;\n    }\n}\nfunction validateToolCall(toolCall, context = 'Tool call') {\n    if (!toolCall || typeof toolCall !== 'object') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`${context} must be a valid object`);\n    }\n    if (!toolCall.id || typeof toolCall.id !== 'string') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`${context} must have a valid id`);\n    }\n    // Validate tool call ID format\n    if (!/^[a-zA-Z0-9_-]+$/.test(toolCall.id)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`${context} has invalid ID format`);\n    }\n    if (toolCall.type !== 'function') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`${context} type must be \"function\"`);\n    }\n    if (!toolCall.function || typeof toolCall.function !== 'object') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`${context} must have a valid function object`);\n    }\n    if (!toolCall.function.name || typeof toolCall.function.name !== 'string') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`${context} function must have a valid name`);\n    }\n    // Validate function name format (prevent injection)\n    if (!/^[a-zA-Z][a-zA-Z0-9_]*$/.test(toolCall.function.name)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`${context} function name has invalid format`);\n    }\n    validateStringLength(toolCall.function.name, `${context} function name`, 100);\n    if (typeof toolCall.function.arguments !== 'string') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`${context} function arguments must be a string`);\n    }\n    // Validate arguments as JSON\n    try {\n        JSON.parse(toolCall.function.arguments);\n    } catch  {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`${context} function arguments must be valid JSON`);\n    }\n    validateStringLength(toolCall.function.arguments, `${context} function arguments`, 10000);\n}\nfunction validateApiKey(apiKey, provider) {\n    if (!apiKey || typeof apiKey !== 'string') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('API key must be a valid string');\n    }\n    // Basic length validation\n    if (apiKey.length < 10) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('API key is too short');\n    }\n    if (apiKey.length > 200) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('API key is too long');\n    }\n    // Provider-specific validation\n    switch(provider){\n        case 'openai':\n            if (!apiKey.startsWith('sk-')) {\n                throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('OpenAI API key must start with \"sk-\"');\n            }\n            break;\n        case 'deepseek':\n            if (!apiKey.startsWith('sk-')) {\n                throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('DeepSeek API key must start with \"sk-\"');\n            }\n            break;\n        case 'openrouter':\n            if (!apiKey.startsWith('sk-or-')) {\n                throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('OpenRouter API key must start with \"sk-or-\"');\n            }\n            break;\n    }\n    // Check for suspicious patterns\n    const suspiciousPatterns = [\n        /\\s/,\n        /[<>]/,\n        /javascript:/i,\n        /data:/i\n    ];\n    for (const pattern of suspiciousPatterns){\n        if (pattern.test(apiKey)) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('API key contains invalid characters');\n        }\n    }\n}\nfunction validateMCPServerConfig(config) {\n    if (!config || typeof config !== 'object') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('MCP server config must be a valid object');\n    }\n    if (!config.id || typeof config.id !== 'string') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('MCP server config must have a valid id');\n    }\n    // Validate ID format\n    if (!/^[a-zA-Z0-9_-]+$/.test(config.id)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('MCP server config ID has invalid format');\n    }\n    if (!config.name || typeof config.name !== 'string') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('MCP server config must have a valid name');\n    }\n    validateStringLength(config.name, 'MCP server name', 100);\n    if (!config.command || typeof config.command !== 'string') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('MCP server config must have a valid command');\n    }\n    // Validate command (prevent command injection)\n    if (!/^[a-zA-Z0-9_./\\-]+$/.test(config.command)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('MCP server command contains invalid characters');\n    }\n    if (!Array.isArray(config.args)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('MCP server args must be an array');\n    }\n    // Validate each argument\n    config.args.forEach((arg, index)=>{\n        if (typeof arg !== 'string') {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`MCP server arg at index ${index} must be a string`);\n        }\n        validateStringLength(arg, `MCP server arg ${index}`, 500);\n    });\n    // Validate environment variables if present\n    if (config.env && typeof config.env === 'object') {\n        Object.entries(config.env).forEach(([key, value])=>{\n            if (typeof key !== 'string' || typeof value !== 'string') {\n                throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('MCP server environment variables must be strings');\n            }\n            // Validate environment variable names\n            if (!/^[A-Z_][A-Z0-9_]*$/.test(key)) {\n                throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`Invalid environment variable name: ${key}`);\n            }\n            validateStringLength(key, 'Environment variable name', 100);\n            validateStringLength(value, 'Environment variable value', 1000);\n        });\n    }\n}\nfunction validateUserPreferences(preferences) {\n    if (!preferences || typeof preferences !== 'object') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('User preferences must be a valid object');\n    }\n    if (preferences.theme && ![\n        'light',\n        'dark',\n        'system'\n    ].includes(preferences.theme)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Theme must be one of: light, dark, system');\n    }\n    if (preferences.language && ![\n        'en',\n        'zh'\n    ].includes(preferences.language)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Language must be one of: en, zh');\n    }\n    if (preferences.autoScroll !== undefined && typeof preferences.autoScroll !== 'boolean') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('autoScroll must be a boolean');\n    }\n    if (preferences.soundEnabled !== undefined && typeof preferences.soundEnabled !== 'boolean') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('soundEnabled must be a boolean');\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1FBQ3RFO0lBQ0Y7QUFDRjtBQUVPLFNBQVM1Qix3QkFBd0JELFdBQWdCO0lBQ3RELElBQUksQ0FBQ0EsZUFBZSxPQUFPQSxnQkFBZ0IsVUFBVTtRQUNuRCxNQUFNLElBQUloRCxvREFBZUEsQ0FBQztJQUM1QjtJQUVBLElBQUlnRCxZQUFZOEIsS0FBSyxJQUFJLENBQUM7UUFBQztRQUFTO1FBQVE7S0FBUyxDQUFDdkQsUUFBUSxDQUFDeUIsWUFBWThCLEtBQUssR0FBRztRQUNqRixNQUFNLElBQUk5RSxvREFBZUEsQ0FBQztJQUM1QjtJQUVBLElBQUlnRCxZQUFZK0IsUUFBUSxJQUFJLENBQUM7UUFBQztRQUFNO0tBQUssQ0FBQ3hELFFBQVEsQ0FBQ3lCLFlBQVkrQixRQUFRLEdBQUc7UUFDeEUsTUFBTSxJQUFJL0Usb0RBQWVBLENBQUM7SUFDNUI7SUFFQSxJQUFJZ0QsWUFBWWdDLFVBQVUsS0FBSzdDLGFBQWEsT0FBT2EsWUFBWWdDLFVBQVUsS0FBSyxXQUFXO1FBQ3ZGLE1BQU0sSUFBSWhGLG9EQUFlQSxDQUFDO0lBQzVCO0lBRUEsSUFBSWdELFlBQVlpQyxZQUFZLEtBQUs5QyxhQUFhLE9BQU9hLFlBQVlpQyxZQUFZLEtBQUssV0FBVztRQUMzRixNQUFNLElBQUlqRixvREFBZUEsQ0FBQztJQUM1QjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvb25lYmlyZC9naXRodWIvZWJvb2stbWNwL21jcC1jaGF0LXVpL2JhY2tlbmQvc3JjL2xpYi92YWxpZGF0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZhbGlkYXRpb25FcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IENoYXRSZXF1ZXN0LCBSdW5Ub29sUmVxdWVzdCwgTExNUHJvdmlkZXIgfSBmcm9tICdAL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ2hhdFJlcXVlc3QoZGF0YTogYW55KTogQ2hhdFJlcXVlc3Qge1xuICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignUmVxdWVzdCBib2R5IG11c3QgYmUgYSB2YWxpZCBKU09OIG9iamVjdCcpO1xuICB9XG5cbiAgY29uc3QgeyBcbiAgICBtZXNzYWdlcywgXG4gICAgc2Vzc2lvbklkLCBcbiAgICBwcm92aWRlciwgXG4gICAgbW9kZWwsIFxuICAgIGFwaUtleSwgXG4gICAgYmFzZVVybCwgXG4gICAgc3lzdGVtUHJvbXB0LCBcbiAgICB0ZW1wZXJhdHVyZSwgXG4gICAgbWF4VG9rZW5zLCBcbiAgICBhdmFpbGFibGVUb29scyBcbiAgfSA9IGRhdGE7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2VzKSkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ01lc3NhZ2VzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgfVxuXG4gIGlmIChtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdNZXNzYWdlcyBhcnJheSBjYW5ub3QgYmUgZW1wdHknKTtcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIGVhY2ggbWVzc2FnZVxuICBtZXNzYWdlcy5mb3JFYWNoKChtZXNzYWdlOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICBpZiAoIW1lc3NhZ2UuaWQgfHwgdHlwZW9mIG1lc3NhZ2UuaWQgIT09ICdzdHJpbmcnIHx8IG1lc3NhZ2UuaWQudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgTWVzc2FnZSBhdCBpbmRleCAke2luZGV4fSBtdXN0IGhhdmUgYSB2YWxpZCBub24tZW1wdHkgaWRgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgbWVzc2FnZSBJRCBmb3JtYXQgKHByZXZlbnQgaW5qZWN0aW9uKVxuICAgIGlmICghL15bYS16QS1aMC05Xy1dKyQvLnRlc3QobWVzc2FnZS5pZCkpIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYE1lc3NhZ2UgYXQgaW5kZXggJHtpbmRleH0gaGFzIGludmFsaWQgSUQgZm9ybWF0YCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghbWVzc2FnZS5yb2xlIHx8ICFbJ3VzZXInLCAnYXNzaXN0YW50JywgJ3Rvb2wnLCAnc3lzdGVtJ10uaW5jbHVkZXMobWVzc2FnZS5yb2xlKSkge1xuICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgTWVzc2FnZSBhdCBpbmRleCAke2luZGV4fSBtdXN0IGhhdmUgYSB2YWxpZCByb2xlYCk7XG4gICAgfVxuICAgIFxuICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgTWVzc2FnZSBhdCBpbmRleCAke2luZGV4fSBtdXN0IGhhdmUgc3RyaW5nIGNvbnRlbnRgKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBjb250ZW50IGxlbmd0aFxuICAgIHZhbGlkYXRlU3RyaW5nTGVuZ3RoKG1lc3NhZ2UuY29udGVudCwgYE1lc3NhZ2UgJHtpbmRleH0gY29udGVudGAsIDUwMDAwKTtcblxuICAgIC8vIFNhbml0aXplIG1lc3NhZ2UgY29udGVudCB0byBwcmV2ZW50IFhTU1xuICAgIG1lc3NhZ2UuY29udGVudCA9IHNhbml0aXplSW5wdXQobWVzc2FnZS5jb250ZW50KTtcbiAgICBcbiAgICAvLyBWYWxpZGF0ZSB0aW1lc3RhbXAgaWYgcHJlc2VudFxuICAgIGlmIChtZXNzYWdlLnRpbWVzdGFtcCAmJiAhKG1lc3NhZ2UudGltZXN0YW1wIGluc3RhbmNlb2YgRGF0ZSkgJiYgaXNOYU4oRGF0ZS5wYXJzZShtZXNzYWdlLnRpbWVzdGFtcCkpKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBNZXNzYWdlIGF0IGluZGV4ICR7aW5kZXh9IGhhcyBpbnZhbGlkIHRpbWVzdGFtcGApO1xuICAgIH1cbiAgICBcbiAgICAvLyBWYWxpZGF0ZSB0b29sIGNhbGxzIGlmIHByZXNlbnRcbiAgICBpZiAobWVzc2FnZS50b29sQ2FsbHMgJiYgQXJyYXkuaXNBcnJheShtZXNzYWdlLnRvb2xDYWxscykpIHtcbiAgICAgIG1lc3NhZ2UudG9vbENhbGxzLmZvckVhY2goKHRvb2xDYWxsOiBhbnksIHRvb2xJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIHZhbGlkYXRlVG9vbENhbGwodG9vbENhbGwsIGBNZXNzYWdlICR7aW5kZXh9LCB0b29sIGNhbGwgJHt0b29sSW5kZXh9YCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmICghc2Vzc2lvbklkIHx8IHR5cGVvZiBzZXNzaW9uSWQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignU2Vzc2lvbiBJRCBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nJyk7XG4gIH1cbiAgXG4gIC8vIFZhbGlkYXRlIHNlc3Npb24gSUQgZm9ybWF0XG4gIGlmICghL15bYS16QS1aMC05Xy1dKyQvLnRlc3Qoc2Vzc2lvbklkKSkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ1Nlc3Npb24gSUQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzJyk7XG4gIH1cbiAgXG4gIHZhbGlkYXRlU3RyaW5nTGVuZ3RoKHNlc3Npb25JZCwgJ1Nlc3Npb24gSUQnLCAxMDApO1xuXG4gIGlmICghcHJvdmlkZXIgfHwgIVsnb3BlbmFpJywgJ2RlZXBzZWVrJywgJ29wZW5yb3V0ZXInXS5pbmNsdWRlcyhwcm92aWRlcikpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdQcm92aWRlciBtdXN0IGJlIG9uZSBvZjogb3BlbmFpLCBkZWVwc2Vlaywgb3BlbnJvdXRlcicpO1xuICB9XG5cbiAgaWYgKCFtb2RlbCB8fCB0eXBlb2YgbW9kZWwgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignTW9kZWwgbXVzdCBiZSBhIHZhbGlkIHN0cmluZycpO1xuICB9XG5cbiAgLy8gVmFsaWRhdGUgb3B0aW9uYWwgcGFyYW1ldGVyc1xuICBpZiAoYXBpS2V5ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGFwaUtleSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdBUEkga2V5IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmIChiYXNlVXJsICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGJhc2VVcmwgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignQmFzZSBVUkwgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKHN5c3RlbVByb21wdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzeXN0ZW1Qcm9tcHQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignU3lzdGVtIHByb21wdCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAodGVtcGVyYXR1cmUgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIHRlbXBlcmF0dXJlICE9PSAnbnVtYmVyJyB8fCB0ZW1wZXJhdHVyZSA8IDAgfHwgdGVtcGVyYXR1cmUgPiAyKSkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ1RlbXBlcmF0dXJlIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAyJyk7XG4gIH1cblxuICBpZiAobWF4VG9rZW5zICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBtYXhUb2tlbnMgIT09ICdudW1iZXInIHx8IG1heFRva2VucyA8PSAwKSkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ01heCB0b2tlbnMgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB9XG5cbiAgaWYgKGF2YWlsYWJsZVRvb2xzICE9PSB1bmRlZmluZWQgJiYgIUFycmF5LmlzQXJyYXkoYXZhaWxhYmxlVG9vbHMpKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignQXZhaWxhYmxlIHRvb2xzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IG1lc3NhZ2VzLm1hcCgobXNnOiBhbnkpID0+ICh7XG4gICAgICAuLi5tc2csXG4gICAgICB0aW1lc3RhbXA6IG1zZy50aW1lc3RhbXAgPyBuZXcgRGF0ZShtc2cudGltZXN0YW1wKSA6IG5ldyBEYXRlKCksXG4gICAgfSkpLFxuICAgIHNlc3Npb25JZCxcbiAgICBwcm92aWRlcjogcHJvdmlkZXIgYXMgTExNUHJvdmlkZXIsXG4gICAgbW9kZWwsXG4gICAgYXBpS2V5LFxuICAgIGJhc2VVcmwsXG4gICAgc3lzdGVtUHJvbXB0LFxuICAgIHRlbXBlcmF0dXJlLFxuICAgIG1heFRva2VucyxcbiAgICBhdmFpbGFibGVUb29scyxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUnVuVG9vbFJlcXVlc3QoZGF0YTogYW55KTogUnVuVG9vbFJlcXVlc3Qge1xuICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignUmVxdWVzdCBib2R5IG11c3QgYmUgYSB2YWxpZCBKU09OIG9iamVjdCcpO1xuICB9XG5cbiAgY29uc3QgeyB0b29sQ2FsbCwgc2Vzc2lvbklkLCBtZXNzYWdlcyB9ID0gZGF0YTtcblxuICB2YWxpZGF0ZVRvb2xDYWxsKHRvb2xDYWxsLCAnVG9vbCBjYWxsJyk7XG5cbiAgaWYgKCFzZXNzaW9uSWQgfHwgdHlwZW9mIHNlc3Npb25JZCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdTZXNzaW9uIElEIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlcykpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdNZXNzYWdlcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvb2xDYWxsLFxuICAgIHNlc3Npb25JZCxcbiAgICBtZXNzYWdlczogbWVzc2FnZXMubWFwKChtc2c6IGFueSkgPT4gKHtcbiAgICAgIC4uLm1zZyxcbiAgICAgIHRpbWVzdGFtcDogbXNnLnRpbWVzdGFtcCA/IG5ldyBEYXRlKG1zZy50aW1lc3RhbXApIDogbmV3IERhdGUoKSxcbiAgICB9KSksXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVNldHRpbmdzKGRhdGE6IGFueSkge1xuICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignU2V0dGluZ3MgbXVzdCBiZSBhIHZhbGlkIEpTT04gb2JqZWN0Jyk7XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBMTE0gcHJvdmlkZXJzIGlmIHByZXNlbnRcbiAgaWYgKGRhdGEubGxtUHJvdmlkZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEubGxtUHJvdmlkZXJzKSkge1xuICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignTExNIHByb3ZpZGVycyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuXG4gICAgZGF0YS5sbG1Qcm92aWRlcnMuZm9yRWFjaCgocHJvdmlkZXI6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKCFwcm92aWRlciB8fCB0eXBlb2YgcHJvdmlkZXIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYExMTSBwcm92aWRlciBhdCBpbmRleCAke2luZGV4fSBtdXN0IGJlIGEgdmFsaWQgb2JqZWN0YCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcHJvdmlkZXIuaWQgfHwgdHlwZW9mIHByb3ZpZGVyLmlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBMTE0gcHJvdmlkZXIgYXQgaW5kZXggJHtpbmRleH0gbXVzdCBoYXZlIGEgdmFsaWQgaWRgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEvXlthLXpBLVowLTlfLV0rJC8udGVzdChwcm92aWRlci5pZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgTExNIHByb3ZpZGVyIGF0IGluZGV4ICR7aW5kZXh9IGhhcyBpbnZhbGlkIElEIGZvcm1hdGApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXByb3ZpZGVyLm5hbWUgfHwgIVsnb3BlbmFpJywgJ2RlZXBzZWVrJywgJ29wZW5yb3V0ZXInXS5pbmNsdWRlcyhwcm92aWRlci5uYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBMTE0gcHJvdmlkZXIgYXQgaW5kZXggJHtpbmRleH0gbXVzdCBoYXZlIGEgdmFsaWQgbmFtZWApO1xuICAgICAgfVxuXG4gICAgICAvLyBPbmx5IHZhbGlkYXRlIEFQSSBrZXkgaWYgaXQncyBwcm92aWRlZCwgbm90IGVtcHR5LCBhbmQgbm90IG1hc2tlZFxuICAgICAgaWYgKHByb3ZpZGVyLmFwaUtleSAmJiBcbiAgICAgICAgICB0eXBlb2YgcHJvdmlkZXIuYXBpS2V5ID09PSAnc3RyaW5nJyAmJiBcbiAgICAgICAgICBwcm92aWRlci5hcGlLZXkudHJpbSgpICE9PSAnJyAmJiBcbiAgICAgICAgICAhcHJvdmlkZXIuYXBpS2V5LmluY2x1ZGVzKCcqJykgJiYgXG4gICAgICAgICAgIXByb3ZpZGVyLmFwaUtleS5pbmNsdWRlcygn4oCiJykpIHtcbiAgICAgICAgdmFsaWRhdGVBcGlLZXkocHJvdmlkZXIuYXBpS2V5LCBwcm92aWRlci5uYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3ZpZGVyLmJhc2VVcmwgJiYgdHlwZW9mIHByb3ZpZGVyLmJhc2VVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghdmFsaWRhdGVVcmwocHJvdmlkZXIuYmFzZVVybCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBMTE0gcHJvdmlkZXIgYXQgaW5kZXggJHtpbmRleH0gaGFzIGludmFsaWQgYmFzZSBVUkxgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gVmFsaWRhdGUgTUNQIHNlcnZlcnMgaWYgcHJlc2VudFxuICBpZiAoZGF0YS5tY3BTZXJ2ZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEubWNwU2VydmVycykpIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ01DUCBzZXJ2ZXJzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICB9XG5cbiAgICBkYXRhLm1jcFNlcnZlcnMuZm9yRWFjaCgoc2VydmVyOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbGlkYXRlTUNQU2VydmVyQ29uZmlnKHNlcnZlcik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBNQ1Agc2VydmVyIGF0IGluZGV4ICR7aW5kZXh9OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBwcmVmZXJlbmNlcyBpZiBwcmVzZW50XG4gIGlmIChkYXRhLnByZWZlcmVuY2VzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbGlkYXRlVXNlclByZWZlcmVuY2VzKGRhdGEucHJlZmVyZW5jZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBVc2VyIHByZWZlcmVuY2VzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZUlucHV0KGlucHV0OiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBcbiAgLy8gRW5oYW5jZWQgWFNTIHByZXZlbnRpb25cbiAgcmV0dXJuIGlucHV0XG4gICAgLnJlcGxhY2UoLzxzY3JpcHRcXGJbXjxdKig/Oig/ITxcXC9zY3JpcHQ+KTxbXjxdKikqPFxcL3NjcmlwdD4vZ2ksICcnKVxuICAgIC5yZXBsYWNlKC88aWZyYW1lXFxiW148XSooPzooPyE8XFwvaWZyYW1lPik8W148XSopKjxcXC9pZnJhbWU+L2dpLCAnJylcbiAgICAucmVwbGFjZSgvPG9iamVjdFxcYltePF0qKD86KD8hPFxcL29iamVjdD4pPFtePF0qKSo8XFwvb2JqZWN0Pi9naSwgJycpXG4gICAgLnJlcGxhY2UoLzxlbWJlZFxcYltePF0qKD86KD8hPFxcL2VtYmVkPik8W148XSopKjxcXC9lbWJlZD4vZ2ksICcnKVxuICAgIC5yZXBsYWNlKC9qYXZhc2NyaXB0Oi9naSwgJycpXG4gICAgLnJlcGxhY2UoL3Zic2NyaXB0Oi9naSwgJycpXG4gICAgLnJlcGxhY2UoL2RhdGE6dGV4dFxcL2h0bWwvZ2ksICcnKVxuICAgIC5yZXBsYWNlKC9vblxcdytcXHMqPS9naSwgJycpXG4gICAgLnJlcGxhY2UoL3N0eWxlXFxzKj1cXHMqW1wiJ11bXlwiJ10qZXhwcmVzc2lvblxccypcXCgvZ2ksICcnKVxuICAgIC50cmltKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVN0cmluZ0xlbmd0aChpbnB1dDogc3RyaW5nLCBmaWVsZE5hbWU6IHN0cmluZywgbWF4TGVuZ3RoOiBudW1iZXIgPSAxMDAwKTogdm9pZCB7XG4gIGlmIChpbnB1dC5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGAke2ZpZWxkTmFtZX0gZXhjZWVkcyBtYXhpbXVtIGxlbmd0aCBvZiAke21heExlbmd0aH0gY2hhcmFjdGVyc2ApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUVtYWlsKGVtYWlsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgZW1haWxSZWdleCA9IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvO1xuICByZXR1cm4gZW1haWxSZWdleC50ZXN0KGVtYWlsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVXJsKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IFVSTCh1cmwpO1xuICAgIHJldHVybiBbJ2h0dHA6JywgJ2h0dHBzOiddLmluY2x1ZGVzKHBhcnNlZC5wcm90b2NvbCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVUb29sQ2FsbCh0b29sQ2FsbDogYW55LCBjb250ZXh0OiBzdHJpbmcgPSAnVG9vbCBjYWxsJyk6IHZvaWQge1xuICBpZiAoIXRvb2xDYWxsIHx8IHR5cGVvZiB0b29sQ2FsbCAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGAke2NvbnRleHR9IG11c3QgYmUgYSB2YWxpZCBvYmplY3RgKTtcbiAgfVxuXG4gIGlmICghdG9vbENhbGwuaWQgfHwgdHlwZW9mIHRvb2xDYWxsLmlkICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYCR7Y29udGV4dH0gbXVzdCBoYXZlIGEgdmFsaWQgaWRgKTtcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIHRvb2wgY2FsbCBJRCBmb3JtYXRcbiAgaWYgKCEvXlthLXpBLVowLTlfLV0rJC8udGVzdCh0b29sQ2FsbC5pZCkpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGAke2NvbnRleHR9IGhhcyBpbnZhbGlkIElEIGZvcm1hdGApO1xuICB9XG5cbiAgaWYgKHRvb2xDYWxsLnR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGAke2NvbnRleHR9IHR5cGUgbXVzdCBiZSBcImZ1bmN0aW9uXCJgKTtcbiAgfVxuXG4gIGlmICghdG9vbENhbGwuZnVuY3Rpb24gfHwgdHlwZW9mIHRvb2xDYWxsLmZ1bmN0aW9uICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYCR7Y29udGV4dH0gbXVzdCBoYXZlIGEgdmFsaWQgZnVuY3Rpb24gb2JqZWN0YCk7XG4gIH1cblxuICBpZiAoIXRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUgfHwgdHlwZW9mIHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgJHtjb250ZXh0fSBmdW5jdGlvbiBtdXN0IGhhdmUgYSB2YWxpZCBuYW1lYCk7XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBmdW5jdGlvbiBuYW1lIGZvcm1hdCAocHJldmVudCBpbmplY3Rpb24pXG4gIGlmICghL15bYS16QS1aXVthLXpBLVowLTlfXSokLy50ZXN0KHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgJHtjb250ZXh0fSBmdW5jdGlvbiBuYW1lIGhhcyBpbnZhbGlkIGZvcm1hdGApO1xuICB9XG5cbiAgdmFsaWRhdGVTdHJpbmdMZW5ndGgodG9vbENhbGwuZnVuY3Rpb24ubmFtZSwgYCR7Y29udGV4dH0gZnVuY3Rpb24gbmFtZWAsIDEwMCk7XG5cbiAgaWYgKHR5cGVvZiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgJHtjb250ZXh0fSBmdW5jdGlvbiBhcmd1bWVudHMgbXVzdCBiZSBhIHN0cmluZ2ApO1xuICB9XG5cbiAgLy8gVmFsaWRhdGUgYXJndW1lbnRzIGFzIEpTT05cbiAgdHJ5IHtcbiAgICBKU09OLnBhcnNlKHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyk7XG4gIH0gY2F0Y2gge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYCR7Y29udGV4dH0gZnVuY3Rpb24gYXJndW1lbnRzIG11c3QgYmUgdmFsaWQgSlNPTmApO1xuICB9XG5cbiAgdmFsaWRhdGVTdHJpbmdMZW5ndGgodG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzLCBgJHtjb250ZXh0fSBmdW5jdGlvbiBhcmd1bWVudHNgLCAxMDAwMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFwaUtleShhcGlLZXk6IHN0cmluZywgcHJvdmlkZXI6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoIWFwaUtleSB8fCB0eXBlb2YgYXBpS2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ0FQSSBrZXkgbXVzdCBiZSBhIHZhbGlkIHN0cmluZycpO1xuICB9XG5cbiAgLy8gQmFzaWMgbGVuZ3RoIHZhbGlkYXRpb25cbiAgaWYgKGFwaUtleS5sZW5ndGggPCAxMCkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ0FQSSBrZXkgaXMgdG9vIHNob3J0Jyk7XG4gIH1cblxuICBpZiAoYXBpS2V5Lmxlbmd0aCA+IDIwMCkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ0FQSSBrZXkgaXMgdG9vIGxvbmcnKTtcbiAgfVxuXG4gIC8vIFByb3ZpZGVyLXNwZWNpZmljIHZhbGlkYXRpb25cbiAgc3dpdGNoIChwcm92aWRlcikge1xuICAgIGNhc2UgJ29wZW5haSc6XG4gICAgICBpZiAoIWFwaUtleS5zdGFydHNXaXRoKCdzay0nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdPcGVuQUkgQVBJIGtleSBtdXN0IHN0YXJ0IHdpdGggXCJzay1cIicpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGVlcHNlZWsnOlxuICAgICAgaWYgKCFhcGlLZXkuc3RhcnRzV2l0aCgnc2stJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignRGVlcFNlZWsgQVBJIGtleSBtdXN0IHN0YXJ0IHdpdGggXCJzay1cIicpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3BlbnJvdXRlcic6XG4gICAgICBpZiAoIWFwaUtleS5zdGFydHNXaXRoKCdzay1vci0nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdPcGVuUm91dGVyIEFQSSBrZXkgbXVzdCBzdGFydCB3aXRoIFwic2stb3ItXCInKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHN1c3BpY2lvdXMgcGF0dGVybnNcbiAgY29uc3Qgc3VzcGljaW91c1BhdHRlcm5zID0gW1xuICAgIC9cXHMvLCAgLy8gTm8gd2hpdGVzcGFjZSBhbGxvd2VkXG4gICAgL1s8Pl0vLCAgLy8gTm8gYW5nbGUgYnJhY2tldHNcbiAgICAvamF2YXNjcmlwdDovaSwgIC8vIE5vIGphdmFzY3JpcHQgcHJvdG9jb2xcbiAgICAvZGF0YTovaSwgIC8vIE5vIGRhdGEgVVJMc1xuICBdO1xuXG4gIGZvciAoY29uc3QgcGF0dGVybiBvZiBzdXNwaWNpb3VzUGF0dGVybnMpIHtcbiAgICBpZiAocGF0dGVybi50ZXN0KGFwaUtleSkpIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ0FQSSBrZXkgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU1DUFNlcnZlckNvbmZpZyhjb25maWc6IGFueSk6IHZvaWQge1xuICBpZiAoIWNvbmZpZyB8fCB0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ01DUCBzZXJ2ZXIgY29uZmlnIG11c3QgYmUgYSB2YWxpZCBvYmplY3QnKTtcbiAgfVxuXG4gIGlmICghY29uZmlnLmlkIHx8IHR5cGVvZiBjb25maWcuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignTUNQIHNlcnZlciBjb25maWcgbXVzdCBoYXZlIGEgdmFsaWQgaWQnKTtcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIElEIGZvcm1hdFxuICBpZiAoIS9eW2EtekEtWjAtOV8tXSskLy50ZXN0KGNvbmZpZy5pZCkpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdNQ1Agc2VydmVyIGNvbmZpZyBJRCBoYXMgaW52YWxpZCBmb3JtYXQnKTtcbiAgfVxuXG4gIGlmICghY29uZmlnLm5hbWUgfHwgdHlwZW9mIGNvbmZpZy5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ01DUCBzZXJ2ZXIgY29uZmlnIG11c3QgaGF2ZSBhIHZhbGlkIG5hbWUnKTtcbiAgfVxuXG4gIHZhbGlkYXRlU3RyaW5nTGVuZ3RoKGNvbmZpZy5uYW1lLCAnTUNQIHNlcnZlciBuYW1lJywgMTAwKTtcblxuICBpZiAoIWNvbmZpZy5jb21tYW5kIHx8IHR5cGVvZiBjb25maWcuY29tbWFuZCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdNQ1Agc2VydmVyIGNvbmZpZyBtdXN0IGhhdmUgYSB2YWxpZCBjb21tYW5kJyk7XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBjb21tYW5kIChwcmV2ZW50IGNvbW1hbmQgaW5qZWN0aW9uKVxuICBpZiAoIS9eW2EtekEtWjAtOV8uL1xcLV0rJC8udGVzdChjb25maWcuY29tbWFuZCkpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdNQ1Agc2VydmVyIGNvbW1hbmQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzJyk7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlnLmFyZ3MpKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignTUNQIHNlcnZlciBhcmdzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIGVhY2ggYXJndW1lbnRcbiAgY29uZmlnLmFyZ3MuZm9yRWFjaCgoYXJnOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYE1DUCBzZXJ2ZXIgYXJnIGF0IGluZGV4ICR7aW5kZXh9IG11c3QgYmUgYSBzdHJpbmdgKTtcbiAgICB9XG4gICAgdmFsaWRhdGVTdHJpbmdMZW5ndGgoYXJnLCBgTUNQIHNlcnZlciBhcmcgJHtpbmRleH1gLCA1MDApO1xuICB9KTtcblxuICAvLyBWYWxpZGF0ZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaWYgcHJlc2VudFxuICBpZiAoY29uZmlnLmVudiAmJiB0eXBlb2YgY29uZmlnLmVudiA9PT0gJ29iamVjdCcpIHtcbiAgICBPYmplY3QuZW50cmllcyhjb25maWcuZW52KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ01DUCBzZXJ2ZXIgZW52aXJvbm1lbnQgdmFyaWFibGVzIG11c3QgYmUgc3RyaW5ncycpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBuYW1lc1xuICAgICAgaWYgKCEvXltBLVpfXVtBLVowLTlfXSokLy50ZXN0KGtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgSW52YWxpZCBlbnZpcm9ubWVudCB2YXJpYWJsZSBuYW1lOiAke2tleX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFsaWRhdGVTdHJpbmdMZW5ndGgoa2V5LCAnRW52aXJvbm1lbnQgdmFyaWFibGUgbmFtZScsIDEwMCk7XG4gICAgICB2YWxpZGF0ZVN0cmluZ0xlbmd0aCh2YWx1ZSBhcyBzdHJpbmcsICdFbnZpcm9ubWVudCB2YXJpYWJsZSB2YWx1ZScsIDEwMDApO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVVzZXJQcmVmZXJlbmNlcyhwcmVmZXJlbmNlczogYW55KTogdm9pZCB7XG4gIGlmICghcHJlZmVyZW5jZXMgfHwgdHlwZW9mIHByZWZlcmVuY2VzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ1VzZXIgcHJlZmVyZW5jZXMgbXVzdCBiZSBhIHZhbGlkIG9iamVjdCcpO1xuICB9XG5cbiAgaWYgKHByZWZlcmVuY2VzLnRoZW1lICYmICFbJ2xpZ2h0JywgJ2RhcmsnLCAnc3lzdGVtJ10uaW5jbHVkZXMocHJlZmVyZW5jZXMudGhlbWUpKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignVGhlbWUgbXVzdCBiZSBvbmUgb2Y6IGxpZ2h0LCBkYXJrLCBzeXN0ZW0nKTtcbiAgfVxuXG4gIGlmIChwcmVmZXJlbmNlcy5sYW5ndWFnZSAmJiAhWydlbicsICd6aCddLmluY2x1ZGVzKHByZWZlcmVuY2VzLmxhbmd1YWdlKSkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ0xhbmd1YWdlIG11c3QgYmUgb25lIG9mOiBlbiwgemgnKTtcbiAgfVxuXG4gIGlmIChwcmVmZXJlbmNlcy5hdXRvU2Nyb2xsICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHByZWZlcmVuY2VzLmF1dG9TY3JvbGwgIT09ICdib29sZWFuJykge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ2F1dG9TY3JvbGwgbXVzdCBiZSBhIGJvb2xlYW4nKTtcbiAgfVxuXG4gIGlmIChwcmVmZXJlbmNlcy5zb3VuZEVuYWJsZWQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcHJlZmVyZW5jZXMuc291bmRFbmFibGVkICE9PSAnYm9vbGVhbicpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdzb3VuZEVuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcbiAgfVxufSJdLCJuYW1lcyI6WyJWYWxpZGF0aW9uRXJyb3IiLCJ2YWxpZGF0ZUNoYXRSZXF1ZXN0IiwiZGF0YSIsIm1lc3NhZ2VzIiwic2Vzc2lvbklkIiwicHJvdmlkZXIiLCJtb2RlbCIsImFwaUtleSIsImJhc2VVcmwiLCJzeXN0ZW1Qcm9tcHQiLCJ0ZW1wZXJhdHVyZSIsIm1heFRva2VucyIsImF2YWlsYWJsZVRvb2xzIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiZm9yRWFjaCIsIm1lc3NhZ2UiLCJpbmRleCIsImlkIiwidHJpbSIsInRlc3QiLCJyb2xlIiwiaW5jbHVkZXMiLCJjb250ZW50IiwidmFsaWRhdGVTdHJpbmdMZW5ndGgiLCJzYW5pdGl6ZUlucHV0IiwidGltZXN0YW1wIiwiRGF0ZSIsImlzTmFOIiwicGFyc2UiLCJ0b29sQ2FsbHMiLCJ0b29sQ2FsbCIsInRvb2xJbmRleCIsInZhbGlkYXRlVG9vbENhbGwiLCJ1bmRlZmluZWQiLCJtYXAiLCJtc2ciLCJ2YWxpZGF0ZVJ1blRvb2xSZXF1ZXN0IiwidmFsaWRhdGVTZXR0aW5ncyIsImxsbVByb3ZpZGVycyIsIm5hbWUiLCJ2YWxpZGF0ZUFwaUtleSIsInZhbGlkYXRlVXJsIiwibWNwU2VydmVycyIsInNlcnZlciIsInZhbGlkYXRlTUNQU2VydmVyQ29uZmlnIiwiZXJyb3IiLCJwcmVmZXJlbmNlcyIsInZhbGlkYXRlVXNlclByZWZlcmVuY2VzIiwiaW5wdXQiLCJyZXBsYWNlIiwiZmllbGROYW1lIiwibWF4TGVuZ3RoIiwidmFsaWRhdGVFbWFpbCIsImVtYWlsIiwiZW1haWxSZWdleCIsInVybCIsInBhcnNlZCIsIlVSTCIsInByb3RvY29sIiwiY29udGV4dCIsInR5cGUiLCJmdW5jdGlvbiIsImFyZ3VtZW50cyIsIkpTT04iLCJzdGFydHNXaXRoIiwic3VzcGljaW91c1BhdHRlcm5zIiwicGF0dGVybiIsImNvbmZpZyIsImNvbW1hbmQiLCJhcmdzIiwiYXJnIiwiZW52IiwiT2JqZWN0IiwiZW50cmllcyIsImtleSIsInZhbHVlIiwidGhlbWUiLCJsYW5ndWFnZSIsImF1dG9TY3JvbGwiLCJzb3VuZEVuYWJsZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/validation.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/ChatProcessor.ts":
/*!***************************************!*\
  !*** ./src/services/ChatProcessor.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatProcessor: () => (/* binding */ ChatProcessor),\n/* harmony export */   createChatProcessor: () => (/* binding */ createChatProcessor),\n/* harmony export */   estimateTokenCount: () => (/* binding */ estimateTokenCount),\n/* harmony export */   getLastUserMessage: () => (/* binding */ getLastUserMessage),\n/* harmony export */   truncateMessageHistory: () => (/* binding */ truncateMessageHistory)\n/* harmony export */ });\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/errors */ \"(rsc)/./src/lib/errors.ts\");\n\nclass ChatProcessor {\n    constructor(llmService, sessionManager){\n        this.llmService = llmService;\n        this.sessionManager = sessionManager;\n    }\n    /**\n   * Process a chat query with full message history management and tool call detection\n   */ async processQuery(request) {\n        try {\n            // Validate the request\n            this.validateProcessQueryRequest(request);\n            // Get or create session\n            let session;\n            try {\n                session = await this.sessionManager.getSession(request.sessionId);\n            } catch (error) {\n                // If session doesn't exist, create a new one\n                session = await this.sessionManager.createSession(request.provider, request.model, [], request.messages[0] // First message as initial message\n                );\n            }\n            // Construct the complete message history with system prompt\n            const messageHistory = this.constructMessageHistory(request.messages, request.systemPrompt, request.availableTools);\n            // Prepare LLM completion request\n            const llmRequest = {\n                messages: messageHistory.map((msg)=>({\n                        role: msg.role,\n                        content: msg.content,\n                        tool_calls: msg.toolCalls,\n                        tool_call_id: msg.toolCallId\n                    })),\n                model: request.model,\n                temperature: request.temperature ?? 0.7,\n                maxTokens: request.maxTokens ?? 1000\n            };\n            // Add tools if available\n            if (request.availableTools && request.availableTools.length > 0) {\n                llmRequest.tools = this.formatToolsForLLM(request.availableTools);\n                llmRequest.toolChoice = 'auto';\n            }\n            // Generate completion\n            const completion = await this.llmService.generateCompletion(llmRequest);\n            // Process the response\n            const response = {\n                sessionId: request.sessionId,\n                reply: completion.content,\n                toolCalls: completion.toolCalls,\n                usage: completion.usage,\n                finishReason: completion.finishReason\n            };\n            // Update session with new messages\n            await this.updateSessionWithResponse(request.sessionId, request.messages, completion);\n            return response;\n        } catch (error) {\n            console.error('Chat processing error:', error);\n            if (error instanceof _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError) {\n                throw error;\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.InternalServerError(`Failed to process chat query: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n    /**\n   * Process a streaming chat query (placeholder for future streaming implementation)\n   */ async processStreamingQuery(request) {\n        // For now, return a generator that yields the complete response\n        // This can be enhanced later to support true streaming\n        const response = await this.processQuery(request);\n        async function* streamGenerator() {\n            yield {\n                ...response,\n                isStreaming: true,\n                streamId: `stream_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n            };\n        }\n        return streamGenerator();\n    }\n    /**\n   * Construct system prompt based on available tools and context\n   */ constructSystemPrompt(availableTools, customPrompt) {\n        const basePrompt = customPrompt || `You are a helpful AI assistant with access to various tools through the Model Context Protocol (MCP). \n\nWhen you need to use a tool to help the user, you should:\n1. Explain what you're going to do\n2. Call the appropriate tool with the correct parameters\n3. Wait for the tool result\n4. Interpret and explain the results to the user\n\nAlways be clear about what tools you're using and why. If a tool call fails, explain the error and suggest alternatives if possible.`;\n        if (!availableTools || availableTools.length === 0) {\n            return basePrompt;\n        }\n        const toolDescriptions = availableTools.map((tool)=>`- ${tool.name}: ${tool.description}`).join('\\n');\n        return `${basePrompt}\n\nAvailable tools:\n${toolDescriptions}\n\nUse these tools when they can help answer the user's questions or complete their requests.`;\n    }\n    /**\n   * Construct complete message history with system prompt\n   */ constructMessageHistory(messages, systemPrompt, availableTools) {\n        const history = [];\n        // Add system prompt if provided or if tools are available\n        if (systemPrompt || availableTools && availableTools.length > 0) {\n            const finalSystemPrompt = this.constructSystemPrompt(availableTools, systemPrompt);\n            history.push({\n                id: `system_${Date.now()}`,\n                role: 'system',\n                content: finalSystemPrompt,\n                timestamp: new Date()\n            });\n        }\n        // Add all user messages, maintaining conversation flow\n        history.push(...messages);\n        return history;\n    }\n    /**\n   * Format MCP tools for LLM API\n   */ formatToolsForLLM(tools) {\n        return tools.map((tool)=>({\n                type: 'function',\n                function: {\n                    name: tool.name,\n                    description: tool.description,\n                    parameters: tool.inputSchema\n                }\n            }));\n    }\n    /**\n   * Update session with new messages and LLM response\n   */ async updateSessionWithResponse(sessionId, userMessages, completion) {\n        try {\n            // Add user messages to session\n            for (const message of userMessages){\n                await this.sessionManager.addMessage(sessionId, message);\n            }\n            // Add assistant response\n            if (completion.content || completion.toolCalls) {\n                const assistantMessage = {\n                    id: `assistant_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n                    role: 'assistant',\n                    content: completion.content || '',\n                    timestamp: new Date(),\n                    toolCalls: completion.toolCalls\n                };\n                await this.sessionManager.addMessage(sessionId, assistantMessage);\n            }\n            // Generate session title if this is a new conversation\n            const session = await this.sessionManager.getSession(sessionId);\n            if (session.title === 'New Chat' && session.messages.length >= 2) {\n                try {\n                    await this.sessionManager.generateSessionTitle(sessionId, this.llmService);\n                } catch (error) {\n                    console.warn('Failed to generate session title:', error);\n                // Continue without failing the entire request\n                }\n            }\n        } catch (error) {\n            console.error('Failed to update session:', error);\n        // Don't throw here as the main processing was successful\n        }\n    }\n    /**\n   * Validate process query request\n   */ validateProcessQueryRequest(request) {\n        if (!request.messages || !Array.isArray(request.messages)) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Messages must be an array');\n        }\n        if (request.messages.length === 0) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Messages array cannot be empty');\n        }\n        if (!request.sessionId || typeof request.sessionId !== 'string') {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Session ID must be a valid string');\n        }\n        if (!request.provider || ![\n            'openai',\n            'deepseek',\n            'openrouter'\n        ].includes(request.provider)) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Provider must be one of: openai, deepseek, openrouter');\n        }\n        if (!request.model || typeof request.model !== 'string') {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Model must be a valid string');\n        }\n        // Validate each message\n        request.messages.forEach((message, index)=>{\n            if (!message.id || typeof message.id !== 'string') {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`Message at index ${index} must have a valid id`);\n            }\n            if (!message.role || ![\n                'user',\n                'assistant',\n                'tool',\n                'system'\n            ].includes(message.role)) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`Message at index ${index} must have a valid role`);\n            }\n            if (typeof message.content !== 'string') {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`Message at index ${index} must have string content`);\n            }\n        });\n        // Validate optional parameters\n        if (request.temperature !== undefined && (request.temperature < 0 || request.temperature > 2)) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Temperature must be between 0 and 2');\n        }\n        if (request.maxTokens !== undefined && request.maxTokens <= 0) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Max tokens must be positive');\n        }\n    }\n    /**\n   * Detect if a message contains tool calls that need confirmation\n   */ static detectToolCalls(message) {\n        return message.toolCalls || [];\n    }\n    /**\n   * Format tool call for user confirmation\n   */ static formatToolCallForConfirmation(toolCall) {\n        let parameters = {};\n        try {\n            parameters = JSON.parse(toolCall.function.arguments);\n        } catch (error) {\n            console.warn('Failed to parse tool call arguments:', error);\n            parameters = {\n                raw_arguments: toolCall.function.arguments\n            };\n        }\n        return {\n            name: toolCall.function.name,\n            description: `Execute ${toolCall.function.name} with the provided parameters`,\n            parameters\n        };\n    }\n    /**\n   * Create a tool result message\n   */ static createToolResultMessage(toolCallId, result, isError = false) {\n        return {\n            id: `tool_result_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n            role: 'tool',\n            content: isError ? `Error: ${result}` : result,\n            timestamp: new Date(),\n            toolCallId\n        };\n    }\n}\n/**\n * Factory function to create ChatProcessor instances\n */ function createChatProcessor(llmService, sessionManager) {\n    return new ChatProcessor(llmService, sessionManager);\n}\n/**\n * Utility function to extract the last user message from a conversation\n */ function getLastUserMessage(messages) {\n    for(let i = messages.length - 1; i >= 0; i--){\n        if (messages[i].role === 'user') {\n            return messages[i];\n        }\n    }\n    return null;\n}\n/**\n * Utility function to count tokens in messages (rough estimation)\n */ function estimateTokenCount(messages) {\n    // Rough estimation: 1 token  4 characters for English text\n    const totalChars = messages.reduce((sum, msg)=>sum + msg.content.length, 0);\n    return Math.ceil(totalChars / 4);\n}\n/**\n * Utility function to truncate message history to fit within token limits\n */ function truncateMessageHistory(messages, maxTokens, preserveSystemMessage = true) {\n    if (messages.length === 0) return messages;\n    let truncatedMessages = [\n        ...messages\n    ];\n    let currentTokens = estimateTokenCount(truncatedMessages);\n    // Always preserve the system message if requested\n    const systemMessageIndex = preserveSystemMessage ? truncatedMessages.findIndex((msg)=>msg.role === 'system') : -1;\n    // Remove messages from the middle (keeping recent context) until under limit\n    while(currentTokens > maxTokens && truncatedMessages.length > 1){\n        // Find the oldest non-system message to remove\n        let indexToRemove = -1;\n        for(let i = 0; i < truncatedMessages.length; i++){\n            if (i !== systemMessageIndex && truncatedMessages[i].role !== 'system') {\n                indexToRemove = i;\n                break;\n            }\n        }\n        if (indexToRemove === -1) break; // No more messages to remove\n        truncatedMessages.splice(indexToRemove, 1);\n        currentTokens = estimateTokenCount(truncatedMessages);\n    }\n    return truncatedMessages;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvc2VydmljZXMvQ2hhdFByb2Nlc3Nvci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFHb0U7QUE4QjdELE1BQU1FO0lBSVgsWUFBWUMsVUFBc0IsRUFBRUMsY0FBOEIsQ0FBRTtRQUNsRSxJQUFJLENBQUNELFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxjQUFjLEdBQUdBO0lBQ3hCO0lBRUE7O0dBRUMsR0FDRCxNQUFNQyxhQUFhQyxPQUE0QixFQUFpQztRQUM5RSxJQUFJO1lBQ0YsdUJBQXVCO1lBQ3ZCLElBQUksQ0FBQ0MsMkJBQTJCLENBQUNEO1lBRWpDLHdCQUF3QjtZQUN4QixJQUFJRTtZQUNKLElBQUk7Z0JBQ0ZBLFVBQVUsTUFBTSxJQUFJLENBQUNKLGNBQWMsQ0FBQ0ssVUFBVSxDQUFDSCxRQUFRSSxTQUFTO1lBQ2xFLEVBQUUsT0FBT0MsT0FBTztnQkFDZCw2Q0FBNkM7Z0JBQzdDSCxVQUFVLE1BQU0sSUFBSSxDQUFDSixjQUFjLENBQUNRLGFBQWEsQ0FDL0NOLFFBQVFPLFFBQVEsRUFDaEJQLFFBQVFRLEtBQUssRUFDYixFQUFFLEVBQ0ZSLFFBQVFTLFFBQVEsQ0FBQyxFQUFFLENBQUMsbUNBQW1DOztZQUUzRDtZQUVBLDREQUE0RDtZQUM1RCxNQUFNQyxpQkFBaUIsSUFBSSxDQUFDQyx1QkFBdUIsQ0FDakRYLFFBQVFTLFFBQVEsRUFDaEJULFFBQVFZLFlBQVksRUFDcEJaLFFBQVFhLGNBQWM7WUFHeEIsaUNBQWlDO1lBQ2pDLE1BQU1DLGFBQW1DO2dCQUN2Q0wsVUFBVUMsZUFBZUssR0FBRyxDQUFDQyxDQUFBQSxNQUFRO3dCQUNuQ0MsTUFBTUQsSUFBSUMsSUFBSTt3QkFDZEMsU0FBU0YsSUFBSUUsT0FBTzt3QkFDcEJDLFlBQVlILElBQUlJLFNBQVM7d0JBQ3pCQyxjQUFjTCxJQUFJTSxVQUFVO29CQUM5QjtnQkFDQWQsT0FBT1IsUUFBUVEsS0FBSztnQkFDcEJlLGFBQWF2QixRQUFRdUIsV0FBVyxJQUFJO2dCQUNw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UUFBbUIsRUFDbkJlLFNBQWlCLEVBQ2pCeUUsd0JBQWlDLElBQUk7SUFFckMsSUFBSXhGLFNBQVNnQixNQUFNLEtBQUssR0FBRyxPQUFPaEI7SUFFbEMsSUFBSXlGLG9CQUFvQjtXQUFJekY7S0FBUztJQUNyQyxJQUFJMEYsZ0JBQWdCUixtQkFBbUJPO0lBRXZDLGtEQUFrRDtJQUNsRCxNQUFNRSxxQkFBcUJILHdCQUN2QkMsa0JBQWtCRyxTQUFTLENBQUNyRixDQUFBQSxNQUFPQSxJQUFJQyxJQUFJLEtBQUssWUFDaEQsQ0FBQztJQUVMLDZFQUE2RTtJQUM3RSxNQUFPa0YsZ0JBQWdCM0UsYUFBYTBFLGtCQUFrQnpFLE1BQU0sR0FBRyxFQUFHO1FBQ2hFLCtDQUErQztRQUMvQyxJQUFJNkUsZ0JBQWdCLENBQUM7UUFDckIsSUFBSyxJQUFJWixJQUFJLEdBQUdBLElBQUlRLGtCQUFrQnpFLE1BQU0sRUFBRWlFLElBQUs7WUFDakQsSUFBSUEsTUFBTVUsc0JBQXNCRixpQkFBaUIsQ0FBQ1IsRUFBRSxDQUFDekUsSUFBSSxLQUFLLFVBQVU7Z0JBQ3RFcUYsZ0JBQWdCWjtnQkFDaEI7WUFDRjtRQUNGO1FBRUEsSUFBSVksa0JBQWtCLENBQUMsR0FBRyxPQUFPLDZCQUE2QjtRQUU5REosa0JBQWtCSyxNQUFNLENBQUNELGVBQWU7UUFDeENILGdCQUFnQlIsbUJBQW1CTztJQUNyQztJQUVBLE9BQU9BO0FBQ1QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9vbmViaXJkL2dpdGh1Yi9lYm9vay1tY3AvbWNwLWNoYXQtdWkvYmFja2VuZC9zcmMvc2VydmljZXMvQ2hhdFByb2Nlc3Nvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMTE1TZXJ2aWNlLCBMTE1Db21wbGV0aW9uUmVxdWVzdCwgTExNQ29tcGxldGlvblJlc3BvbnNlIH0gZnJvbSAnLi9MTE1TZXJ2aWNlJztcbmltcG9ydCB7IFNlc3Npb25NYW5hZ2VyIH0gZnJvbSAnLi9TZXNzaW9uTWFuYWdlcic7XG5pbXBvcnQgeyBNZXNzYWdlLCBUb29sQ2FsbCwgTExNUHJvdmlkZXIsIE1DUFRvb2wgfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IFZhbGlkYXRpb25FcnJvciwgSW50ZXJuYWxTZXJ2ZXJFcnJvciB9IGZyb20gJ0AvbGliL2Vycm9ycyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvY2Vzc1F1ZXJ5UmVxdWVzdCB7XG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG4gIHNlc3Npb25JZDogc3RyaW5nO1xuICBwcm92aWRlcjogTExNUHJvdmlkZXI7XG4gIG1vZGVsOiBzdHJpbmc7XG4gIGF2YWlsYWJsZVRvb2xzPzogTUNQVG9vbFtdO1xuICBzeXN0ZW1Qcm9tcHQ/OiBzdHJpbmc7XG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuICBtYXhUb2tlbnM/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvY2Vzc1F1ZXJ5UmVzcG9uc2Uge1xuICByZXBseT86IHN0cmluZztcbiAgdG9vbENhbGxzPzogVG9vbENhbGxbXTtcbiAgc2Vzc2lvbklkOiBzdHJpbmc7XG4gIHVzYWdlPzoge1xuICAgIHByb21wdFRva2VuczogbnVtYmVyO1xuICAgIGNvbXBsZXRpb25Ub2tlbnM6IG51bWJlcjtcbiAgICB0b3RhbFRva2VuczogbnVtYmVyO1xuICB9O1xuICBmaW5pc2hSZWFzb24/OiAnc3RvcCcgfCAnbGVuZ3RoJyB8ICd0b29sX2NhbGxzJyB8ICdjb250ZW50X2ZpbHRlcic7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RyZWFtaW5nUHJvY2Vzc1F1ZXJ5UmVzcG9uc2UgZXh0ZW5kcyBQcm9jZXNzUXVlcnlSZXNwb25zZSB7XG4gIGlzU3RyZWFtaW5nOiBib29sZWFuO1xuICBzdHJlYW1JZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIENoYXRQcm9jZXNzb3Ige1xuICBwcml2YXRlIGxsbVNlcnZpY2U6IExMTVNlcnZpY2U7XG4gIHByaXZhdGUgc2Vzc2lvbk1hbmFnZXI6IFNlc3Npb25NYW5hZ2VyO1xuXG4gIGNvbnN0cnVjdG9yKGxsbVNlcnZpY2U6IExMTVNlcnZpY2UsIHNlc3Npb25NYW5hZ2VyOiBTZXNzaW9uTWFuYWdlcikge1xuICAgIHRoaXMubGxtU2VydmljZSA9IGxsbVNlcnZpY2U7XG4gICAgdGhpcy5zZXNzaW9uTWFuYWdlciA9IHNlc3Npb25NYW5hZ2VyO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYSBjaGF0IHF1ZXJ5IHdpdGggZnVsbCBtZXNzYWdlIGhpc3RvcnkgbWFuYWdlbWVudCBhbmQgdG9vbCBjYWxsIGRldGVjdGlvblxuICAgKi9cbiAgYXN5bmMgcHJvY2Vzc1F1ZXJ5KHJlcXVlc3Q6IFByb2Nlc3NRdWVyeVJlcXVlc3QpOiBQcm9taXNlPFByb2Nlc3NRdWVyeVJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoZSByZXF1ZXN0XG4gICAgICB0aGlzLnZhbGlkYXRlUHJvY2Vzc1F1ZXJ5UmVxdWVzdChyZXF1ZXN0KTtcblxuICAgICAgLy8gR2V0IG9yIGNyZWF0ZSBzZXNzaW9uXG4gICAgICBsZXQgc2Vzc2lvbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlc3Npb24gPSBhd2FpdCB0aGlzLnNlc3Npb25NYW5hZ2VyLmdldFNlc3Npb24ocmVxdWVzdC5zZXNzaW9uSWQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgc2Vzc2lvbiBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgIHNlc3Npb24gPSBhd2FpdCB0aGlzLnNlc3Npb25NYW5hZ2VyLmNyZWF0ZVNlc3Npb24oXG4gICAgICAgICAgcmVxdWVzdC5wcm92aWRlcixcbiAgICAgICAgICByZXF1ZXN0Lm1vZGVsLFxuICAgICAgICAgIFtdLCAvLyBNQ1Agc2VydmVycyB3aWxsIGJlIGFkZGVkIGxhdGVyXG4gICAgICAgICAgcmVxdWVzdC5tZXNzYWdlc1swXSAvLyBGaXJzdCBtZXNzYWdlIGFzIGluaXRpYWwgbWVzc2FnZVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBDb25zdHJ1Y3QgdGhlIGNvbXBsZXRlIG1lc3NhZ2UgaGlzdG9yeSB3aXRoIHN5c3RlbSBwcm9tcHRcbiAgICAgIGNvbnN0IG1lc3NhZ2VIaXN0b3J5ID0gdGhpcy5jb25zdHJ1Y3RNZXNzYWdlSGlzdG9yeShcbiAgICAgICAgcmVxdWVzdC5tZXNzYWdlcyxcbiAgICAgICAgcmVxdWVzdC5zeXN0ZW1Qcm9tcHQsXG4gICAgICAgIHJlcXVlc3QuYXZhaWxhYmxlVG9vbHNcbiAgICAgICk7XG5cbiAgICAgIC8vIFByZXBhcmUgTExNIGNvbXBsZXRpb24gcmVxdWVzdFxuICAgICAgY29uc3QgbGxtUmVxdWVzdDogTExNQ29tcGxldGlvblJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlSGlzdG9yeS5tYXAobXNnID0+ICh7XG4gICAgICAgICAgcm9sZTogbXNnLnJvbGUsXG4gICAgICAgICAgY29udGVudDogbXNnLmNvbnRlbnQsXG4gICAgICAgICAgdG9vbF9jYWxsczogbXNnLnRvb2xDYWxscyxcbiAgICAgICAgICB0b29sX2NhbGxfaWQ6IG1zZy50b29sQ2FsbElkLFxuICAgICAgICB9KSksXG4gICAgICAgIG1vZGVsOiByZXF1ZXN0Lm1vZGVsLFxuICAgICAgICB0ZW1wZXJhdHVyZTogcmVxdWVzdC50ZW1wZXJhdHVyZSA/PyAwLjcsXG4gICAgICAgIG1heFRva2VuczogcmVxdWVzdC5tYXhUb2tlbnMgPz8gMTAwMCxcbiAgICAgIH07XG5cbiAgICAgIC8vIEFkZCB0b29scyBpZiBhdmFpbGFibGVcbiAgICAgIGlmIChyZXF1ZXN0LmF2YWlsYWJsZVRvb2xzICYmIHJlcXVlc3QuYXZhaWxhYmxlVG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICBsbG1SZXF1ZXN0LnRvb2xzID0gdGhpcy5mb3JtYXRUb29sc0ZvckxMTShyZXF1ZXN0LmF2YWlsYWJsZVRvb2xzKTtcbiAgICAgICAgbGxtUmVxdWVzdC50b29sQ2hvaWNlID0gJ2F1dG8nO1xuICAgICAgfVxuXG4gICAgICAvLyBHZW5lcmF0ZSBjb21wbGV0aW9uXG4gICAgICBjb25zdCBjb21wbGV0aW9uID0gYXdhaXQgdGhpcy5sbG1TZXJ2aWNlLmdlbmVyYXRlQ29tcGxldGlvbihsbG1SZXF1ZXN0KTtcblxuICAgICAgLy8gUHJvY2VzcyB0aGUgcmVzcG9uc2VcbiAgICAgIGNvbnN0IHJlc3BvbnNlOiBQcm9jZXNzUXVlcnlSZXNwb25zZSA9IHtcbiAgICAgICAgc2Vzc2lvbklkOiByZXF1ZXN0LnNlc3Npb25JZCxcbiAgICAgICAgcmVwbHk6IGNvbXBsZXRpb24uY29udGVudCxcbiAgICAgICAgdG9vbENhbGxzOiBjb21wbGV0aW9uLnRvb2xDYWxscyxcbiAgICAgICAgdXNhZ2U6IGNvbXBsZXRpb24udXNhZ2UsXG4gICAgICAgIGZpbmlzaFJlYXNvbjogY29tcGxldGlvbi5maW5pc2hSZWFzb24sXG4gICAgICB9O1xuXG4gICAgICAvLyBVcGRhdGUgc2Vzc2lvbiB3aXRoIG5ldyBtZXNzYWdlc1xuICAgICAgYXdhaXQgdGhpcy51cGRhdGVTZXNzaW9uV2l0aFJlc3BvbnNlKHJlcXVlc3Quc2Vzc2lvbklkLCByZXF1ZXN0Lm1lc3NhZ2VzLCBjb21wbGV0aW9uKTtcblxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDaGF0IHByb2Nlc3NpbmcgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEludGVybmFsU2VydmVyRXJyb3IoYEZhaWxlZCB0byBwcm9jZXNzIGNoYXQgcXVlcnk6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYSBzdHJlYW1pbmcgY2hhdCBxdWVyeSAocGxhY2Vob2xkZXIgZm9yIGZ1dHVyZSBzdHJlYW1pbmcgaW1wbGVtZW50YXRpb24pXG4gICAqL1xuICBhc3luYyBwcm9jZXNzU3RyZWFtaW5nUXVlcnkocmVxdWVzdDogUHJvY2Vzc1F1ZXJ5UmVxdWVzdCk6IFByb21pc2U8QXN5bmNHZW5lcmF0b3I8U3RyZWFtaW5nUHJvY2Vzc1F1ZXJ5UmVzcG9uc2UsIHZvaWQsIHVua25vd24+PiB7XG4gICAgLy8gRm9yIG5vdywgcmV0dXJuIGEgZ2VuZXJhdG9yIHRoYXQgeWllbGRzIHRoZSBjb21wbGV0ZSByZXNwb25zZVxuICAgIC8vIFRoaXMgY2FuIGJlIGVuaGFuY2VkIGxhdGVyIHRvIHN1cHBvcnQgdHJ1ZSBzdHJlYW1pbmdcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvY2Vzc1F1ZXJ5KHJlcXVlc3QpO1xuICAgIFxuICAgIGFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1HZW5lcmF0b3IoKTogQXN5bmNHZW5lcmF0b3I8U3RyZWFtaW5nUHJvY2Vzc1F1ZXJ5UmVzcG9uc2UsIHZvaWQsIHVua25vd24+IHtcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgIGlzU3RyZWFtaW5nOiB0cnVlLFxuICAgICAgICBzdHJlYW1JZDogYHN0cmVhbV8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWAsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBzdHJlYW1HZW5lcmF0b3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Qgc3lzdGVtIHByb21wdCBiYXNlZCBvbiBhdmFpbGFibGUgdG9vbHMgYW5kIGNvbnRleHRcbiAgICovXG4gIGNvbnN0cnVjdFN5c3RlbVByb21wdChhdmFpbGFibGVUb29scz86IE1DUFRvb2xbXSwgY3VzdG9tUHJvbXB0Pzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBiYXNlUHJvbXB0ID0gY3VzdG9tUHJvbXB0IHx8IGBZb3UgYXJlIGEgaGVscGZ1bCBBSSBhc3Npc3RhbnQgd2l0aCBhY2Nlc3MgdG8gdmFyaW91cyB0b29scyB0aHJvdWdoIHRoZSBNb2RlbCBDb250ZXh0IFByb3RvY29sIChNQ1ApLiBcblxuV2hlbiB5b3UgbmVlZCB0byB1c2UgYSB0b29sIHRvIGhlbHAgdGhlIHVzZXIsIHlvdSBzaG91bGQ6XG4xLiBFeHBsYWluIHdoYXQgeW91J3JlIGdvaW5nIHRvIGRvXG4yLiBDYWxsIHRoZSBhcHByb3ByaWF0ZSB0b29sIHdpdGggdGhlIGNvcnJlY3QgcGFyYW1ldGVyc1xuMy4gV2FpdCBmb3IgdGhlIHRvb2wgcmVzdWx0XG40LiBJbnRlcnByZXQgYW5kIGV4cGxhaW4gdGhlIHJlc3VsdHMgdG8gdGhlIHVzZXJcblxuQWx3YXlzIGJlIGNsZWFyIGFib3V0IHdoYXQgdG9vbHMgeW91J3JlIHVzaW5nIGFuZCB3aHkuIElmIGEgdG9vbCBjYWxsIGZhaWxzLCBleHBsYWluIHRoZSBlcnJvciBhbmQgc3VnZ2VzdCBhbHRlcm5hdGl2ZXMgaWYgcG9zc2libGUuYDtcblxuICAgIGlmICghYXZhaWxhYmxlVG9vbHMgfHwgYXZhaWxhYmxlVG9vbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYmFzZVByb21wdDtcbiAgICB9XG5cbiAgICBjb25zdCB0b29sRGVzY3JpcHRpb25zID0gYXZhaWxhYmxlVG9vbHNcbiAgICAgIC5tYXAodG9vbCA9PiBgLSAke3Rvb2wubmFtZX06ICR7dG9vbC5kZXNjcmlwdGlvbn1gKVxuICAgICAgLmpvaW4oJ1xcbicpO1xuXG4gICAgcmV0dXJuIGAke2Jhc2VQcm9tcHR9XG5cbkF2YWlsYWJsZSB0b29sczpcbiR7dG9vbERlc2NyaXB0aW9uc31cblxuVXNlIHRoZXNlIHRvb2xzIHdoZW4gdGhleSBjYW4gaGVscCBhbnN3ZXIgdGhlIHVzZXIncyBxdWVzdGlvbnMgb3IgY29tcGxldGUgdGhlaXIgcmVxdWVzdHMuYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgY29tcGxldGUgbWVzc2FnZSBoaXN0b3J5IHdpdGggc3lzdGVtIHByb21wdFxuICAgKi9cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RNZXNzYWdlSGlzdG9yeShcbiAgICBtZXNzYWdlczogTWVzc2FnZVtdLFxuICAgIHN5c3RlbVByb21wdD86IHN0cmluZyxcbiAgICBhdmFpbGFibGVUb29scz86IE1DUFRvb2xbXVxuICApOiBNZXNzYWdlW10ge1xuICAgIGNvbnN0IGhpc3Rvcnk6IE1lc3NhZ2VbXSA9IFtdO1xuXG4gICAgLy8gQWRkIHN5c3RlbSBwcm9tcHQgaWYgcHJvdmlkZWQgb3IgaWYgdG9vbHMgYXJlIGF2YWlsYWJsZVxuICAgIGlmIChzeXN0ZW1Qcm9tcHQgfHwgKGF2YWlsYWJsZVRvb2xzICYmIGF2YWlsYWJsZVRvb2xzLmxlbmd0aCA+IDApKSB7XG4gICAgICBjb25zdCBmaW5hbFN5c3RlbVByb21wdCA9IHRoaXMuY29uc3RydWN0U3lzdGVtUHJvbXB0KGF2YWlsYWJsZVRvb2xzLCBzeXN0ZW1Qcm9tcHQpO1xuICAgICAgaGlzdG9yeS5wdXNoKHtcbiAgICAgICAgaWQ6IGBzeXN0ZW1fJHtEYXRlLm5vdygpfWAsXG4gICAgICAgIHJvbGU6ICdzeXN0ZW0nLFxuICAgICAgICBjb250ZW50OiBmaW5hbFN5c3RlbVByb21wdCxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFsbCB1c2VyIG1lc3NhZ2VzLCBtYWludGFpbmluZyBjb252ZXJzYXRpb24gZmxvd1xuICAgIGhpc3RvcnkucHVzaCguLi5tZXNzYWdlcyk7XG5cbiAgICByZXR1cm4gaGlzdG9yeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtYXQgTUNQIHRvb2xzIGZvciBMTE0gQVBJXG4gICAqL1xuICBwcml2YXRlIGZvcm1hdFRvb2xzRm9yTExNKHRvb2xzOiBNQ1BUb29sW10pOiBBcnJheTx7XG4gICAgdHlwZTogJ2Z1bmN0aW9uJztcbiAgICBmdW5jdGlvbjoge1xuICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICAgIHBhcmFtZXRlcnM6IG9iamVjdDtcbiAgICB9O1xuICB9PiB7XG4gICAgcmV0dXJuIHRvb2xzLm1hcCh0b29sID0+ICh7XG4gICAgICB0eXBlOiAnZnVuY3Rpb24nIGFzIGNvbnN0LFxuICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgbmFtZTogdG9vbC5uYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbixcbiAgICAgICAgcGFyYW1ldGVyczogdG9vbC5pbnB1dFNjaGVtYSxcbiAgICAgIH0sXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzZXNzaW9uIHdpdGggbmV3IG1lc3NhZ2VzIGFuZCBMTE0gcmVzcG9uc2VcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgdXBkYXRlU2Vzc2lvbldpdGhSZXNwb25zZShcbiAgICBzZXNzaW9uSWQ6IHN0cmluZyxcbiAgICB1c2VyTWVzc2FnZXM6IE1lc3NhZ2VbXSxcbiAgICBjb21wbGV0aW9uOiBMTE1Db21wbGV0aW9uUmVzcG9uc2VcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEFkZCB1c2VyIG1lc3NhZ2VzIHRvIHNlc3Npb25cbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiB1c2VyTWVzc2FnZXMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXNzaW9uTWFuYWdlci5hZGRNZXNzYWdlKHNlc3Npb25JZCwgbWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBhc3Npc3RhbnQgcmVzcG9uc2VcbiAgICAgIGlmIChjb21wbGV0aW9uLmNvbnRlbnQgfHwgY29tcGxldGlvbi50b29sQ2FsbHMpIHtcbiAgICAgICAgY29uc3QgYXNzaXN0YW50TWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgICAgICBpZDogYGFzc2lzdGFudF8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWAsXG4gICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgY29udGVudDogY29tcGxldGlvbi5jb250ZW50IHx8ICcnLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICB0b29sQ2FsbHM6IGNvbXBsZXRpb24udG9vbENhbGxzLFxuICAgICAgICB9O1xuXG4gICAgICAgIGF3YWl0IHRoaXMuc2Vzc2lvbk1hbmFnZXIuYWRkTWVzc2FnZShzZXNzaW9uSWQsIGFzc2lzdGFudE1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBHZW5lcmF0ZSBzZXNzaW9uIHRpdGxlIGlmIHRoaXMgaXMgYSBuZXcgY29udmVyc2F0aW9uXG4gICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgdGhpcy5zZXNzaW9uTWFuYWdlci5nZXRTZXNzaW9uKHNlc3Npb25JZCk7XG4gICAgICBpZiAoc2Vzc2lvbi50aXRsZSA9PT0gJ05ldyBDaGF0JyAmJiBzZXNzaW9uLm1lc3NhZ2VzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5zZXNzaW9uTWFuYWdlci5nZW5lcmF0ZVNlc3Npb25UaXRsZShzZXNzaW9uSWQsIHRoaXMubGxtU2VydmljZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZ2VuZXJhdGUgc2Vzc2lvbiB0aXRsZTonLCBlcnJvcik7XG4gICAgICAgICAgLy8gQ29udGludWUgd2l0aG91dCBmYWlsaW5nIHRoZSBlbnRpcmUgcmVxdWVzdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgc2Vzc2lvbjonLCBlcnJvcik7XG4gICAgICAvLyBEb24ndCB0aHJvdyBoZXJlIGFzIHRoZSBtYWluIHByb2Nlc3Npbmcgd2FzIHN1Y2Nlc3NmdWxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgcHJvY2VzcyBxdWVyeSByZXF1ZXN0XG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlUHJvY2Vzc1F1ZXJ5UmVxdWVzdChyZXF1ZXN0OiBQcm9jZXNzUXVlcnlSZXF1ZXN0KTogdm9pZCB7XG4gICAgaWYgKCFyZXF1ZXN0Lm1lc3NhZ2VzIHx8ICFBcnJheS5pc0FycmF5KHJlcXVlc3QubWVzc2FnZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdNZXNzYWdlcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QubWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdNZXNzYWdlcyBhcnJheSBjYW5ub3QgYmUgZW1wdHknKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcXVlc3Quc2Vzc2lvbklkIHx8IHR5cGVvZiByZXF1ZXN0LnNlc3Npb25JZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ1Nlc3Npb24gSUQgbXVzdCBiZSBhIHZhbGlkIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghcmVxdWVzdC5wcm92aWRlciB8fCAhWydvcGVuYWknLCAnZGVlcHNlZWsnLCAnb3BlbnJvdXRlciddLmluY2x1ZGVzKHJlcXVlc3QucHJvdmlkZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdQcm92aWRlciBtdXN0IGJlIG9uZSBvZjogb3BlbmFpLCBkZWVwc2Vlaywgb3BlbnJvdXRlcicpO1xuICAgIH1cblxuICAgIGlmICghcmVxdWVzdC5tb2RlbCB8fCB0eXBlb2YgcmVxdWVzdC5tb2RlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ01vZGVsIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBlYWNoIG1lc3NhZ2VcbiAgICByZXF1ZXN0Lm1lc3NhZ2VzLmZvckVhY2goKG1lc3NhZ2UsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIW1lc3NhZ2UuaWQgfHwgdHlwZW9mIG1lc3NhZ2UuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYE1lc3NhZ2UgYXQgaW5kZXggJHtpbmRleH0gbXVzdCBoYXZlIGEgdmFsaWQgaWRgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKCFtZXNzYWdlLnJvbGUgfHwgIVsndXNlcicsICdhc3Npc3RhbnQnLCAndG9vbCcsICdzeXN0ZW0nXS5pbmNsdWRlcyhtZXNzYWdlLnJvbGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYE1lc3NhZ2UgYXQgaW5kZXggJHtpbmRleH0gbXVzdCBoYXZlIGEgdmFsaWQgcm9sZWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgTWVzc2FnZSBhdCBpbmRleCAke2luZGV4fSBtdXN0IGhhdmUgc3RyaW5nIGNvbnRlbnRgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFZhbGlkYXRlIG9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICBpZiAocmVxdWVzdC50ZW1wZXJhdHVyZSAhPT0gdW5kZWZpbmVkICYmIChyZXF1ZXN0LnRlbXBlcmF0dXJlIDwgMCB8fCByZXF1ZXN0LnRlbXBlcmF0dXJlID4gMikpIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ1RlbXBlcmF0dXJlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyJyk7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QubWF4VG9rZW5zICE9PSB1bmRlZmluZWQgJiYgcmVxdWVzdC5tYXhUb2tlbnMgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignTWF4IHRva2VucyBtdXN0IGJlIHBvc2l0aXZlJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBhIG1lc3NhZ2UgY29udGFpbnMgdG9vbCBjYWxscyB0aGF0IG5lZWQgY29uZmlybWF0aW9uXG4gICAqL1xuICBzdGF0aWMgZGV0ZWN0VG9vbENhbGxzKG1lc3NhZ2U6IE1lc3NhZ2UpOiBUb29sQ2FsbFtdIHtcbiAgICByZXR1cm4gbWVzc2FnZS50b29sQ2FsbHMgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogRm9ybWF0IHRvb2wgY2FsbCBmb3IgdXNlciBjb25maXJtYXRpb25cbiAgICovXG4gIHN0YXRpYyBmb3JtYXRUb29sQ2FsbEZvckNvbmZpcm1hdGlvbih0b29sQ2FsbDogVG9vbENhbGwpOiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgcGFyYW1ldGVyczogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgfSB7XG4gICAgbGV0IHBhcmFtZXRlcnM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgcGFyYW1ldGVycyA9IEpTT04ucGFyc2UodG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgdG9vbCBjYWxsIGFyZ3VtZW50czonLCBlcnJvcik7XG4gICAgICBwYXJhbWV0ZXJzID0geyByYXdfYXJndW1lbnRzOiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdG9vbENhbGwuZnVuY3Rpb24ubmFtZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBgRXhlY3V0ZSAke3Rvb2xDYWxsLmZ1bmN0aW9uLm5hbWV9IHdpdGggdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnNgLFxuICAgICAgcGFyYW1ldGVycyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRvb2wgcmVzdWx0IG1lc3NhZ2VcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVUb29sUmVzdWx0TWVzc2FnZShcbiAgICB0b29sQ2FsbElkOiBzdHJpbmcsXG4gICAgcmVzdWx0OiBzdHJpbmcsXG4gICAgaXNFcnJvcjogYm9vbGVhbiA9IGZhbHNlXG4gICk6IE1lc3NhZ2Uge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogYHRvb2xfcmVzdWx0XyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YCxcbiAgICAgIHJvbGU6ICd0b29sJyxcbiAgICAgIGNvbnRlbnQ6IGlzRXJyb3IgPyBgRXJyb3I6ICR7cmVzdWx0fWAgOiByZXN1bHQsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICB0b29sQ2FsbElkLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBDaGF0UHJvY2Vzc29yIGluc3RhbmNlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2hhdFByb2Nlc3NvcihcbiAgbGxtU2VydmljZTogTExNU2VydmljZSxcbiAgc2Vzc2lvbk1hbmFnZXI6IFNlc3Npb25NYW5hZ2VyXG4pOiBDaGF0UHJvY2Vzc29yIHtcbiAgcmV0dXJuIG5ldyBDaGF0UHJvY2Vzc29yKGxsbVNlcnZpY2UsIHNlc3Npb25NYW5hZ2VyKTtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGV4dHJhY3QgdGhlIGxhc3QgdXNlciBtZXNzYWdlIGZyb20gYSBjb252ZXJzYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhc3RVc2VyTWVzc2FnZShtZXNzYWdlczogTWVzc2FnZVtdKTogTWVzc2FnZSB8IG51bGwge1xuICBmb3IgKGxldCBpID0gbWVzc2FnZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAobWVzc2FnZXNbaV0ucm9sZSA9PT0gJ3VzZXInKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZXNbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY291bnQgdG9rZW5zIGluIG1lc3NhZ2VzIChyb3VnaCBlc3RpbWF0aW9uKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXN0aW1hdGVUb2tlbkNvdW50KG1lc3NhZ2VzOiBNZXNzYWdlW10pOiBudW1iZXIge1xuICAvLyBSb3VnaCBlc3RpbWF0aW9uOiAxIHRva2VuIOKJiCA0IGNoYXJhY3RlcnMgZm9yIEVuZ2xpc2ggdGV4dFxuICBjb25zdCB0b3RhbENoYXJzID0gbWVzc2FnZXMucmVkdWNlKChzdW0sIG1zZykgPT4gc3VtICsgbXNnLmNvbnRlbnQubGVuZ3RoLCAwKTtcbiAgcmV0dXJuIE1hdGguY2VpbCh0b3RhbENoYXJzIC8gNCk7XG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byB0cnVuY2F0ZSBtZXNzYWdlIGhpc3RvcnkgdG8gZml0IHdpdGhpbiB0b2tlbiBsaW1pdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRydW5jYXRlTWVzc2FnZUhpc3RvcnkoXG4gIG1lc3NhZ2VzOiBNZXNzYWdlW10sXG4gIG1heFRva2VuczogbnVtYmVyLFxuICBwcmVzZXJ2ZVN5c3RlbU1lc3NhZ2U6IGJvb2xlYW4gPSB0cnVlXG4pOiBNZXNzYWdlW10ge1xuICBpZiAobWVzc2FnZXMubGVuZ3RoID09PSAwKSByZXR1cm4gbWVzc2FnZXM7XG5cbiAgbGV0IHRydW5jYXRlZE1lc3NhZ2VzID0gWy4uLm1lc3NhZ2VzXTtcbiAgbGV0IGN1cnJlbnRUb2tlbnMgPSBlc3RpbWF0ZVRva2VuQ291bnQodHJ1bmNhdGVkTWVzc2FnZXMpO1xuXG4gIC8vIEFsd2F5cyBwcmVzZXJ2ZSB0aGUgc3lzdGVtIG1lc3NhZ2UgaWYgcmVxdWVzdGVkXG4gIGNvbnN0IHN5c3RlbU1lc3NhZ2VJbmRleCA9IHByZXNlcnZlU3lzdGVtTWVzc2FnZSBcbiAgICA/IHRydW5jYXRlZE1lc3NhZ2VzLmZpbmRJbmRleChtc2cgPT4gbXNnLnJvbGUgPT09ICdzeXN0ZW0nKVxuICAgIDogLTE7XG5cbiAgLy8gUmVtb3ZlIG1lc3NhZ2VzIGZyb20gdGhlIG1pZGRsZSAoa2VlcGluZyByZWNlbnQgY29udGV4dCkgdW50aWwgdW5kZXIgbGltaXRcbiAgd2hpbGUgKGN1cnJlbnRUb2tlbnMgPiBtYXhUb2tlbnMgJiYgdHJ1bmNhdGVkTWVzc2FnZXMubGVuZ3RoID4gMSkge1xuICAgIC8vIEZpbmQgdGhlIG9sZGVzdCBub24tc3lzdGVtIG1lc3NhZ2UgdG8gcmVtb3ZlXG4gICAgbGV0IGluZGV4VG9SZW1vdmUgPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRydW5jYXRlZE1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSAhPT0gc3lzdGVtTWVzc2FnZUluZGV4ICYmIHRydW5jYXRlZE1lc3NhZ2VzW2ldLnJvbGUgIT09ICdzeXN0ZW0nKSB7XG4gICAgICAgIGluZGV4VG9SZW1vdmUgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5kZXhUb1JlbW92ZSA9PT0gLTEpIGJyZWFrOyAvLyBObyBtb3JlIG1lc3NhZ2VzIHRvIHJlbW92ZVxuXG4gICAgdHJ1bmNhdGVkTWVzc2FnZXMuc3BsaWNlKGluZGV4VG9SZW1vdmUsIDEpO1xuICAgIGN1cnJlbnRUb2tlbnMgPSBlc3RpbWF0ZVRva2VuQ291bnQodHJ1bmNhdGVkTWVzc2FnZXMpO1xuICB9XG5cbiAgcmV0dXJuIHRydW5jYXRlZE1lc3NhZ2VzO1xufSJdLCJuYW1lcyI6WyJWYWxpZGF0aW9uRXJyb3IiLCJJbnRlcm5hbFNlcnZlckVycm9yIiwiQ2hhdFByb2Nlc3NvciIsImxsbVNlcnZpY2UiLCJzZXNzaW9uTWFuYWdlciIsInByb2Nlc3NRdWVyeSIsInJlcXVlc3QiLCJ2YWxpZGF0ZVByb2Nlc3NRdWVyeVJlcXVlc3QiLCJzZXNzaW9uIiwiZ2V0U2Vzc2lvbiIsInNlc3Npb25JZCIsImVycm9yIiwiY3JlYXRlU2Vzc2lvbiIsInByb3ZpZGVyIiwibW9kZWwiLCJtZXNzYWdlcyIsIm1lc3NhZ2VIaXN0b3J5IiwiY29uc3RydWN0TWVzc2FnZUhpc3RvcnkiLCJzeXN0ZW1Qcm9tcHQiLCJhdmFpbGFibGVUb29scyIsImxsbVJlcXVlc3QiLCJtYXAiLCJtc2ciLCJyb2xlIiwiY29udGVudCIsInRvb2xfY2FsbHMiLCJ0b29sQ2FsbHMiLCJ0b29sX2NhbGxfaWQiLCJ0b29sQ2FsbElkIiwidGVtcGVyYXR1cmUiLCJtYXhUb2tlbnMiLCJsZW5ndGgiLCJ0b29scyIsImZvcm1hdFRvb2xzRm9yTExNIiwidG9vbENob2ljZSIsImNvbXBsZXRpb24iLCJnZW5lcmF0ZUNvbXBsZXRpb24iLCJyZXNwb25zZSIsInJlcGx5IiwidXNhZ2UiLCJmaW5pc2hSZWFzb24iLCJ1cGRhdGVTZXNzaW9uV2l0aFJlc3BvbnNlIiwiY29uc29sZSIsIkVycm9yIiwibWVzc2FnZSIsInByb2Nlc3NTdHJlYW1pbmdRdWVyeSIsInN0cmVhbUdlbmVyYXRvciIsImlzU3RyZWFtaW5nIiwic3RyZWFtSWQiLCJEYXRlIiwibm93IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwiY29uc3RydWN0U3lzdGVtUHJvbXB0IiwiY3VzdG9tUHJvbXB0IiwiYmFzZVByb21wdCIsInRvb2xEZXNjcmlwdGlvbnMiLCJ0b29sIiwibmFtZSIsImRlc2NyaXB0aW9uIiwiam9pbiIsImhpc3RvcnkiLCJmaW5hbFN5c3RlbVByb21wdCIsInB1c2giLCJpZCIsInRpbWVzdGFtcCIsInR5cGUiLCJmdW5jdGlvbiIsInBhcmFtZXRlcnMiLCJpbnB1dFNjaGVtYSIsInVzZXJNZXNzYWdlcyIsImFkZE1lc3NhZ2UiLCJhc3Npc3RhbnRNZXNzYWdlIiwidGl0bGUiLCJnZW5lcmF0ZVNlc3Npb25UaXRsZSIsIndhcm4iLCJBcnJheSIsImlzQXJyYXkiLCJpbmNsdWRlcyIsImZvckVhY2giLCJpbmRleCIsInVuZGVmaW5lZCIsImRldGVjdFRvb2xDYWxscyIsImZvcm1hdFRvb2xDYWxsRm9yQ29uZmlybWF0aW9uIiwidG9vbENhbGwiLCJKU09OIiwicGFyc2UiLCJhcmd1bWVudHMiLCJyYXdfYXJndW1lbnRzIiwiY3JlYXRlVG9vbFJlc3VsdE1lc3NhZ2UiLCJyZXN1bHQiLCJpc0Vycm9yIiwiY3JlYXRlQ2hhdFByb2Nlc3NvciIsImdldExhc3RVc2VyTWVzc2FnZSIsImkiLCJlc3RpbWF0ZVRva2VuQ291bnQiLCJ0b3RhbENoYXJzIiwicmVkdWNlIiwic3VtIiwiY2VpbCIsInRydW5jYXRlTWVzc2FnZUhpc3RvcnkiLCJwcmVzZXJ2ZVN5c3RlbU1lc3NhZ2UiLCJ0cnVuY2F0ZWRNZXNzYWdlcyIsImN1cnJlbnRUb2tlbnMiLCJzeXN0ZW1NZXNzYWdlSW5kZXgiLCJmaW5kSW5kZXgiLCJpbmRleFRvUmVtb3ZlIiwic3BsaWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/services/ChatProcessor.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/LLMService.ts":
/*!************************************!*\
  !*** ./src/services/LLMService.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LLMService: () => (/* binding */ LLMService),\n/* harmony export */   createLLMService: () => (/* binding */ createLLMService),\n/* harmony export */   getDefaultProviderConfig: () => (/* binding */ getDefaultProviderConfig),\n/* harmony export */   getProviderModels: () => (/* binding */ getProviderModels),\n/* harmony export */   testLLMProviderConnection: () => (/* binding */ testLLMProviderConnection),\n/* harmony export */   validateProviderConfig: () => (/* binding */ validateProviderConfig)\n/* harmony export */ });\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/errors */ \"(rsc)/./src/lib/errors.ts\");\n\nclass LLMService {\n    static{\n        this.DEFAULT_MAX_RETRIES = 3;\n    }\n    static{\n        this.DEFAULT_RETRY_DELAY = 1000; // 1 second\n    }\n    static{\n        this.DEFAULT_TIMEOUT = 30000; // 30 seconds\n    }\n    constructor(config){\n        this.config = {\n            maxRetries: LLMService.DEFAULT_MAX_RETRIES,\n            retryDelay: LLMService.DEFAULT_RETRY_DELAY,\n            timeout: LLMService.DEFAULT_TIMEOUT,\n            ...config\n        };\n        this.validateConfig();\n    }\n    /**\n   * Generate a completion using the configured LLM provider with retry logic\n   */ async generateCompletion(request) {\n        return this.executeWithRetry(async ()=>{\n            switch(this.config.provider){\n                case 'openai':\n                    return await this.callOpenAI(request);\n                case 'deepseek':\n                    return await this.callDeepSeek(request);\n                case 'openrouter':\n                    return await this.callOpenRouter(request);\n                default:\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`Unsupported LLM provider: ${this.config.provider}`);\n            }\n        });\n    }\n    /**\n   * Test the connection to the LLM provider\n   */ async testConnection() {\n        try {\n            const response = await this.generateCompletion({\n                messages: [\n                    {\n                        role: 'user',\n                        content: 'Hello'\n                    }\n                ],\n                maxTokens: 5,\n                temperature: 0\n            });\n            return {\n                success: !!response.content\n            };\n        } catch (error) {\n            console.error('Connection test failed:', error);\n            const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n            return {\n                success: false,\n                error: errorMessage\n            };\n        }\n    }\n    /**\n   * Get provider capabilities\n   */ getProviderCapabilities() {\n        switch(this.config.provider){\n            case 'openai':\n                return {\n                    supportsToolCalling: true,\n                    supportsStreaming: true,\n                    maxTokens: 128000,\n                    supportedModels: [\n                        'gpt-4',\n                        'gpt-4-turbo',\n                        'gpt-3.5-turbo'\n                    ]\n                };\n            case 'deepseek':\n                return {\n                    supportsToolCalling: true,\n                    supportsStreaming: true,\n                    maxTokens: 32000,\n                    supportedModels: [\n                        'deepseek-chat',\n                        'deepseek-coder'\n                    ]\n                };\n            case 'openrouter':\n                return {\n                    supportsToolCalling: true,\n                    supportsStreaming: true,\n                    maxTokens: 200000,\n                    supportedModels: [\n                        'anthropic/claude-3-opus',\n                        'openai/gpt-4',\n                        'meta-llama/llama-2-70b-chat'\n                    ]\n                };\n            default:\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`Unsupported LLM provider: ${this.config.provider}`);\n        }\n    }\n    /**\n   * Validate API key format for the provider\n   */ validateApiKey(apiKey) {\n        if (!apiKey || typeof apiKey !== 'string') {\n            return false;\n        }\n        switch(this.config.provider){\n            case 'openai':\n                return apiKey.startsWith('sk-') && apiKey.length > 20;\n            case 'deepseek':\n                return apiKey.startsWith('sk-') && apiKey.length > 20;\n            case 'openrouter':\n                return apiKey.startsWith('sk-or-') && apiKey.length > 30;\n            default:\n                return apiKey.length > 10; // Basic length check for unknown providers\n        }\n    }\n    /**\n   * Execute a function with retry logic for transient errors\n   */ async executeWithRetry(fn) {\n        let lastError = new Error('Unknown error');\n        const maxRetries = this.config.maxRetries || LLMService.DEFAULT_MAX_RETRIES;\n        for(let attempt = 0; attempt <= maxRetries; attempt++){\n            try {\n                return await this.withTimeout(fn(), this.config.timeout || LLMService.DEFAULT_TIMEOUT);\n            } catch (error) {\n                lastError = error;\n                // Don't retry on validation errors or non-retryable errors\n                if (error instanceof _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError || !this.isRetryableError(error)) {\n                    throw error;\n                }\n                // Don't retry on the last attempt\n                if (attempt === maxRetries) {\n                    break;\n                }\n                // Wait before retrying with exponential backoff\n                const delay = (this.config.retryDelay || LLMService.DEFAULT_RETRY_DELAY) * Math.pow(2, attempt);\n                await this.sleep(delay);\n                console.warn(`LLM request attempt ${attempt + 1} failed, retrying in ${delay}ms:`, error);\n            }\n        }\n        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.InternalServerError(`LLM request failed after ${maxRetries + 1} attempts: ${lastError.message}`);\n    }\n    /**\n   * Determine if an error is retryable\n   */ isRetryableError(error) {\n        const llmError = error;\n        // Explicitly marked as retryable\n        if (llmError.retryable !== undefined) {\n            return llmError.retryable;\n        }\n        // Network errors are generally retryable\n        if (error.message.includes('fetch') || error.message.includes('network')) {\n            return true;\n        }\n        // HTTP status codes that are retryable\n        if (llmError.statusCode) {\n            return [\n                408,\n                429,\n                500,\n                502,\n                503,\n                504\n            ].includes(llmError.statusCode);\n        }\n        // Rate limit errors\n        if (error.message.toLowerCase().includes('rate limit')) {\n            return true;\n        }\n        return false;\n    }\n    /**\n   * Add timeout to a promise\n   */ withTimeout(promise, timeoutMs) {\n        return Promise.race([\n            promise,\n            new Promise((_, reject)=>{\n                setTimeout(()=>reject(new Error(`Request timeout after ${timeoutMs}ms`)), timeoutMs);\n            })\n        ]);\n    }\n    /**\n   * Sleep for specified milliseconds\n   */ sleep(ms) {\n        return new Promise((resolve)=>setTimeout(resolve, ms));\n    }\n    validateConfig() {\n        if (!this.config.apiKey) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('API key is required');\n        }\n        if (!this.config.model) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Model is required');\n        }\n        if (![\n            'openai',\n            'deepseek',\n            'openrouter'\n        ].includes(this.config.provider)) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Invalid LLM provider');\n        }\n        if (!this.validateApiKey(this.config.apiKey)) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`Invalid API key format for ${this.config.provider}`);\n        }\n        if (this.config.maxRetries !== undefined && this.config.maxRetries < 0) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Max retries must be non-negative');\n        }\n        if (this.config.retryDelay !== undefined && this.config.retryDelay < 0) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Retry delay must be non-negative');\n        }\n        if (this.config.timeout !== undefined && this.config.timeout <= 0) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError('Timeout must be positive');\n        }\n    }\n    async callOpenAI(request) {\n        const baseUrl = this.config.baseUrl || 'https://api.openai.com/v1';\n        const url = `${baseUrl}/chat/completions`;\n        const requestBody = {\n            model: request.model || this.config.model,\n            messages: request.messages,\n            max_tokens: request.maxTokens || 1000,\n            temperature: request.temperature ?? 0.7\n        };\n        // Add tool support if tools are provided\n        if (request.tools && request.tools.length > 0) {\n            requestBody.tools = request.tools;\n            if (request.toolChoice) {\n                requestBody.tool_choice = request.toolChoice;\n            }\n        }\n        const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${this.config.apiKey}`,\n                'User-Agent': 'MCP-Chat-UI/1.0'\n            },\n            body: JSON.stringify(requestBody)\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            let errorData;\n            try {\n                errorData = JSON.parse(errorText);\n            } catch  {\n                errorData = {\n                    error: {\n                        message: errorText\n                    }\n                };\n            }\n            const error = new Error(`OpenAI API error: ${errorData.error?.message || errorText}`);\n            error.statusCode = response.status;\n            error.code = errorData.error?.code;\n            error.retryable = [\n                408,\n                429,\n                500,\n                502,\n                503,\n                504\n            ].includes(response.status);\n            throw error;\n        }\n        const data = await response.json();\n        const choice = data.choices[0];\n        if (!choice) {\n            throw new Error('No response choices returned from OpenAI API');\n        }\n        return {\n            content: choice.message?.content || '',\n            toolCalls: choice.message?.tool_calls?.map((tc)=>({\n                    id: tc.id,\n                    type: tc.type,\n                    function: {\n                        name: tc.function.name,\n                        arguments: tc.function.arguments\n                    }\n                })),\n            usage: data.usage ? {\n                promptTokens: data.usage.prompt_tokens,\n                completionTokens: data.usage.completion_tokens,\n                totalTokens: data.usage.total_tokens\n            } : undefined,\n            finishReason: choice.finish_reason\n        };\n    }\n    async callDeepSeek(request) {\n        const baseUrl = this.config.baseUrl || 'https://api.deepseek.com/v1';\n        const url = `${baseUrl}/chat/completions`;\n        const requestBody = {\n            model: request.model || this.config.model,\n            messages: request.messages,\n            max_tokens: request.maxTokens || 1000,\n            temperature: request.temperature ?? 0.7\n        };\n        // Add tool support if tools are provided\n        if (request.tools && request.tools.length > 0) {\n            requestBody.tools = request.tools;\n            if (request.toolChoice) {\n                requestBody.tool_choice = request.toolChoice;\n            }\n        }\n        const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${this.config.apiKey}`,\n                'User-Agent': 'MCP-Chat-UI/1.0'\n            },\n            body: JSON.stringify(requestBody)\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            let errorData;\n            try {\n                errorData = JSON.parse(errorText);\n            } catch  {\n                errorData = {\n                    error: {\n                        message: errorText\n                    }\n                };\n            }\n            const error = new Error(`DeepSeek API error: ${errorData.error?.message || errorText}`);\n            error.statusCode = response.status;\n            error.code = errorData.error?.code;\n            error.retryable = [\n                408,\n                429,\n                500,\n                502,\n                503,\n                504\n            ].includes(response.status);\n            throw error;\n        }\n        const data = await response.json();\n        const choice = data.choices[0];\n        if (!choice) {\n            throw new Error('No response choices returned from DeepSeek API');\n        }\n        return {\n            content: choice.message?.content || '',\n            toolCalls: choice.message?.tool_calls?.map((tc)=>({\n                    id: tc.id,\n                    type: tc.type,\n                    function: {\n                        name: tc.function.name,\n                        arguments: tc.function.arguments\n                    }\n                })),\n            usage: data.usage ? {\n                promptTokens: data.usage.prompt_tokens,\n                completionTokens: data.usage.completion_tokens,\n                totalTokens: data.usage.total_tokens\n            } : undefined,\n            finishReason: choice.finish_reason\n        };\n    }\n    async callOpenRouter(request) {\n        const baseUrl = this.config.baseUrl || 'https://openrouter.ai/api/v1';\n        const url = `${baseUrl}/chat/completions`;\n        const requestBody = {\n            model: request.model || this.config.model,\n            messages: request.messages,\n            max_tokens: request.maxTokens || 1000,\n            temperature: request.temperature ?? 0.7\n        };\n        // Add tool support if tools are provided\n        if (request.tools && request.tools.length > 0) {\n            requestBody.tools = request.tools;\n            if (request.toolChoice) {\n                requestBody.tool_choice = request.toolChoice;\n            }\n        }\n        const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${this.config.apiKey}`,\n                'HTTP-Referer': 'http://localhost:3000',\n                'X-Title': 'MCP Chat UI',\n                'User-Agent': 'MCP-Chat-UI/1.0'\n            },\n            body: JSON.stringify(requestBody)\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            let errorData;\n            try {\n                errorData = JSON.parse(errorText);\n            } catch  {\n                errorData = {\n                    error: {\n                        message: errorText\n                    }\n                };\n            }\n            const error = new Error(`OpenRouter API error: ${errorData.error?.message || errorText}`);\n            error.statusCode = response.status;\n            error.code = errorData.error?.code;\n            error.retryable = [\n                408,\n                429,\n                500,\n                502,\n                503,\n                504\n            ].includes(response.status);\n            throw error;\n        }\n        const data = await response.json();\n        const choice = data.choices[0];\n        if (!choice) {\n            throw new Error('No response choices returned from OpenRouter API');\n        }\n        return {\n            content: choice.message?.content || '',\n            toolCalls: choice.message?.tool_calls?.map((tc)=>({\n                    id: tc.id,\n                    type: tc.type,\n                    function: {\n                        name: tc.function.name,\n                        arguments: tc.function.arguments\n                    }\n                })),\n            usage: data.usage ? {\n                promptTokens: data.usage.prompt_tokens,\n                completionTokens: data.usage.completion_tokens,\n                totalTokens: data.usage.total_tokens\n            } : undefined,\n            finishReason: choice.finish_reason\n        };\n    }\n}\n/**\n * Factory function to create LLM service instances\n */ function createLLMService(config) {\n    return new LLMService(config);\n}\n/**\n * Get default configuration for a provider\n */ function getDefaultProviderConfig(provider) {\n    switch(provider){\n        case 'openai':\n            return {\n                baseUrl: 'https://api.openai.com/v1',\n                model: 'gpt-4',\n                maxRetries: 3,\n                retryDelay: 1000,\n                timeout: 30000\n            };\n        case 'deepseek':\n            return {\n                baseUrl: 'https://api.deepseek.com/v1',\n                model: 'deepseek-chat',\n                maxRetries: 3,\n                retryDelay: 1000,\n                timeout: 30000\n            };\n        case 'openrouter':\n            return {\n                baseUrl: 'https://openrouter.ai/api/v1',\n                model: 'openai/gpt-4',\n                maxRetries: 3,\n                retryDelay: 1000,\n                timeout: 45000\n            };\n        default:\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_0__.ValidationError(`Unsupported provider: ${provider}`);\n    }\n}\n/**\n * Validate provider configuration\n */ function validateProviderConfig(config) {\n    const errors = [];\n    if (!config.provider) {\n        errors.push('Provider is required');\n    } else if (![\n        'openai',\n        'deepseek',\n        'openrouter'\n    ].includes(config.provider)) {\n        errors.push('Invalid provider');\n    }\n    if (!config.apiKey) {\n        errors.push('API key is required');\n    } else if (config.provider) {\n        const service = new LLMService({\n            ...config,\n            model: 'test'\n        });\n        if (!service.validateApiKey(config.apiKey)) {\n            errors.push(`Invalid API key format for ${config.provider}`);\n        }\n    }\n    if (!config.model) {\n        errors.push('Model is required');\n    }\n    if (config.maxRetries !== undefined && config.maxRetries < 0) {\n        errors.push('Max retries must be non-negative');\n    }\n    if (config.retryDelay !== undefined && config.retryDelay < 0) {\n        errors.push('Retry delay must be non-negative');\n    }\n    if (config.timeout !== undefined && config.timeout <= 0) {\n        errors.push('Timeout must be positive');\n    }\n    return errors;\n}\n/**\n * Get available models for a provider\n */ function getProviderModels(provider) {\n    switch(provider){\n        case 'openai':\n            return [\n                {\n                    id: 'gpt-4',\n                    name: 'GPT-4',\n                    supportsToolCalling: true\n                },\n                {\n                    id: 'gpt-4-turbo',\n                    name: 'GPT-4 Turbo',\n                    supportsToolCalling: true\n                },\n                {\n                    id: 'gpt-3.5-turbo',\n                    name: 'GPT-3.5 Turbo',\n                    supportsToolCalling: true\n                }\n            ];\n        case 'deepseek':\n            return [\n                {\n                    id: 'deepseek-chat',\n                    name: 'DeepSeek Chat',\n                    supportsToolCalling: true\n                },\n                {\n                    id: 'deepseek-coder',\n                    name: 'DeepSeek Coder',\n                    supportsToolCalling: true\n                }\n            ];\n        case 'openrouter':\n            return [\n                {\n                    id: 'openai/gpt-4',\n                    name: 'GPT-4 (via OpenRouter)',\n                    supportsToolCalling: true\n                },\n                {\n                    id: 'anthropic/claude-3-opus',\n                    name: 'Claude 3 Opus',\n                    supportsToolCalling: true\n                },\n                {\n                    id: 'meta-llama/llama-2-70b-chat',\n                    name: 'Llama 2 70B',\n                    supportsToolCalling: false\n                }\n            ];\n        default:\n            return [];\n    }\n}\n/**\n *\n Test LLM provider connection\n */ async function testLLMProviderConnection(provider) {\n    if (!provider.apiKey) {\n        return {\n            success: false,\n            error: 'API key is required'\n        };\n    }\n    const baseUrl = provider.baseUrl || getDefaultProviderConfig(provider.name).baseUrl;\n    try {\n        // Create a minimal test request\n        const testPayload = {\n            model: provider.models[0]?.id || getDefaultModelForProvider(provider.name),\n            messages: [\n                {\n                    role: 'user',\n                    content: 'Hello'\n                }\n            ],\n            max_tokens: 5,\n            temperature: 0\n        };\n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        // Set authorization header based on provider\n        if (provider.name === 'openai' || provider.name === 'deepseek') {\n            headers['Authorization'] = `Bearer ${provider.apiKey}`;\n        } else if (provider.name === 'openrouter') {\n            headers['Authorization'] = `Bearer ${provider.apiKey}`;\n            headers['HTTP-Referer'] = 'https://mcp-chat-ui.local';\n            headers['X-Title'] = 'MCP Chat UI';\n        }\n        const response = await fetch(`${baseUrl}/chat/completions`, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(testPayload)\n        });\n        if (response.ok) {\n            return {\n                success: true\n            };\n        } else {\n            const errorData = await response.json().catch(()=>({}));\n            const errorMessage = errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`;\n            return {\n                success: false,\n                error: errorMessage\n            };\n        }\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Network error occurred';\n        return {\n            success: false,\n            error: errorMessage\n        };\n    }\n}\n/**\n * Helper function to get default model for provider\n */ function getDefaultModelForProvider(provider) {\n    const defaultModels = {\n        openai: 'gpt-3.5-turbo',\n        deepseek: 'deepseek-chat',\n        openrouter: 'openai/gpt-3.5-turbo'\n    };\n    return defaultModels[provider] || 'gpt-3.5-turbo';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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MkJBQTJCdkcsUUFBcUI7SUFDdkQsTUFBTTBHLGdCQUE2QztRQUNqREMsUUFBUTtRQUNSQyxVQUFVO1FBQ1ZDLFlBQVk7SUFDZDtJQUNBLE9BQU9ILGFBQWEsQ0FBQzFHLFNBQVMsSUFBSTtBQUNwQyIsInNvdXJjZXMiOlsiL1VzZXJzL29uZWJpcmQvZ2l0aHViL2Vib29rLW1jcC9tY3AtY2hhdC11aS9iYWNrZW5kL3NyYy9zZXJ2aWNlcy9MTE1TZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExMTVByb3ZpZGVyLCBNZXNzYWdlLCBUb29sQ2FsbCB9IGZyb20gJ0AvdHlwZXMnO1xuaW1wb3J0IHsgSW50ZXJuYWxTZXJ2ZXJFcnJvciwgVmFsaWRhdGlvbkVycm9yIH0gZnJvbSAnQC9saWIvZXJyb3JzJztcblxuZXhwb3J0IGludGVyZmFjZSBMTE1Db21wbGV0aW9uUmVxdWVzdCB7XG4gIG1lc3NhZ2VzOiBBcnJheTx7IHJvbGU6IHN0cmluZzsgY29udGVudDogc3RyaW5nOyB0b29sX2NhbGxzPzogVG9vbENhbGxbXTsgdG9vbF9jYWxsX2lkPzogc3RyaW5nIH0+O1xuICBtYXhUb2tlbnM/OiBudW1iZXI7XG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuICBtb2RlbD86IHN0cmluZztcbiAgdG9vbHM/OiBBcnJheTx7XG4gICAgdHlwZTogJ2Z1bmN0aW9uJztcbiAgICBmdW5jdGlvbjoge1xuICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICAgIHBhcmFtZXRlcnM6IG9iamVjdDtcbiAgICB9O1xuICB9PjtcbiAgdG9vbENob2ljZT86ICdhdXRvJyB8ICdub25lJyB8IHsgdHlwZTogJ2Z1bmN0aW9uJzsgZnVuY3Rpb246IHsgbmFtZTogc3RyaW5nIH0gfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMTE1Db21wbGV0aW9uUmVzcG9uc2Uge1xuICBjb250ZW50OiBzdHJpbmc7XG4gIHRvb2xDYWxscz86IFRvb2xDYWxsW107XG4gIHVzYWdlPzoge1xuICAgIHByb21wdFRva2VuczogbnVtYmVyO1xuICAgIGNvbXBsZXRpb25Ub2tlbnM6IG51bWJlcjtcbiAgICB0b3RhbFRva2VuczogbnVtYmVyO1xuICB9O1xuICBmaW5pc2hSZWFzb24/OiAnc3RvcCcgfCAnbGVuZ3RoJyB8ICd0b29sX2NhbGxzJyB8ICdjb250ZW50X2ZpbHRlcic7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTExNU2VydmljZUNvbmZpZyB7XG4gIHByb3ZpZGVyOiBMTE1Qcm92aWRlcjtcbiAgYXBpS2V5OiBzdHJpbmc7XG4gIGJhc2VVcmw/OiBzdHJpbmc7XG4gIG1vZGVsOiBzdHJpbmc7XG4gIG1heFJldHJpZXM/OiBudW1iZXI7XG4gIHJldHJ5RGVsYXk/OiBudW1iZXI7XG4gIHRpbWVvdXQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTExNUHJvdmlkZXJDYXBhYmlsaXRpZXMge1xuICBzdXBwb3J0c1Rvb2xDYWxsaW5nOiBib29sZWFuO1xuICBzdXBwb3J0c1N0cmVhbWluZzogYm9vbGVhbjtcbiAgbWF4VG9rZW5zOiBudW1iZXI7XG4gIHN1cHBvcnRlZE1vZGVsczogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTExNRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvZGU/OiBzdHJpbmc7XG4gIHN0YXR1c0NvZGU/OiBudW1iZXI7XG4gIHJldHJ5YWJsZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBMTE1TZXJ2aWNlIHtcbiAgcHJpdmF0ZSBjb25maWc6IExMTVNlcnZpY2VDb25maWc7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfTUFYX1JFVFJJRVMgPSAzO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBERUZBVUxUX1JFVFJZX0RFTEFZID0gMTAwMDsgLy8gMSBzZWNvbmRcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9USU1FT1VUID0gMzAwMDA7IC8vIDMwIHNlY29uZHNcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IExMTVNlcnZpY2VDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIG1heFJldHJpZXM6IExMTVNlcnZpY2UuREVGQVVMVF9NQVhfUkVUUklFUyxcbiAgICAgIHJldHJ5RGVsYXk6IExMTVNlcnZpY2UuREVGQVVMVF9SRVRSWV9ERUxBWSxcbiAgICAgIHRpbWVvdXQ6IExMTVNlcnZpY2UuREVGQVVMVF9USU1FT1VULFxuICAgICAgLi4uY29uZmlnLFxuICAgIH07XG4gICAgdGhpcy52YWxpZGF0ZUNvbmZpZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgY29tcGxldGlvbiB1c2luZyB0aGUgY29uZmlndXJlZCBMTE0gcHJvdmlkZXIgd2l0aCByZXRyeSBsb2dpY1xuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVDb21wbGV0aW9uKHJlcXVlc3Q6IExMTUNvbXBsZXRpb25SZXF1ZXN0KTogUHJvbWlzZTxMTE1Db21wbGV0aW9uUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlV2l0aFJldHJ5KGFzeW5jICgpID0+IHtcbiAgICAgIHN3aXRjaCAodGhpcy5jb25maWcucHJvdmlkZXIpIHtcbiAgICAgICAgY2FzZSAnb3BlbmFpJzpcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jYWxsT3BlbkFJKHJlcXVlc3QpO1xuICAgICAgICBjYXNlICdkZWVwc2Vlayc6XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2FsbERlZXBTZWVrKHJlcXVlc3QpO1xuICAgICAgICBjYXNlICdvcGVucm91dGVyJzpcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jYWxsT3BlblJvdXRlcihyZXF1ZXN0KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBVbnN1cHBvcnRlZCBMTE0gcHJvdmlkZXI6ICR7dGhpcy5jb25maWcucHJvdmlkZXJ9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCB0aGUgY29ubmVjdGlvbiB0byB0aGUgTExNIHByb3ZpZGVyXG4gICAqL1xuICBhc3luYyB0ZXN0Q29ubmVjdGlvbigpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVDb21wbGV0aW9uKHtcbiAgICAgICAgbWVzc2FnZXM6IFt7IHJvbGU6ICd1c2VyJywgY29udGVudDogJ0hlbGxvJyB9XSxcbiAgICAgICAgbWF4VG9rZW5zOiA1LFxuICAgICAgICB0ZW1wZXJhdHVyZTogMCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogISFyZXNwb25zZS5jb250ZW50IH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nvbm5lY3Rpb24gdGVzdCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcic7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yTWVzc2FnZSB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcHJvdmlkZXIgY2FwYWJpbGl0aWVzXG4gICAqL1xuICBnZXRQcm92aWRlckNhcGFiaWxpdGllcygpOiBMTE1Qcm92aWRlckNhcGFiaWxpdGllcyB7XG4gICAgc3dpdGNoICh0aGlzLmNvbmZpZy5wcm92aWRlcikge1xuICAgICAgY2FzZSAnb3BlbmFpJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdXBwb3J0c1Rvb2xDYWxsaW5nOiB0cnVlLFxuICAgICAgICAgIHN1cHBvcnRzU3RyZWFtaW5nOiB0cnVlLFxuICAgICAgICAgIG1heFRva2VuczogMTI4MDAwLCAvLyBHUFQtNCBjb250ZXh0IHdpbmRvd1xuICAgICAgICAgIHN1cHBvcnRlZE1vZGVsczogWydncHQtNCcsICdncHQtNC10dXJibycsICdncHQtMy41LXR1cmJvJ10sXG4gICAgICAgIH07XG4gICAgICBjYXNlICdkZWVwc2Vlayc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VwcG9ydHNUb29sQ2FsbGluZzogdHJ1ZSxcbiAgICAgICAgICBzdXBwb3J0c1N0cmVhbWluZzogdHJ1ZSxcbiAgICAgICAgICBtYXhUb2tlbnM6IDMyMDAwLFxuICAgICAgICAgIHN1cHBvcnRlZE1vZGVsczogWydkZWVwc2Vlay1jaGF0JywgJ2RlZXBzZWVrLWNvZGVyJ10sXG4gICAgICAgIH07XG4gICAgICBjYXNlICdvcGVucm91dGVyJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdXBwb3J0c1Rvb2xDYWxsaW5nOiB0cnVlLFxuICAgICAgICAgIHN1cHBvcnRzU3RyZWFtaW5nOiB0cnVlLFxuICAgICAgICAgIG1heFRva2VuczogMjAwMDAwLCAvLyBWYXJpZXMgYnkgbW9kZWxcbiAgICAgICAgICBzdXBwb3J0ZWRNb2RlbHM6IFsnYW50aHJvcGljL2NsYXVkZS0zLW9wdXMnLCAnb3BlbmFpL2dwdC00JywgJ21ldGEtbGxhbWEvbGxhbWEtMi03MGItY2hhdCddLFxuICAgICAgICB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVW5zdXBwb3J0ZWQgTExNIHByb3ZpZGVyOiAke3RoaXMuY29uZmlnLnByb3ZpZGVyfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBBUEkga2V5IGZvcm1hdCBmb3IgdGhlIHByb3ZpZGVyXG4gICAqL1xuICB2YWxpZGF0ZUFwaUtleShhcGlLZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghYXBpS2V5IHx8IHR5cGVvZiBhcGlLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLmNvbmZpZy5wcm92aWRlcikge1xuICAgICAgY2FzZSAnb3BlbmFpJzpcbiAgICAgICAgcmV0dXJuIGFwaUtleS5zdGFydHNXaXRoKCdzay0nKSAmJiBhcGlLZXkubGVuZ3RoID4gMjA7XG4gICAgICBjYXNlICdkZWVwc2Vlayc6XG4gICAgICAgIHJldHVybiBhcGlLZXkuc3RhcnRzV2l0aCgnc2stJykgJiYgYXBpS2V5Lmxlbmd0aCA+IDIwO1xuICAgICAgY2FzZSAnb3BlbnJvdXRlcic6XG4gICAgICAgIHJldHVybiBhcGlLZXkuc3RhcnRzV2l0aCgnc2stb3ItJykgJiYgYXBpS2V5Lmxlbmd0aCA+IDMwO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFwaUtleS5sZW5ndGggPiAxMDsgLy8gQmFzaWMgbGVuZ3RoIGNoZWNrIGZvciB1bmtub3duIHByb3ZpZGVyc1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgZnVuY3Rpb24gd2l0aCByZXRyeSBsb2dpYyBmb3IgdHJhbnNpZW50IGVycm9yc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBleGVjdXRlV2l0aFJldHJ5PFQ+KGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgbGV0IGxhc3RFcnJvcjogRXJyb3IgPSBuZXcgRXJyb3IoJ1Vua25vd24gZXJyb3InKTtcbiAgICBjb25zdCBtYXhSZXRyaWVzID0gdGhpcy5jb25maWcubWF4UmV0cmllcyB8fCBMTE1TZXJ2aWNlLkRFRkFVTFRfTUFYX1JFVFJJRVM7XG5cbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8PSBtYXhSZXRyaWVzOyBhdHRlbXB0KyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndpdGhUaW1lb3V0KGZuKCksIHRoaXMuY29uZmlnLnRpbWVvdXQgfHwgTExNU2VydmljZS5ERUZBVUxUX1RJTUVPVVQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbGFzdEVycm9yID0gZXJyb3IgYXMgRXJyb3I7XG4gICAgICAgIFxuICAgICAgICAvLyBEb24ndCByZXRyeSBvbiB2YWxpZGF0aW9uIGVycm9ycyBvciBub24tcmV0cnlhYmxlIGVycm9yc1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IgfHwgIXRoaXMuaXNSZXRyeWFibGVFcnJvcihlcnJvciBhcyBFcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvbid0IHJldHJ5IG9uIHRoZSBsYXN0IGF0dGVtcHRcbiAgICAgICAgaWYgKGF0dGVtcHQgPT09IG1heFJldHJpZXMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5aW5nIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICBjb25zdCBkZWxheSA9ICh0aGlzLmNvbmZpZy5yZXRyeURlbGF5IHx8IExMTVNlcnZpY2UuREVGQVVMVF9SRVRSWV9ERUxBWSkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KTtcbiAgICAgICAgYXdhaXQgdGhpcy5zbGVlcChkZWxheSk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLndhcm4oYExMTSByZXF1ZXN0IGF0dGVtcHQgJHthdHRlbXB0ICsgMX0gZmFpbGVkLCByZXRyeWluZyBpbiAke2RlbGF5fW1zOmAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgSW50ZXJuYWxTZXJ2ZXJFcnJvcihgTExNIHJlcXVlc3QgZmFpbGVkIGFmdGVyICR7bWF4UmV0cmllcyArIDF9IGF0dGVtcHRzOiAke2xhc3RFcnJvci5tZXNzYWdlfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhbiBlcnJvciBpcyByZXRyeWFibGVcbiAgICovXG4gIHByaXZhdGUgaXNSZXRyeWFibGVFcnJvcihlcnJvcjogRXJyb3IpOiBib29sZWFuIHtcbiAgICBjb25zdCBsbG1FcnJvciA9IGVycm9yIGFzIExMTUVycm9yO1xuICAgIFxuICAgIC8vIEV4cGxpY2l0bHkgbWFya2VkIGFzIHJldHJ5YWJsZVxuICAgIGlmIChsbG1FcnJvci5yZXRyeWFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGxsbUVycm9yLnJldHJ5YWJsZTtcbiAgICB9XG5cbiAgICAvLyBOZXR3b3JrIGVycm9ycyBhcmUgZ2VuZXJhbGx5IHJldHJ5YWJsZVxuICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdmZXRjaCcpIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ25ldHdvcmsnKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gSFRUUCBzdGF0dXMgY29kZXMgdGhhdCBhcmUgcmV0cnlhYmxlXG4gICAgaWYgKGxsbUVycm9yLnN0YXR1c0NvZGUpIHtcbiAgICAgIHJldHVybiBbNDA4LCA0MjksIDUwMCwgNTAyLCA1MDMsIDUwNF0uaW5jbHVkZXMobGxtRXJyb3Iuc3RhdHVzQ29kZSk7XG4gICAgfVxuXG4gICAgLy8gUmF0ZSBsaW1pdCBlcnJvcnNcbiAgICBpZiAoZXJyb3IubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdyYXRlIGxpbWl0JykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdGltZW91dCB0byBhIHByb21pc2VcbiAgICovXG4gIHByaXZhdGUgd2l0aFRpbWVvdXQ8VD4ocHJvbWlzZTogUHJvbWlzZTxUPiwgdGltZW91dE1zOiBudW1iZXIpOiBQcm9taXNlPFQ+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgIHByb21pc2UsXG4gICAgICBuZXcgUHJvbWlzZTxuZXZlcj4oKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoYFJlcXVlc3QgdGltZW91dCBhZnRlciAke3RpbWVvdXRNc31tc2ApKSwgdGltZW91dE1zKTtcbiAgICAgIH0pLFxuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNsZWVwIGZvciBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzXG4gICAqL1xuICBwcml2YXRlIHNsZWVwKG1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlQ29uZmlnKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5jb25maWcuYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdBUEkga2V5IGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb25maWcubW9kZWwpIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ01vZGVsIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghWydvcGVuYWknLCAnZGVlcHNlZWsnLCAnb3BlbnJvdXRlciddLmluY2x1ZGVzKHRoaXMuY29uZmlnLnByb3ZpZGVyKSkge1xuICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignSW52YWxpZCBMTE0gcHJvdmlkZXInKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlQXBpS2V5KHRoaXMuY29uZmlnLmFwaUtleSkpIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYEludmFsaWQgQVBJIGtleSBmb3JtYXQgZm9yICR7dGhpcy5jb25maWcucHJvdmlkZXJ9YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy5tYXhSZXRyaWVzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jb25maWcubWF4UmV0cmllcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ01heCByZXRyaWVzIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy5yZXRyeURlbGF5ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jb25maWcucmV0cnlEZWxheSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ1JldHJ5IGRlbGF5IG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy50aW1lb3V0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jb25maWcudGltZW91dCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdUaW1lb3V0IG11c3QgYmUgcG9zaXRpdmUnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNhbGxPcGVuQUkocmVxdWVzdDogTExNQ29tcGxldGlvblJlcXVlc3QpOiBQcm9taXNlPExMTUNvbXBsZXRpb25SZXNwb25zZT4ge1xuICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsIHx8ICdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxJztcbiAgICBjb25zdCB1cmwgPSBgJHtiYXNlVXJsfS9jaGF0L2NvbXBsZXRpb25zYDtcblxuICAgIGNvbnN0IHJlcXVlc3RCb2R5OiBhbnkgPSB7XG4gICAgICBtb2RlbDogcmVxdWVzdC5tb2RlbCB8fCB0aGlzLmNvbmZpZy5tb2RlbCxcbiAgICAgIG1lc3NhZ2VzOiByZXF1ZXN0Lm1lc3NhZ2VzLFxuICAgICAgbWF4X3Rva2VuczogcmVxdWVzdC5tYXhUb2tlbnMgfHwgMTAwMCxcbiAgICAgIHRlbXBlcmF0dXJlOiByZXF1ZXN0LnRlbXBlcmF0dXJlID8/IDAuNyxcbiAgICB9O1xuXG4gICAgLy8gQWRkIHRvb2wgc3VwcG9ydCBpZiB0b29scyBhcmUgcHJvdmlkZWRcbiAgICBpZiAocmVxdWVzdC50b29scyAmJiByZXF1ZXN0LnRvb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlcXVlc3RCb2R5LnRvb2xzID0gcmVxdWVzdC50b29scztcbiAgICAgIGlmIChyZXF1ZXN0LnRvb2xDaG9pY2UpIHtcbiAgICAgICAgcmVxdWVzdEJvZHkudG9vbF9jaG9pY2UgPSByZXF1ZXN0LnRvb2xDaG9pY2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmNvbmZpZy5hcGlLZXl9YCxcbiAgICAgICAgJ1VzZXItQWdlbnQnOiAnTUNQLUNoYXQtVUkvMS4wJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBsZXQgZXJyb3JEYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JEYXRhID0gSlNPTi5wYXJzZShlcnJvclRleHQpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIGVycm9yRGF0YSA9IHsgZXJyb3I6IHsgbWVzc2FnZTogZXJyb3JUZXh0IH0gfTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYE9wZW5BSSBBUEkgZXJyb3I6ICR7ZXJyb3JEYXRhLmVycm9yPy5tZXNzYWdlIHx8IGVycm9yVGV4dH1gKSBhcyBMTE1FcnJvcjtcbiAgICAgIGVycm9yLnN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICBlcnJvci5jb2RlID0gZXJyb3JEYXRhLmVycm9yPy5jb2RlO1xuICAgICAgZXJyb3IucmV0cnlhYmxlID0gWzQwOCwgNDI5LCA1MDAsIDUwMiwgNTAzLCA1MDRdLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnN0IGNob2ljZSA9IGRhdGEuY2hvaWNlc1swXTtcbiAgICBcbiAgICBpZiAoIWNob2ljZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXNwb25zZSBjaG9pY2VzIHJldHVybmVkIGZyb20gT3BlbkFJIEFQSScpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50OiBjaG9pY2UubWVzc2FnZT8uY29udGVudCB8fCAnJyxcbiAgICAgIHRvb2xDYWxsczogY2hvaWNlLm1lc3NhZ2U/LnRvb2xfY2FsbHM/Lm1hcCgodGM6IGFueSkgPT4gKHtcbiAgICAgICAgaWQ6IHRjLmlkLFxuICAgICAgICB0eXBlOiB0Yy50eXBlLFxuICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgIG5hbWU6IHRjLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgYXJndW1lbnRzOiB0Yy5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgIH0sXG4gICAgICB9KSksXG4gICAgICB1c2FnZTogZGF0YS51c2FnZSA/IHtcbiAgICAgICAgcHJvbXB0VG9rZW5zOiBkYXRhLnVzYWdlLnByb21wdF90b2tlbnMsXG4gICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IGRhdGEudXNhZ2UuY29tcGxldGlvbl90b2tlbnMsXG4gICAgICAgIHRvdGFsVG9rZW5zOiBkYXRhLnVzYWdlLnRvdGFsX3Rva2VucyxcbiAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICBmaW5pc2hSZWFzb246IGNob2ljZS5maW5pc2hfcmVhc29uLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNhbGxEZWVwU2VlayhyZXF1ZXN0OiBMTE1Db21wbGV0aW9uUmVxdWVzdCk6IFByb21pc2U8TExNQ29tcGxldGlvblJlc3BvbnNlPiB7XG4gICAgY29uc3QgYmFzZVVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgfHwgJ2h0dHBzOi8vYXBpLmRlZXBzZWVrLmNvbS92MSc7XG4gICAgY29uc3QgdXJsID0gYCR7YmFzZVVybH0vY2hhdC9jb21wbGV0aW9uc2A7XG5cbiAgICBjb25zdCByZXF1ZXN0Qm9keTogYW55ID0ge1xuICAgICAgbW9kZWw6IHJlcXVlc3QubW9kZWwgfHwgdGhpcy5jb25maWcubW9kZWwsXG4gICAgICBtZXNzYWdlczogcmVxdWVzdC5tZXNzYWdlcyxcbiAgICAgIG1heF90b2tlbnM6IHJlcXVlc3QubWF4VG9rZW5zIHx8IDEwMDAsXG4gICAgICB0ZW1wZXJhdHVyZTogcmVxdWVzdC50ZW1wZXJhdHVyZSA/PyAwLjcsXG4gICAgfTtcblxuICAgIC8vIEFkZCB0b29sIHN1cHBvcnQgaWYgdG9vbHMgYXJlIHByb3ZpZGVkXG4gICAgaWYgKHJlcXVlc3QudG9vbHMgJiYgcmVxdWVzdC50b29scy5sZW5ndGggPiAwKSB7XG4gICAgICByZXF1ZXN0Qm9keS50b29scyA9IHJlcXVlc3QudG9vbHM7XG4gICAgICBpZiAocmVxdWVzdC50b29sQ2hvaWNlKSB7XG4gICAgICAgIHJlcXVlc3RCb2R5LnRvb2xfY2hvaWNlID0gcmVxdWVzdC50b29sQ2hvaWNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dGhpcy5jb25maWcuYXBpS2V5fWAsXG4gICAgICAgICdVc2VyLUFnZW50JzogJ01DUC1DaGF0LVVJLzEuMCcsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgbGV0IGVycm9yRGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9yRGF0YSA9IEpTT04ucGFyc2UoZXJyb3JUZXh0KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICBlcnJvckRhdGEgPSB7IGVycm9yOiB7IG1lc3NhZ2U6IGVycm9yVGV4dCB9IH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBEZWVwU2VlayBBUEkgZXJyb3I6ICR7ZXJyb3JEYXRhLmVycm9yPy5tZXNzYWdlIHx8IGVycm9yVGV4dH1gKSBhcyBMTE1FcnJvcjtcbiAgICAgIGVycm9yLnN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICBlcnJvci5jb2RlID0gZXJyb3JEYXRhLmVycm9yPy5jb2RlO1xuICAgICAgZXJyb3IucmV0cnlhYmxlID0gWzQwOCwgNDI5LCA1MDAsIDUwMiwgNTAzLCA1MDRdLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnN0IGNob2ljZSA9IGRhdGEuY2hvaWNlc1swXTtcbiAgICBcbiAgICBpZiAoIWNob2ljZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXNwb25zZSBjaG9pY2VzIHJldHVybmVkIGZyb20gRGVlcFNlZWsgQVBJJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnQ6IGNob2ljZS5tZXNzYWdlPy5jb250ZW50IHx8ICcnLFxuICAgICAgdG9vbENhbGxzOiBjaG9pY2UubWVzc2FnZT8udG9vbF9jYWxscz8ubWFwKCh0YzogYW55KSA9PiAoe1xuICAgICAgICBpZDogdGMuaWQsXG4gICAgICAgIHR5cGU6IHRjLnR5cGUsXG4gICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgbmFtZTogdGMuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICBhcmd1bWVudHM6IHRjLmZ1bmN0aW9uLmFyZ3VtZW50cyxcbiAgICAgICAgfSxcbiAgICAgIH0pKSxcbiAgICAgIHVzYWdlOiBkYXRhLnVzYWdlID8ge1xuICAgICAgICBwcm9tcHRUb2tlbnM6IGRhdGEudXNhZ2UucHJvbXB0X3Rva2VucyxcbiAgICAgICAgY29tcGxldGlvblRva2VuczogZGF0YS51c2FnZS5jb21wbGV0aW9uX3Rva2VucyxcbiAgICAgICAgdG90YWxUb2tlbnM6IGRhdGEudXNhZ2UudG90YWxfdG9rZW5zLFxuICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgIGZpbmlzaFJlYXNvbjogY2hvaWNlLmZpbmlzaF9yZWFzb24sXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY2FsbE9wZW5Sb3V0ZXIocmVxdWVzdDogTExNQ29tcGxldGlvblJlcXVlc3QpOiBQcm9taXNlPExMTUNvbXBsZXRpb25SZXNwb25zZT4ge1xuICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsIHx8ICdodHRwczovL29wZW5yb3V0ZXIuYWkvYXBpL3YxJztcbiAgICBjb25zdCB1cmwgPSBgJHtiYXNlVXJsfS9jaGF0L2NvbXBsZXRpb25zYDtcblxuICAgIGNvbnN0IHJlcXVlc3RCb2R5OiBhbnkgPSB7XG4gICAgICBtb2RlbDogcmVxdWVzdC5tb2RlbCB8fCB0aGlzLmNvbmZpZy5tb2RlbCxcbiAgICAgIG1lc3NhZ2VzOiByZXF1ZXN0Lm1lc3NhZ2VzLFxuICAgICAgbWF4X3Rva2VuczogcmVxdWVzdC5tYXhUb2tlbnMgfHwgMTAwMCxcbiAgICAgIHRlbXBlcmF0dXJlOiByZXF1ZXN0LnRlbXBlcmF0dXJlID8/IDAuNyxcbiAgICB9O1xuXG4gICAgLy8gQWRkIHRvb2wgc3VwcG9ydCBpZiB0b29scyBhcmUgcHJvdmlkZWRcbiAgICBpZiAocmVxdWVzdC50b29scyAmJiByZXF1ZXN0LnRvb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlcXVlc3RCb2R5LnRvb2xzID0gcmVxdWVzdC50b29scztcbiAgICAgIGlmIChyZXF1ZXN0LnRvb2xDaG9pY2UpIHtcbiAgICAgICAgcmVxdWVzdEJvZHkudG9vbF9jaG9pY2UgPSByZXF1ZXN0LnRvb2xDaG9pY2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmNvbmZpZy5hcGlLZXl9YCxcbiAgICAgICAgJ0hUVFAtUmVmZXJlcic6ICdodHRwOi8vbG9jYWxob3N0OjMwMDAnLCAvLyBSZXF1aXJlZCBieSBPcGVuUm91dGVyXG4gICAgICAgICdYLVRpdGxlJzogJ01DUCBDaGF0IFVJJywgLy8gT3B0aW9uYWwgYnV0IHJlY29tbWVuZGVkXG4gICAgICAgICdVc2VyLUFnZW50JzogJ01DUC1DaGF0LVVJLzEuMCcsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgbGV0IGVycm9yRGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9yRGF0YSA9IEpTT04ucGFyc2UoZXJyb3JUZXh0KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICBlcnJvckRhdGEgPSB7IGVycm9yOiB7IG1lc3NhZ2U6IGVycm9yVGV4dCB9IH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBPcGVuUm91dGVyIEFQSSBlcnJvcjogJHtlcnJvckRhdGEuZXJyb3I/Lm1lc3NhZ2UgfHwgZXJyb3JUZXh0fWApIGFzIExMTUVycm9yO1xuICAgICAgZXJyb3Iuc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICAgIGVycm9yLmNvZGUgPSBlcnJvckRhdGEuZXJyb3I/LmNvZGU7XG4gICAgICBlcnJvci5yZXRyeWFibGUgPSBbNDA4LCA0MjksIDUwMCwgNTAyLCA1MDMsIDUwNF0uaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc3QgY2hvaWNlID0gZGF0YS5jaG9pY2VzWzBdO1xuICAgIFxuICAgIGlmICghY2hvaWNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlc3BvbnNlIGNob2ljZXMgcmV0dXJuZWQgZnJvbSBPcGVuUm91dGVyIEFQSScpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50OiBjaG9pY2UubWVzc2FnZT8uY29udGVudCB8fCAnJyxcbiAgICAgIHRvb2xDYWxsczogY2hvaWNlLm1lc3NhZ2U/LnRvb2xfY2FsbHM/Lm1hcCgodGM6IGFueSkgPT4gKHtcbiAgICAgICAgaWQ6IHRjLmlkLFxuICAgICAgICB0eXBlOiB0Yy50eXBlLFxuICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgIG5hbWU6IHRjLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgYXJndW1lbnRzOiB0Yy5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgIH0sXG4gICAgICB9KSksXG4gICAgICB1c2FnZTogZGF0YS51c2FnZSA/IHtcbiAgICAgICAgcHJvbXB0VG9rZW5zOiBkYXRhLnVzYWdlLnByb21wdF90b2tlbnMsXG4gICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IGRhdGEudXNhZ2UuY29tcGxldGlvbl90b2tlbnMsXG4gICAgICAgIHRvdGFsVG9rZW5zOiBkYXRhLnVzYWdlLnRvdGFsX3Rva2VucyxcbiAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICBmaW5pc2hSZWFzb246IGNob2ljZS5maW5pc2hfcmVhc29uLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBMTE0gc2VydmljZSBpbnN0YW5jZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxMTVNlcnZpY2UoY29uZmlnOiBMTE1TZXJ2aWNlQ29uZmlnKTogTExNU2VydmljZSB7XG4gIHJldHVybiBuZXcgTExNU2VydmljZShjb25maWcpO1xufVxuXG4vKipcbiAqIEdldCBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gZm9yIGEgcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRQcm92aWRlckNvbmZpZyhwcm92aWRlcjogTExNUHJvdmlkZXIpOiBQYXJ0aWFsPExMTVNlcnZpY2VDb25maWc+IHtcbiAgc3dpdGNoIChwcm92aWRlcikge1xuICAgIGNhc2UgJ29wZW5haSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlVXJsOiAnaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MScsXG4gICAgICAgIG1vZGVsOiAnZ3B0LTQnLFxuICAgICAgICBtYXhSZXRyaWVzOiAzLFxuICAgICAgICByZXRyeURlbGF5OiAxMDAwLFxuICAgICAgICB0aW1lb3V0OiAzMDAwMCxcbiAgICAgIH07XG4gICAgY2FzZSAnZGVlcHNlZWsnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZVVybDogJ2h0dHBzOi8vYXBpLmRlZXBzZWVrLmNvbS92MScsXG4gICAgICAgIG1vZGVsOiAnZGVlcHNlZWstY2hhdCcsXG4gICAgICAgIG1heFJldHJpZXM6IDMsXG4gICAgICAgIHJldHJ5RGVsYXk6IDEwMDAsXG4gICAgICAgIHRpbWVvdXQ6IDMwMDAwLFxuICAgICAgfTtcbiAgICBjYXNlICdvcGVucm91dGVyJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VVcmw6ICdodHRwczovL29wZW5yb3V0ZXIuYWkvYXBpL3YxJyxcbiAgICAgICAgbW9kZWw6ICdvcGVuYWkvZ3B0LTQnLFxuICAgICAgICBtYXhSZXRyaWVzOiAzLFxuICAgICAgICByZXRyeURlbGF5OiAxMDAwLFxuICAgICAgICB0aW1lb3V0OiA0NTAwMCwgLy8gT3BlblJvdXRlciBtYXkgYmUgc2xvd2VyXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBVbnN1cHBvcnRlZCBwcm92aWRlcjogJHtwcm92aWRlcn1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIHByb3ZpZGVyIGNvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUHJvdmlkZXJDb25maWcoY29uZmlnOiBQYXJ0aWFsPExMTVNlcnZpY2VDb25maWc+KTogc3RyaW5nW10ge1xuICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG5cbiAgaWYgKCFjb25maWcucHJvdmlkZXIpIHtcbiAgICBlcnJvcnMucHVzaCgnUHJvdmlkZXIgaXMgcmVxdWlyZWQnKTtcbiAgfSBlbHNlIGlmICghWydvcGVuYWknLCAnZGVlcHNlZWsnLCAnb3BlbnJvdXRlciddLmluY2x1ZGVzKGNvbmZpZy5wcm92aWRlcikpIHtcbiAgICBlcnJvcnMucHVzaCgnSW52YWxpZCBwcm92aWRlcicpO1xuICB9XG5cbiAgaWYgKCFjb25maWcuYXBpS2V5KSB7XG4gICAgZXJyb3JzLnB1c2goJ0FQSSBrZXkgaXMgcmVxdWlyZWQnKTtcbiAgfSBlbHNlIGlmIChjb25maWcucHJvdmlkZXIpIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gbmV3IExMTVNlcnZpY2UoeyAuLi5jb25maWcsIG1vZGVsOiAndGVzdCcgfSBhcyBMTE1TZXJ2aWNlQ29uZmlnKTtcbiAgICBpZiAoIXNlcnZpY2UudmFsaWRhdGVBcGlLZXkoY29uZmlnLmFwaUtleSkpIHtcbiAgICAgIGVycm9ycy5wdXNoKGBJbnZhbGlkIEFQSSBrZXkgZm9ybWF0IGZvciAke2NvbmZpZy5wcm92aWRlcn1gKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmZpZy5tb2RlbCkge1xuICAgIGVycm9ycy5wdXNoKCdNb2RlbCBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgaWYgKGNvbmZpZy5tYXhSZXRyaWVzICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLm1heFJldHJpZXMgPCAwKSB7XG4gICAgZXJyb3JzLnB1c2goJ01heCByZXRyaWVzIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gIH1cblxuICBpZiAoY29uZmlnLnJldHJ5RGVsYXkgIT09IHVuZGVmaW5lZCAmJiBjb25maWcucmV0cnlEZWxheSA8IDApIHtcbiAgICBlcnJvcnMucHVzaCgnUmV0cnkgZGVsYXkgbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgfVxuXG4gIGlmIChjb25maWcudGltZW91dCAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZy50aW1lb3V0IDw9IDApIHtcbiAgICBlcnJvcnMucHVzaCgnVGltZW91dCBtdXN0IGJlIHBvc2l0aXZlJyk7XG4gIH1cblxuICByZXR1cm4gZXJyb3JzO1xufVxuXG4vKipcbiAqIEdldCBhdmFpbGFibGUgbW9kZWxzIGZvciBhIHByb3ZpZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm92aWRlck1vZGVscyhwcm92aWRlcjogTExNUHJvdmlkZXIpOiBBcnJheTx7IGlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZzsgc3VwcG9ydHNUb29sQ2FsbGluZzogYm9vbGVhbiB9PiB7XG4gIHN3aXRjaCAocHJvdmlkZXIpIHtcbiAgICBjYXNlICdvcGVuYWknOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgeyBpZDogJ2dwdC00JywgbmFtZTogJ0dQVC00Jywgc3VwcG9ydHNUb29sQ2FsbGluZzogdHJ1ZSB9LFxuICAgICAgICB7IGlkOiAnZ3B0LTQtdHVyYm8nLCBuYW1lOiAnR1BULTQgVHVyYm8nLCBzdXBwb3J0c1Rvb2xDYWxsaW5nOiB0cnVlIH0sXG4gICAgICAgIHsgaWQ6ICdncHQtMy41LXR1cmJvJywgbmFtZTogJ0dQVC0zLjUgVHVyYm8nLCBzdXBwb3J0c1Rvb2xDYWxsaW5nOiB0cnVlIH0sXG4gICAgICBdO1xuICAgIGNhc2UgJ2RlZXBzZWVrJzpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHsgaWQ6ICdkZWVwc2Vlay1jaGF0JywgbmFtZTogJ0RlZXBTZWVrIENoYXQnLCBzdXBwb3J0c1Rvb2xDYWxsaW5nOiB0cnVlIH0sXG4gICAgICAgIHsgaWQ6ICdkZWVwc2Vlay1jb2RlcicsIG5hbWU6ICdEZWVwU2VlayBDb2RlcicsIHN1cHBvcnRzVG9vbENhbGxpbmc6IHRydWUgfSxcbiAgICAgIF07XG4gICAgY2FzZSAnb3BlbnJvdXRlcic6XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7IGlkOiAnb3BlbmFpL2dwdC00JywgbmFtZTogJ0dQVC00ICh2aWEgT3BlblJvdXRlciknLCBzdXBwb3J0c1Rvb2xDYWxsaW5nOiB0cnVlIH0sXG4gICAgICAgIHsgaWQ6ICdhbnRocm9waWMvY2xhdWRlLTMtb3B1cycsIG5hbWU6ICdDbGF1ZGUgMyBPcHVzJywgc3VwcG9ydHNUb29sQ2FsbGluZzogdHJ1ZSB9LFxuICAgICAgICB7IGlkOiAnbWV0YS1sbGFtYS9sbGFtYS0yLTcwYi1jaGF0JywgbmFtZTogJ0xsYW1hIDIgNzBCJywgc3VwcG9ydHNUb29sQ2FsbGluZzogZmFsc2UgfSxcbiAgICAgIF07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXTtcbiAgfVxufVxuLyoqXG4gKlxuIFRlc3QgTExNIHByb3ZpZGVyIGNvbm5lY3Rpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRlc3RMTE1Qcm92aWRlckNvbm5lY3Rpb24ocHJvdmlkZXI6IHtcbiAgbmFtZTogc3RyaW5nO1xuICBhcGlLZXk6IHN0cmluZztcbiAgYmFzZVVybD86IHN0cmluZztcbiAgbW9kZWxzOiBBcnJheTx7IGlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZzsgc3VwcG9ydHNUb29sQ2FsbGluZzogYm9vbGVhbjsgbWF4VG9rZW5zOiBudW1iZXIgfT47XG59KTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgaWYgKCFwcm92aWRlci5hcGlLZXkpIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdBUEkga2V5IGlzIHJlcXVpcmVkJyB9O1xuICB9XG5cbiAgY29uc3QgYmFzZVVybCA9IHByb3ZpZGVyLmJhc2VVcmwgfHwgZ2V0RGVmYXVsdFByb3ZpZGVyQ29uZmlnKHByb3ZpZGVyLm5hbWUgYXMgTExNUHJvdmlkZXIpLmJhc2VVcmw7XG4gIFxuICB0cnkge1xuICAgIC8vIENyZWF0ZSBhIG1pbmltYWwgdGVzdCByZXF1ZXN0XG4gICAgY29uc3QgdGVzdFBheWxvYWQgPSB7XG4gICAgICBtb2RlbDogcHJvdmlkZXIubW9kZWxzWzBdPy5pZCB8fCBnZXREZWZhdWx0TW9kZWxGb3JQcm92aWRlcihwcm92aWRlci5uYW1lIGFzIExMTVByb3ZpZGVyKSxcbiAgICAgIG1lc3NhZ2VzOiBbeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6ICdIZWxsbycgfV0sXG4gICAgICBtYXhfdG9rZW5zOiA1LFxuICAgICAgdGVtcGVyYXR1cmU6IDAsXG4gICAgfTtcblxuICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgIH07XG5cbiAgICAvLyBTZXQgYXV0aG9yaXphdGlvbiBoZWFkZXIgYmFzZWQgb24gcHJvdmlkZXJcbiAgICBpZiAocHJvdmlkZXIubmFtZSA9PT0gJ29wZW5haScgfHwgcHJvdmlkZXIubmFtZSA9PT0gJ2RlZXBzZWVrJykge1xuICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3Byb3ZpZGVyLmFwaUtleX1gO1xuICAgIH0gZWxzZSBpZiAocHJvdmlkZXIubmFtZSA9PT0gJ29wZW5yb3V0ZXInKSB7XG4gICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7cHJvdmlkZXIuYXBpS2V5fWA7XG4gICAgICBoZWFkZXJzWydIVFRQLVJlZmVyZXInXSA9ICdodHRwczovL21jcC1jaGF0LXVpLmxvY2FsJztcbiAgICAgIGhlYWRlcnNbJ1gtVGl0bGUnXSA9ICdNQ1AgQ2hhdCBVSSc7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYXNlVXJsfS9jaGF0L2NvbXBsZXRpb25zYCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodGVzdFBheWxvYWQpLFxuICAgIH0pO1xuXG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yRGF0YS5lcnJvcj8ubWVzc2FnZSB8fCBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvck1lc3NhZ2UgfTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnTmV0d29yayBlcnJvciBvY2N1cnJlZCc7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvck1lc3NhZ2UgfTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgZGVmYXVsdCBtb2RlbCBmb3IgcHJvdmlkZXJcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdE1vZGVsRm9yUHJvdmlkZXIocHJvdmlkZXI6IExMTVByb3ZpZGVyKTogc3RyaW5nIHtcbiAgY29uc3QgZGVmYXVsdE1vZGVsczogUmVjb3JkPExMTVByb3ZpZGVyLCBzdHJpbmc+ID0ge1xuICAgIG9wZW5haTogJ2dwdC0zLjUtdHVyYm8nLFxuICAgIGRlZXBzZWVrOiAnZGVlcHNlZWstY2hhdCcsXG4gICAgb3BlbnJvdXRlcjogJ29wZW5haS9ncHQtMy41LXR1cmJvJyxcbiAgfTtcbiAgcmV0dXJuIGRlZmF1bHRNb2RlbHNbcHJvdmlkZXJdIHx8ICdncHQtMy41LXR1cmJvJztcbn0iXSwibmFtZXMiOlsiSW50ZXJuYWxTZXJ2ZXJFcnJvciIsIlZhbGlkYXRpb25FcnJvciIsIkxMTVNlcnZpY2UiLCJERUZBVUxUX01BWF9SRVRSSUVTIiwiREVGQVVMVF9SRVRSWV9ERUxBWSIsIkRFRkFVTFRfVElNRU9VVCIsImNvbmZpZyIsIm1heFJldHJpZXMiLCJyZXRyeURlbGF5IiwidGltZW91dCIsInZhbGlkYXRlQ29uZmlnIiwiZ2VuZXJhdGVDb21wbGV0aW9uIiwicmVxdWVzdCIsImV4ZWN1dGVXaXRoUmV0cnkiLCJwcm92aWRlciIsImNhbGxPcGVuQUkiLCJjYWxsRGVlcFNlZWsiLCJjYWxsT3BlblJvdXRlciIsInRlc3RDb25uZWN0aW9uIiwicmVzcG9uc2UiLCJtZXNzYWdlcyIsInJvbGUiLCJjb250ZW50IiwibWF4VG9rZW5zIiwidGVtcGVyYXR1cmUiLCJzdWNjZXNzIiwiZXJyb3IiLCJjb25zb2xlIiwiZXJyb3JNZXNzYWdlIiwiRXJyb3IiLCJtZXNzYWdlIiwiZ2V0UHJvdmlkZXJDYXBhYmlsaXRpZXMiLCJzdXBwb3J0c1Rvb2xDYWxsaW5nIiwic3VwcG9ydHNTdHJlYW1pbmciLCJzdXBwb3J0ZWRNb2RlbHMiLCJ2YWxpZGF0ZUFwaUtleSIsImFwaUtleSIsInN0YXJ0c1dpdGgiLCJsZW5ndGgiLCJmbiIsImxhc3RFcnJvciIsImF0dGVtcHQiLCJ3aXRoVGltZW91dCIsImlzUmV0cnlhYmxlRXJyb3IiLCJkZWxheSIsIk1hdGgiLCJwb3ciLCJzbGVlcCIsIndhcm4iLCJsbG1FcnJvciIsInJldHJ5YWJsZSIsInVuZGVmaW5lZCIsImluY2x1ZGVzIiwic3RhdHVzQ29kZSIsInRvTG93ZXJDYXNlIiwicHJvbWlzZSIsInRpbWVvdXRNcyIsIlByb21pc2UiLCJyYWNlIiwiXyIsInJlamVjdCIsInNldFRpbWVvdXQiLCJtcyIsInJlc29sdmUiLCJtb2RlbCIsImJhc2VVcmwiLCJ1cmwiLCJyZXF1ZXN0Qm9keSIsIm1heF90b2tlbnMiLCJ0b29scyIsInRvb2xDaG9pY2UiLCJ0b29sX2Nob2ljZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJlcnJvclRleHQiLCJ0ZXh0IiwiZXJyb3JEYXRhIiwicGFyc2UiLCJzdGF0dXMiLCJjb2RlIiwiZGF0YSIsImpzb24iLCJjaG9pY2UiLCJjaG9pY2VzIiwidG9vbENhbGxzIiwidG9vbF9jYWxscyIsIm1hcCIsInRjIiwiaWQiLCJ0eXBlIiwiZnVuY3Rpb24iLCJuYW1lIiwiYXJndW1lbnRzIiwidXNhZ2UiLCJwcm9tcHRUb2tlbnMiLCJwcm9tcHRfdG9rZW5zIiwiY29tcGxldGlvblRva2VucyIsImNvbXBsZXRpb25fdG9rZW5zIiwidG90YWxUb2tlbnMiLCJ0b3RhbF90b2tlbnMiLCJmaW5pc2hSZWFzb24iLCJmaW5pc2hfcmVhc29uIiwiY3JlYXRlTExNU2VydmljZSIsImdldERlZmF1bHRQcm92aWRlckNvbmZpZyIsInZhbGlkYXRlUHJvdmlkZXJDb25maWciLCJlcnJvcnMiLCJwdXNoIiwic2VydmljZSIsImdldFByb3ZpZGVyTW9kZWxzIiwidGVzdExMTVByb3ZpZGVyQ29ubmVjdGlvbiIsInRlc3RQYXlsb2FkIiwibW9kZWxzIiwiZ2V0RGVmYXVsdE1vZGVsRm9yUHJvdmlkZXIiLCJjYXRjaCIsInN0YXR1c1RleHQiLCJkZWZhdWx0TW9kZWxzIiwib3BlbmFpIiwiZGVlcHNlZWsiLCJvcGVucm91dGVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/services/LLMService.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/SessionManager.ts":
/*!****************************************!*\
  !*** ./src/services/SessionManager.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SessionManager: () => (/* binding */ SessionManager),\n/* harmony export */   getSessionManager: () => (/* binding */ getSessionManager),\n/* harmony export */   initializeSessionManager: () => (/* binding */ initializeSessionManager)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/errors */ \"(rsc)/./src/lib/errors.ts\");\n/* harmony import */ var _lib_encryption__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/encryption */ \"(rsc)/./src/lib/encryption.ts\");\n\n\n\n\nclass SessionManager {\n    constructor(storageDir = './data/sessions', maxSessions = 1000, cleanupIntervalMs = 24 * 60 * 60 * 1000 // 24 hours\n    ){\n        this.encryptionService = (0,_lib_encryption__WEBPACK_IMPORTED_MODULE_3__.getEncryptionService)();\n        this.storageDir = storageDir;\n        this.storageFile = path__WEBPACK_IMPORTED_MODULE_1___default().join(storageDir, 'sessions.json');\n        this.maxSessions = maxSessions;\n        this.cleanupIntervalMs = cleanupIntervalMs;\n        this.storage = {\n            sessions: {},\n            metadata: {\n                lastCleanup: new Date().toISOString(),\n                totalSessions: 0,\n                version: '1.0.0',\n                encrypted: false\n            }\n        };\n    }\n    /**\n   * Initialize the session manager and load existing sessions\n   */ async initialize() {\n        try {\n            await this.ensureStorageDirectory();\n            await this.loadSessions();\n            this.startCleanupTimer();\n        } catch (error) {\n            console.error('Failed to initialize SessionManager:', error);\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.InternalServerError('Failed to initialize session storage');\n        }\n    }\n    /**\n   * Create a new chat session\n   */ async createSession(provider, model, mcpServers = [], initialMessage) {\n        const sessionId = this.generateSessionId();\n        const now = new Date();\n        const session = {\n            id: sessionId,\n            title: 'New Chat',\n            messages: initialMessage ? [\n                initialMessage\n            ] : [],\n            createdAt: now,\n            updatedAt: now,\n            provider,\n            model,\n            mcpServers\n        };\n        this.storage.sessions[sessionId] = session;\n        this.storage.metadata.totalSessions = Object.keys(this.storage.sessions).length;\n        await this.saveSessions();\n        return session;\n    }\n    /**\n   * Get a session by ID\n   */ async getSession(sessionId) {\n        const session = this.storage.sessions[sessionId];\n        if (!session) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.NotFoundError(`Session with ID ${sessionId} not found`);\n        }\n        return {\n            ...session\n        }; // Return a copy to prevent mutations\n    }\n    /**\n   * Update an existing session\n   */ async updateSession(sessionId, updates) {\n        const session = this.storage.sessions[sessionId];\n        if (!session) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.NotFoundError(`Session with ID ${sessionId} not found`);\n        }\n        // Prevent updating immutable fields\n        const { id, createdAt, ...allowedUpdates } = updates;\n        const updatedSession = {\n            ...session,\n            ...allowedUpdates,\n            updatedAt: new Date()\n        };\n        this.storage.sessions[sessionId] = updatedSession;\n        await this.saveSessions();\n        return {\n            ...updatedSession\n        };\n    }\n    /**\n   * Add a message to a session\n   */ async addMessage(sessionId, message) {\n        const session = this.storage.sessions[sessionId];\n        if (!session) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.NotFoundError(`Session with ID ${sessionId} not found`);\n        }\n        session.messages.push(message);\n        session.updatedAt = new Date();\n        this.storage.sessions[sessionId] = session;\n        await this.saveSessions();\n        return {\n            ...session\n        };\n    }\n    /**\n   * Delete a session\n   */ async deleteSession(sessionId) {\n        if (!this.storage.sessions[sessionId]) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.NotFoundError(`Session with ID ${sessionId} not found`);\n        }\n        delete this.storage.sessions[sessionId];\n        this.storage.metadata.totalSessions = Object.keys(this.storage.sessions).length;\n        await this.saveSessions();\n    }\n    /**\n   * Search and filter sessions\n   */ async searchSessions(options = {}) {\n        const { query, provider, limit = 50, offset = 0, sortBy = 'updatedAt', sortOrder = 'desc' } = options;\n        let sessions = Object.values(this.storage.sessions);\n        // Apply filters\n        if (query) {\n            const searchQuery = query.toLowerCase();\n            sessions = sessions.filter((session)=>session.title.toLowerCase().includes(searchQuery) || session.messages.some((msg)=>msg.content.toLowerCase().includes(searchQuery)));\n        }\n        if (provider) {\n            sessions = sessions.filter((session)=>session.provider === provider);\n        }\n        // Sort sessions\n        sessions.sort((a, b)=>{\n            const aValue = a[sortBy];\n            const bValue = b[sortBy];\n            let comparison = 0;\n            if (aValue instanceof Date && bValue instanceof Date) {\n                comparison = aValue.getTime() - bValue.getTime();\n            } else {\n                comparison = String(aValue).localeCompare(String(bValue));\n            }\n            return sortOrder === 'desc' ? -comparison : comparison;\n        });\n        const total = sessions.length;\n        const paginatedSessions = sessions.slice(offset, offset + limit);\n        // Convert to summary format\n        const sessionSummaries = paginatedSessions.map((session)=>({\n                id: session.id,\n                title: session.title,\n                createdAt: session.createdAt.toISOString(),\n                updatedAt: session.updatedAt.toISOString(),\n                messageCount: session.messages.length,\n                provider: session.provider,\n                model: session.model\n            }));\n        return {\n            sessions: sessionSummaries,\n            total,\n            hasMore: offset + limit < total\n        };\n    }\n    /**\n   * Generate automatic session title using LLM\n   */ async generateSessionTitle(sessionId, llmService) {\n        const session = this.storage.sessions[sessionId];\n        if (!session) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.NotFoundError(`Session with ID ${sessionId} not found`);\n        }\n        // If no LLM service provided or no messages, use fallback\n        if (!llmService || session.messages.length === 0) {\n            return this.generateFallbackTitle(session);\n        }\n        try {\n            // Get first few messages for context\n            const contextMessages = session.messages.filter((msg)=>msg.role === 'user' || msg.role === 'assistant').slice(0, 4).map((msg)=>`${msg.role}: ${msg.content.substring(0, 200)}`).join('\\n');\n            const titlePrompt = `Based on this conversation, generate a concise, descriptive title (max 50 characters):\n\n${contextMessages}\n\nTitle:`;\n            const response = await llmService.generateCompletion({\n                messages: [\n                    {\n                        role: 'user',\n                        content: titlePrompt\n                    }\n                ],\n                maxTokens: 20,\n                temperature: 0.3\n            });\n            const generatedTitle = response.content?.trim().replace(/^[\"']|[\"']$/g, '') // Remove quotes\n            .substring(0, 50) // Ensure max length\n             || this.generateFallbackTitle(session);\n            // Update session with new title\n            await this.updateSession(sessionId, {\n                title: generatedTitle\n            });\n            return generatedTitle;\n        } catch (error) {\n            console.error('Failed to generate session title:', error);\n            return this.generateFallbackTitle(session);\n        }\n    }\n    /**\n   * Clean up old sessions based on age and count limits\n   */ async cleanupSessions() {\n        const sessions = Object.values(this.storage.sessions);\n        const now = new Date();\n        const maxAge = 30 * 24 * 60 * 60 * 1000; // 30 days\n        let deletedCount = 0;\n        // Delete sessions older than maxAge\n        const oldSessions = sessions.filter((session)=>now.getTime() - session.updatedAt.getTime() > maxAge);\n        for (const session of oldSessions){\n            delete this.storage.sessions[session.id];\n            deletedCount++;\n        }\n        // If still over limit, delete oldest sessions\n        const remainingSessions = Object.values(this.storage.sessions);\n        if (remainingSessions.length > this.maxSessions) {\n            const sortedSessions = remainingSessions.sort((a, b)=>a.updatedAt.getTime() - b.updatedAt.getTime());\n            const sessionsToDelete = sortedSessions.slice(0, remainingSessions.length - this.maxSessions);\n            for (const session of sessionsToDelete){\n                delete this.storage.sessions[session.id];\n                deletedCount++;\n            }\n        }\n        this.storage.metadata.lastCleanup = now.toISOString();\n        this.storage.metadata.totalSessions = Object.keys(this.storage.sessions).length;\n        if (deletedCount > 0) {\n            await this.saveSessions();\n        }\n        return {\n            deletedCount\n        };\n    }\n    /**\n   * Get session statistics\n   */ getStatistics() {\n        const sessions = Object.values(this.storage.sessions);\n        const providerBreakdown = {\n            openai: 0,\n            deepseek: 0,\n            openrouter: 0\n        };\n        let totalMessages = 0;\n        sessions.forEach((session)=>{\n            providerBreakdown[session.provider]++;\n            totalMessages += session.messages.length;\n        });\n        return {\n            totalSessions: sessions.length,\n            lastCleanup: this.storage.metadata.lastCleanup,\n            providerBreakdown,\n            averageMessagesPerSession: sessions.length > 0 ? totalMessages / sessions.length : 0\n        };\n    }\n    /**\n   * Export chat history for backup\n   */ async exportChatHistory(options = {}) {\n        const { sessionIds, dateFrom, dateTo, includeSystemMessages = false } = options;\n        let sessions = Object.values(this.storage.sessions);\n        // Filter by session IDs if specified\n        if (sessionIds && sessionIds.length > 0) {\n            sessions = sessions.filter((session)=>sessionIds.includes(session.id));\n        }\n        // Filter by date range\n        if (dateFrom) {\n            sessions = sessions.filter((session)=>session.createdAt >= dateFrom);\n        }\n        if (dateTo) {\n            sessions = sessions.filter((session)=>session.createdAt <= dateTo);\n        }\n        // Filter messages if needed\n        const exportSessions = sessions.map((session)=>({\n                ...session,\n                messages: includeSystemMessages ? session.messages : session.messages.filter((msg)=>msg.role !== 'system')\n            }));\n        // Calculate metadata\n        const dates = exportSessions.map((s)=>s.createdAt).sort();\n        const earliest = dates.length > 0 ? dates[0].toISOString() : new Date().toISOString();\n        const latest = dates.length > 0 ? dates[dates.length - 1].toISOString() : new Date().toISOString();\n        return {\n            version: '1.0.0',\n            exportDate: new Date().toISOString(),\n            sessions: exportSessions,\n            metadata: {\n                totalSessions: exportSessions.length,\n                dateRange: {\n                    earliest,\n                    latest\n                }\n            }\n        };\n    }\n    /**\n   * Import chat history from backup\n   */ async importChatHistory(exportData, options = {}) {\n        const { overwriteExisting = false, generateNewIds = false } = options;\n        let imported = 0;\n        let skipped = 0;\n        const errors = [];\n        try {\n            if (exportData.version !== '1.0.0') {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.ValidationError('Unsupported export version');\n            }\n            for (const session of exportData.sessions){\n                try {\n                    let sessionId = session.id;\n                    // Generate new ID if requested or if conflict exists\n                    if (generateNewIds || this.storage.sessions[sessionId] && !overwriteExisting) {\n                        sessionId = this.generateSessionId();\n                    }\n                    // Skip if session exists and not overwriting\n                    if (this.storage.sessions[sessionId] && !overwriteExisting) {\n                        skipped++;\n                        continue;\n                    }\n                    // Import session with new ID if needed\n                    const importedSession = {\n                        ...session,\n                        id: sessionId,\n                        // Ensure dates are Date objects\n                        createdAt: new Date(session.createdAt),\n                        updatedAt: new Date(session.updatedAt),\n                        messages: session.messages.map((msg)=>({\n                                ...msg,\n                                timestamp: new Date(msg.timestamp)\n                            }))\n                    };\n                    this.storage.sessions[sessionId] = importedSession;\n                    imported++;\n                } catch (error) {\n                    errors.push(`Failed to import session ${session.id}: ${error}`);\n                }\n            }\n            this.storage.metadata.totalSessions = Object.keys(this.storage.sessions).length;\n            await this.saveSessions();\n            return {\n                imported,\n                skipped,\n                errors\n            };\n        } catch (error) {\n            console.error('Failed to import chat history:', error);\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.InternalServerError('Failed to import chat history');\n        }\n    }\n    /**\n   * Secure cleanup - permanently delete sessions and clear sensitive data\n   */ async secureCleanup(options = {}) {\n        const { olderThanDays = 30, sessionIds, clearAllSensitiveData = false } = options;\n        let deletedSessions = 0;\n        const now = new Date();\n        const maxAge = olderThanDays * 24 * 60 * 60 * 1000;\n        // Delete specific sessions if provided\n        if (sessionIds && sessionIds.length > 0) {\n            for (const sessionId of sessionIds){\n                if (this.storage.sessions[sessionId]) {\n                    delete this.storage.sessions[sessionId];\n                    deletedSessions++;\n                }\n            }\n        } else {\n            // Delete old sessions\n            const sessions = Object.values(this.storage.sessions);\n            const oldSessions = sessions.filter((session)=>now.getTime() - session.updatedAt.getTime() > maxAge);\n            for (const session of oldSessions){\n                delete this.storage.sessions[session.id];\n                deletedSessions++;\n            }\n        }\n        // Clear sensitive data from remaining sessions if requested\n        let clearedData = false;\n        if (clearAllSensitiveData) {\n            Object.values(this.storage.sessions).forEach((session)=>{\n                session.messages = session.messages.map((message)=>({\n                        ...message,\n                        // Remove any potential sensitive content patterns\n                        content: this.sanitizeMessageContent(message.content)\n                    }));\n            });\n            clearedData = true;\n        }\n        this.storage.metadata.totalSessions = Object.keys(this.storage.sessions).length;\n        this.storage.metadata.lastCleanup = now.toISOString();\n        await this.saveSessions();\n        return {\n            deletedSessions,\n            clearedData\n        };\n    }\n    /**\n   * Get privacy and security statistics\n   */ getPrivacyStatistics() {\n        const sessions = Object.values(this.storage.sessions);\n        const now = new Date();\n        if (sessions.length === 0) {\n            return {\n                totalSessions: 0,\n                totalMessages: 0,\n                oldestSession: null,\n                newestSession: null,\n                averageSessionAge: 0,\n                sessionsWithSensitiveData: 0,\n                lastCleanup: this.storage.metadata.lastCleanup\n            };\n        }\n        const sortedByDate = sessions.sort((a, b)=>a.createdAt.getTime() - b.createdAt.getTime());\n        const totalMessages = sessions.reduce((sum, session)=>sum + session.messages.length, 0);\n        const totalAge = sessions.reduce((sum, session)=>sum + (now.getTime() - session.createdAt.getTime()), 0);\n        const averageSessionAge = totalAge / sessions.length / (24 * 60 * 60 * 1000); // in days\n        // Count sessions that might contain sensitive data (API keys, tokens, etc.)\n        const sensitivePatterns = [\n            /api[_-]?key/i,\n            /token/i,\n            /secret/i,\n            /password/i\n        ];\n        const sessionsWithSensitiveData = sessions.filter((session)=>session.messages.some((message)=>sensitivePatterns.some((pattern)=>pattern.test(message.content)))).length;\n        return {\n            totalSessions: sessions.length,\n            totalMessages,\n            oldestSession: sortedByDate[0].createdAt.toISOString(),\n            newestSession: sortedByDate[sortedByDate.length - 1].createdAt.toISOString(),\n            averageSessionAge,\n            sessionsWithSensitiveData,\n            lastCleanup: this.storage.metadata.lastCleanup\n        };\n    }\n    /**\n   * Shutdown the session manager\n   */ async shutdown() {\n        if (this.cleanupTimer) {\n            clearInterval(this.cleanupTimer);\n            this.cleanupTimer = undefined;\n        }\n        await this.saveSessions();\n    }\n    // Private methods\n    generateSessionId() {\n        return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    generateFallbackTitle(session) {\n        const userMessages = session.messages.filter((msg)=>msg.role === 'user');\n        if (userMessages.length > 0) {\n            const originalMessage = userMessages[0].content;\n            const truncatedMessage = originalMessage.substring(0, 40);\n            return originalMessage.length > 40 ? `${truncatedMessage}...` : truncatedMessage;\n        }\n        const date = session.createdAt.toLocaleDateString();\n        return `Chat from ${date}`;\n    }\n    async ensureStorageDirectory() {\n        try {\n            await fs__WEBPACK_IMPORTED_MODULE_0__.promises.mkdir(this.storageDir, {\n                recursive: true\n            });\n        } catch (error) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.InternalServerError(`Failed to create storage directory: ${error}`);\n        }\n    }\n    async loadSessions() {\n        try {\n            const data = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(this.storageFile, 'utf-8');\n            const parsed = JSON.parse(data);\n            // Convert date strings back to Date objects\n            Object.values(parsed.sessions).forEach((session)=>{\n                session.createdAt = new Date(session.createdAt);\n                session.updatedAt = new Date(session.updatedAt);\n                session.messages.forEach((message)=>{\n                    message.timestamp = new Date(message.timestamp);\n                });\n            });\n            this.storage = parsed;\n        } catch (error) {\n            if (error.code === 'ENOENT') {\n                // File doesn't exist, start with empty storage\n                this.storage = {\n                    sessions: {},\n                    metadata: {\n                        lastCleanup: new Date().toISOString(),\n                        totalSessions: 0,\n                        version: '1.0.0',\n                        encrypted: false\n                    }\n                };\n                await this.saveSessions();\n            } else {\n                console.error('Failed to load sessions:', error);\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.InternalServerError('Failed to load session data');\n            }\n        }\n    }\n    async saveSessions() {\n        try {\n            const data = JSON.stringify(this.storage, null, 2);\n            await fs__WEBPACK_IMPORTED_MODULE_0__.promises.writeFile(this.storageFile, data, 'utf-8');\n        } catch (error) {\n            console.error('Failed to save sessions:', error);\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.InternalServerError('Failed to save session data');\n        }\n    }\n    startCleanupTimer() {\n        this.cleanupTimer = setInterval(async ()=>{\n            try {\n                await this.cleanupSessions();\n            } catch (error) {\n                console.error('Automatic cleanup failed:', error);\n            }\n        }, this.cleanupIntervalMs);\n    }\n    sanitizeMessageContent(content) {\n        // Remove potential API keys, tokens, and other sensitive data\n        const sensitivePatterns = [\n            /sk-[a-zA-Z0-9]{20,}/g,\n            /sk-or-[a-zA-Z0-9]{30,}/g,\n            /Bearer\\s+[a-zA-Z0-9]{20,}/g,\n            /[a-zA-Z0-9]{32,}/g\n        ];\n        let sanitized = content;\n        sensitivePatterns.forEach((pattern)=>{\n            sanitized = sanitized.replace(pattern, '[REDACTED]');\n        });\n        return sanitized;\n    }\n}\n// Singleton instance\nlet sessionManagerInstance = null;\nfunction getSessionManager() {\n    if (!sessionManagerInstance) {\n        sessionManagerInstance = new SessionManager();\n    }\n    return sessionManagerInstance;\n}\nasync function initializeSessionManager() {\n    const manager = getSessionManager();\n    await manager.initialize();\n    return manager;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWlCO0lBQzNCO0lBRVFvSSx1QkFBdUJ4RSxPQUFlLEVBQVU7UUFDdEQsOERBQThEO1FBQzlELE1BQU1rRixvQkFBb0I7WUFDeEI7WUFDQTtZQUNBO1lBQ0E7U0FDRDtRQUVELElBQUkyQixZQUFZN0c7UUFDaEJrRixrQkFBa0J0QyxPQUFPLENBQUN1QyxDQUFBQTtZQUN4QjBCLFlBQVlBLFVBQVUvRSxPQUFPLENBQUNxRCxTQUFTO1FBQ3pDO1FBRUEsT0FBTzBCO0lBQ1Q7QUFDRjtBQUVBLHFCQUFxQjtBQUNyQixJQUFJQyx5QkFBZ0Q7QUFFN0MsU0FBU0M7SUFDZCxJQUFJLENBQUNELHdCQUF3QjtRQUMzQkEseUJBQXlCLElBQUk3SztJQUMvQjtJQUNBLE9BQU82SztBQUNUO0FBRU8sZUFBZUU7SUFDcEIsTUFBTUMsVUFBVUY7SUFDaEIsTUFBTUUsUUFBUWhLLFVBQVU7SUFDeEIsT0FBT2dLO0FBQ1QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9vbmViaXJkL2dpdGh1Yi9lYm9vay1tY3AvbWNwLWNoYXQtdWkvYmFja2VuZC9zcmMvc2VydmljZXMvU2Vzc2lvbk1hbmFnZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcHJvbWlzZXMgYXMgZnMgfSBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IENoYXRTZXNzaW9uLCBDaGF0U2Vzc2lvblN1bW1hcnksIE1lc3NhZ2UsIExMTVByb3ZpZGVyIH0gZnJvbSAnQC90eXBlcyc7XG5pbXBvcnQgeyBOb3RGb3VuZEVycm9yLCBJbnRlcm5hbFNlcnZlckVycm9yLCBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tICdAL2xpYi9lcnJvcnMnO1xuaW1wb3J0IHsgZ2V0RW5jcnlwdGlvblNlcnZpY2UgfSBmcm9tICdAL2xpYi9lbmNyeXB0aW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uU2VhcmNoT3B0aW9ucyB7XG4gIHF1ZXJ5Pzogc3RyaW5nO1xuICBwcm92aWRlcj86IExMTVByb3ZpZGVyO1xuICBsaW1pdD86IG51bWJlcjtcbiAgb2Zmc2V0PzogbnVtYmVyO1xuICBzb3J0Qnk/OiAnY3JlYXRlZEF0JyB8ICd1cGRhdGVkQXQnIHwgJ3RpdGxlJztcbiAgc29ydE9yZGVyPzogJ2FzYycgfCAnZGVzYyc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvblN0b3JhZ2Uge1xuICBzZXNzaW9uczogUmVjb3JkPHN0cmluZywgQ2hhdFNlc3Npb24+O1xuICBtZXRhZGF0YToge1xuICAgIGxhc3RDbGVhbnVwOiBzdHJpbmc7XG4gICAgdG90YWxTZXNzaW9uczogbnVtYmVyO1xuICAgIHZlcnNpb246IHN0cmluZztcbiAgICBlbmNyeXB0ZWQ6IGJvb2xlYW47XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbkV4cG9ydCB7XG4gIHZlcnNpb246IHN0cmluZztcbiAgZXhwb3J0RGF0ZTogc3RyaW5nO1xuICBzZXNzaW9uczogQ2hhdFNlc3Npb25bXTtcbiAgbWV0YWRhdGE6IHtcbiAgICB0b3RhbFNlc3Npb25zOiBudW1iZXI7XG4gICAgZGF0ZVJhbmdlOiB7XG4gICAgICBlYXJsaWVzdDogc3RyaW5nO1xuICAgICAgbGF0ZXN0OiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIFNlc3Npb25NYW5hZ2VyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBzdG9yYWdlRGlyOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgc3RvcmFnZUZpbGU6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhTZXNzaW9uczogbnVtYmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IGNsZWFudXBJbnRlcnZhbE1zOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgZW5jcnlwdGlvblNlcnZpY2UgPSBnZXRFbmNyeXB0aW9uU2VydmljZSgpO1xuICBwcml2YXRlIHN0b3JhZ2U6IFNlc3Npb25TdG9yYWdlO1xuICBwcml2YXRlIGNsZWFudXBUaW1lcj86IE5vZGVKUy5UaW1lb3V0O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHN0b3JhZ2VEaXI6IHN0cmluZyA9ICcuL2RhdGEvc2Vzc2lvbnMnLFxuICAgIG1heFNlc3Npb25zOiBudW1iZXIgPSAxMDAwLFxuICAgIGNsZWFudXBJbnRlcnZhbE1zOiBudW1iZXIgPSAyNCAqIDYwICogNjAgKiAxMDAwIC8vIDI0IGhvdXJzXG4gICkge1xuICAgIHRoaXMuc3RvcmFnZURpciA9IHN0b3JhZ2VEaXI7XG4gICAgdGhpcy5zdG9yYWdlRmlsZSA9IHBhdGguam9pbihzdG9yYWdlRGlyLCAnc2Vzc2lvbnMuanNvbicpO1xuICAgIHRoaXMubWF4U2Vzc2lvbnMgPSBtYXhTZXNzaW9ucztcbiAgICB0aGlzLmNsZWFudXBJbnRlcnZhbE1zID0gY2xlYW51cEludGVydmFsTXM7XG4gICAgdGhpcy5zdG9yYWdlID0ge1xuICAgICAgc2Vzc2lvbnM6IHt9LFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgbGFzdENsZWFudXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdG90YWxTZXNzaW9uczogMCxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZW5jcnlwdGVkOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBzZXNzaW9uIG1hbmFnZXIgYW5kIGxvYWQgZXhpc3Rpbmcgc2Vzc2lvbnNcbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZW5zdXJlU3RvcmFnZURpcmVjdG9yeSgpO1xuICAgICAgYXdhaXQgdGhpcy5sb2FkU2Vzc2lvbnMoKTtcbiAgICAgIHRoaXMuc3RhcnRDbGVhbnVwVGltZXIoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgU2Vzc2lvbk1hbmFnZXI6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsU2VydmVyRXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIHNlc3Npb24gc3RvcmFnZScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgY2hhdCBzZXNzaW9uXG4gICAqL1xuICBhc3luYyBjcmVhdGVTZXNzaW9uKFxuICAgIHByb3ZpZGVyOiBMTE1Qcm92aWRlcixcbiAgICBtb2RlbDogc3RyaW5nLFxuICAgIG1jcFNlcnZlcnM6IHN0cmluZ1tdID0gW10sXG4gICAgaW5pdGlhbE1lc3NhZ2U/OiBNZXNzYWdlXG4gICk6IFByb21pc2U8Q2hhdFNlc3Npb24+IHtcbiAgICBjb25zdCBzZXNzaW9uSWQgPSB0aGlzLmdlbmVyYXRlU2Vzc2lvbklkKCk7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcblxuICAgIGNvbnN0IHNlc3Npb246IENoYXRTZXNzaW9uID0ge1xuICAgICAgaWQ6IHNlc3Npb25JZCxcbiAgICAgIHRpdGxlOiAnTmV3IENoYXQnLCAvLyBXaWxsIGJlIHVwZGF0ZWQgd2l0aCBhdXRvLWdlbmVyYXRlZCB0aXRsZVxuICAgICAgbWVzc2FnZXM6IGluaXRpYWxNZXNzYWdlID8gW2luaXRpYWxNZXNzYWdlXSA6IFtdLFxuICAgICAgY3JlYXRlZEF0OiBub3csXG4gICAgICB1cGRhdGVkQXQ6IG5vdyxcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgbW9kZWwsXG4gICAgICBtY3BTZXJ2ZXJzLFxuICAgIH07XG5cbiAgICB0aGlzLnN0b3JhZ2Uuc2Vzc2lvbnNbc2Vzc2lvbklkXSA9IHNlc3Npb247XG4gICAgdGhpcy5zdG9yYWdlLm1ldGFkYXRhLnRvdGFsU2Vzc2lvbnMgPSBPYmplY3Qua2V5cyh0aGlzLnN0b3JhZ2Uuc2Vzc2lvbnMpLmxlbmd0aDtcblxuICAgIGF3YWl0IHRoaXMuc2F2ZVNlc3Npb25zKCk7XG4gICAgcmV0dXJuIHNlc3Npb247XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgc2Vzc2lvbiBieSBJRFxuICAgKi9cbiAgYXN5bmMgZ2V0U2Vzc2lvbihzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8Q2hhdFNlc3Npb24+IHtcbiAgICBjb25zdCBzZXNzaW9uID0gdGhpcy5zdG9yYWdlLnNlc3Npb25zW3Nlc3Npb25JZF07XG4gICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcihgU2Vzc2lvbiB3aXRoIElEICR7c2Vzc2lvbklkfSBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4uc2Vzc2lvbiB9OyAvLyBSZXR1cm4gYSBjb3B5IHRvIHByZXZlbnQgbXV0YXRpb25zXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGFuIGV4aXN0aW5nIHNlc3Npb25cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVNlc3Npb24oc2Vzc2lvbklkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8Q2hhdFNlc3Npb24+KTogUHJvbWlzZTxDaGF0U2Vzc2lvbj4ge1xuICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLnN0b3JhZ2Uuc2Vzc2lvbnNbc2Vzc2lvbklkXTtcbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKGBTZXNzaW9uIHdpdGggSUQgJHtzZXNzaW9uSWR9IG5vdCBmb3VuZGApO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgdXBkYXRpbmcgaW1tdXRhYmxlIGZpZWxkc1xuICAgIGNvbnN0IHsgaWQsIGNyZWF0ZWRBdCwgLi4uYWxsb3dlZFVwZGF0ZXMgfSA9IHVwZGF0ZXM7XG4gICAgXG4gICAgY29uc3QgdXBkYXRlZFNlc3Npb24gPSB7XG4gICAgICAuLi5zZXNzaW9uLFxuICAgICAgLi4uYWxsb3dlZFVwZGF0ZXMsXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgfTtcblxuICAgIHRoaXMuc3RvcmFnZS5zZXNzaW9uc1tzZXNzaW9uSWRdID0gdXBkYXRlZFNlc3Npb247XG4gICAgYXdhaXQgdGhpcy5zYXZlU2Vzc2lvbnMoKTtcbiAgICBcbiAgICByZXR1cm4geyAuLi51cGRhdGVkU2Vzc2lvbiB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG1lc3NhZ2UgdG8gYSBzZXNzaW9uXG4gICAqL1xuICBhc3luYyBhZGRNZXNzYWdlKHNlc3Npb25JZDogc3RyaW5nLCBtZXNzYWdlOiBNZXNzYWdlKTogUHJvbWlzZTxDaGF0U2Vzc2lvbj4ge1xuICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLnN0b3JhZ2Uuc2Vzc2lvbnNbc2Vzc2lvbklkXTtcbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKGBTZXNzaW9uIHdpdGggSUQgJHtzZXNzaW9uSWR9IG5vdCBmb3VuZGApO1xuICAgIH1cblxuICAgIHNlc3Npb24ubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICBzZXNzaW9uLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCk7XG5cbiAgICB0aGlzLnN0b3JhZ2Uuc2Vzc2lvbnNbc2Vzc2lvbklkXSA9IHNlc3Npb247XG4gICAgYXdhaXQgdGhpcy5zYXZlU2Vzc2lvbnMoKTtcblxuICAgIHJldHVybiB7IC4uLnNlc3Npb24gfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBzZXNzaW9uXG4gICAqL1xuICBhc3luYyBkZWxldGVTZXNzaW9uKHNlc3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLnN0b3JhZ2Uuc2Vzc2lvbnNbc2Vzc2lvbklkXSkge1xuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IoYFNlc3Npb24gd2l0aCBJRCAke3Nlc3Npb25JZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuc3RvcmFnZS5zZXNzaW9uc1tzZXNzaW9uSWRdO1xuICAgIHRoaXMuc3RvcmFnZS5tZXRhZGF0YS50b3RhbFNlc3Npb25zID0gT2JqZWN0LmtleXModGhpcy5zdG9yYWdlLnNlc3Npb25zKS5sZW5ndGg7XG4gICAgXG4gICAgYXdhaXQgdGhpcy5zYXZlU2Vzc2lvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2ggYW5kIGZpbHRlciBzZXNzaW9uc1xuICAgKi9cbiAgYXN5bmMgc2VhcmNoU2Vzc2lvbnMob3B0aW9uczogU2Vzc2lvblNlYXJjaE9wdGlvbnMgPSB7fSk6IFByb21pc2U8e1xuICAgIHNlc3Npb25zOiBDaGF0U2Vzc2lvblN1bW1hcnlbXTtcbiAgICB0b3RhbDogbnVtYmVyO1xuICAgIGhhc01vcmU6IGJvb2xlYW47XG4gIH0+IHtcbiAgICBjb25zdCB7XG4gICAgICBxdWVyeSxcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgbGltaXQgPSA1MCxcbiAgICAgIG9mZnNldCA9IDAsXG4gICAgICBzb3J0QnkgPSAndXBkYXRlZEF0JyxcbiAgICAgIHNvcnRPcmRlciA9ICdkZXNjJyxcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGxldCBzZXNzaW9ucyA9IE9iamVjdC52YWx1ZXModGhpcy5zdG9yYWdlLnNlc3Npb25zKTtcblxuICAgIC8vIEFwcGx5IGZpbHRlcnNcbiAgICBpZiAocXVlcnkpIHtcbiAgICAgIGNvbnN0IHNlYXJjaFF1ZXJ5ID0gcXVlcnkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHNlc3Npb25zID0gc2Vzc2lvbnMuZmlsdGVyKHNlc3Npb24gPT4gXG4gICAgICAgIHNlc3Npb24udGl0bGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hRdWVyeSkgfHxcbiAgICAgICAgc2Vzc2lvbi5tZXNzYWdlcy5zb21lKG1zZyA9PiBcbiAgICAgICAgICBtc2cuY29udGVudC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFF1ZXJ5KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChwcm92aWRlcikge1xuICAgICAgc2Vzc2lvbnMgPSBzZXNzaW9ucy5maWx0ZXIoc2Vzc2lvbiA9PiBzZXNzaW9uLnByb3ZpZGVyID09PSBwcm92aWRlcik7XG4gICAgfVxuXG4gICAgLy8gU29ydCBzZXNzaW9uc1xuICAgIHNlc3Npb25zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFWYWx1ZSA9IGFbc29ydEJ5XTtcbiAgICAgIGNvbnN0IGJWYWx1ZSA9IGJbc29ydEJ5XTtcbiAgICAgIFxuICAgICAgbGV0IGNvbXBhcmlzb24gPSAwO1xuICAgICAgaWYgKGFWYWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgYlZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBjb21wYXJpc29uID0gYVZhbHVlLmdldFRpbWUoKSAtIGJWYWx1ZS5nZXRUaW1lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wYXJpc29uID0gU3RyaW5nKGFWYWx1ZSkubG9jYWxlQ29tcGFyZShTdHJpbmcoYlZhbHVlKSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBzb3J0T3JkZXIgPT09ICdkZXNjJyA/IC1jb21wYXJpc29uIDogY29tcGFyaXNvbjtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRvdGFsID0gc2Vzc2lvbnMubGVuZ3RoO1xuICAgIGNvbnN0IHBhZ2luYXRlZFNlc3Npb25zID0gc2Vzc2lvbnMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsaW1pdCk7XG5cbiAgICAvLyBDb252ZXJ0IHRvIHN1bW1hcnkgZm9ybWF0XG4gICAgY29uc3Qgc2Vzc2lvblN1bW1hcmllczogQ2hhdFNlc3Npb25TdW1tYXJ5W10gPSBwYWdpbmF0ZWRTZXNzaW9ucy5tYXAoc2Vzc2lvbiA9PiAoe1xuICAgICAgaWQ6IHNlc3Npb24uaWQsXG4gICAgICB0aXRsZTogc2Vzc2lvbi50aXRsZSxcbiAgICAgIGNyZWF0ZWRBdDogc2Vzc2lvbi5jcmVhdGVkQXQudG9JU09TdHJpbmcoKSxcbiAgICAgIHVwZGF0ZWRBdDogc2Vzc2lvbi51cGRhdGVkQXQudG9JU09TdHJpbmcoKSxcbiAgICAgIG1lc3NhZ2VDb3VudDogc2Vzc2lvbi5tZXNzYWdlcy5sZW5ndGgsXG4gICAgICBwcm92aWRlcjogc2Vzc2lvbi5wcm92aWRlcixcbiAgICAgIG1vZGVsOiBzZXNzaW9uLm1vZGVsLFxuICAgIH0pKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzZXNzaW9uczogc2Vzc2lvblN1bW1hcmllcyxcbiAgICAgIHRvdGFsLFxuICAgICAgaGFzTW9yZTogb2Zmc2V0ICsgbGltaXQgPCB0b3RhbCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGF1dG9tYXRpYyBzZXNzaW9uIHRpdGxlIHVzaW5nIExMTVxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVTZXNzaW9uVGl0bGUoc2Vzc2lvbklkOiBzdHJpbmcsIGxsbVNlcnZpY2U/OiBhbnkpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLnN0b3JhZ2Uuc2Vzc2lvbnNbc2Vzc2lvbklkXTtcbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKGBTZXNzaW9uIHdpdGggSUQgJHtzZXNzaW9uSWR9IG5vdCBmb3VuZGApO1xuICAgIH1cblxuICAgIC8vIElmIG5vIExMTSBzZXJ2aWNlIHByb3ZpZGVkIG9yIG5vIG1lc3NhZ2VzLCB1c2UgZmFsbGJhY2tcbiAgICBpZiAoIWxsbVNlcnZpY2UgfHwgc2Vzc2lvbi5tZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlRmFsbGJhY2tUaXRsZShzZXNzaW9uKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGZpcnN0IGZldyBtZXNzYWdlcyBmb3IgY29udGV4dFxuICAgICAgY29uc3QgY29udGV4dE1lc3NhZ2VzID0gc2Vzc2lvbi5tZXNzYWdlc1xuICAgICAgICAuZmlsdGVyKG1zZyA9PiBtc2cucm9sZSA9PT0gJ3VzZXInIHx8IG1zZy5yb2xlID09PSAnYXNzaXN0YW50JylcbiAgICAgICAgLnNsaWNlKDAsIDQpXG4gICAgICAgIC5tYXAobXNnID0+IGAke21zZy5yb2xlfTogJHttc2cuY29udGVudC5zdWJzdHJpbmcoMCwgMjAwKX1gKVxuICAgICAgICAuam9pbignXFxuJyk7XG5cbiAgICAgIGNvbnN0IHRpdGxlUHJvbXB0ID0gYEJhc2VkIG9uIHRoaXMgY29udmVyc2F0aW9uLCBnZW5lcmF0ZSBhIGNvbmNpc2UsIGRlc2NyaXB0aXZlIHRpdGxlIChtYXggNTAgY2hhcmFjdGVycyk6XG5cbiR7Y29udGV4dE1lc3NhZ2VzfVxuXG5UaXRsZTpgO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGxsbVNlcnZpY2UuZ2VuZXJhdGVDb21wbGV0aW9uKHtcbiAgICAgICAgbWVzc2FnZXM6IFt7IHJvbGU6ICd1c2VyJywgY29udGVudDogdGl0bGVQcm9tcHQgfV0sXG4gICAgICAgIG1heFRva2VuczogMjAsXG4gICAgICAgIHRlbXBlcmF0dXJlOiAwLjMsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZ2VuZXJhdGVkVGl0bGUgPSByZXNwb25zZS5jb250ZW50XG4gICAgICAgID8udHJpbSgpXG4gICAgICAgIC5yZXBsYWNlKC9eW1wiJ118W1wiJ10kL2csICcnKSAvLyBSZW1vdmUgcXVvdGVzXG4gICAgICAgIC5zdWJzdHJpbmcoMCwgNTApIC8vIEVuc3VyZSBtYXggbGVuZ3RoXG4gICAgICAgIHx8IHRoaXMuZ2VuZXJhdGVGYWxsYmFja1RpdGxlKHNlc3Npb24pO1xuXG4gICAgICAvLyBVcGRhdGUgc2Vzc2lvbiB3aXRoIG5ldyB0aXRsZVxuICAgICAgYXdhaXQgdGhpcy51cGRhdGVTZXNzaW9uKHNlc3Npb25JZCwgeyB0aXRsZTogZ2VuZXJhdGVkVGl0bGUgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiBnZW5lcmF0ZWRUaXRsZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdlbmVyYXRlIHNlc3Npb24gdGl0bGU6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVGYWxsYmFja1RpdGxlKHNlc3Npb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCBvbGQgc2Vzc2lvbnMgYmFzZWQgb24gYWdlIGFuZCBjb3VudCBsaW1pdHNcbiAgICovXG4gIGFzeW5jIGNsZWFudXBTZXNzaW9ucygpOiBQcm9taXNlPHsgZGVsZXRlZENvdW50OiBudW1iZXIgfT4ge1xuICAgIGNvbnN0IHNlc3Npb25zID0gT2JqZWN0LnZhbHVlcyh0aGlzLnN0b3JhZ2Uuc2Vzc2lvbnMpO1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgbWF4QWdlID0gMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwOyAvLyAzMCBkYXlzXG4gICAgbGV0IGRlbGV0ZWRDb3VudCA9IDA7XG5cbiAgICAvLyBEZWxldGUgc2Vzc2lvbnMgb2xkZXIgdGhhbiBtYXhBZ2VcbiAgICBjb25zdCBvbGRTZXNzaW9ucyA9IHNlc3Npb25zLmZpbHRlcihzZXNzaW9uID0+IFxuICAgICAgbm93LmdldFRpbWUoKSAtIHNlc3Npb24udXBkYXRlZEF0LmdldFRpbWUoKSA+IG1heEFnZVxuICAgICk7XG5cbiAgICBmb3IgKGNvbnN0IHNlc3Npb24gb2Ygb2xkU2Vzc2lvbnMpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnN0b3JhZ2Uuc2Vzc2lvbnNbc2Vzc2lvbi5pZF07XG4gICAgICBkZWxldGVkQ291bnQrKztcbiAgICB9XG5cbiAgICAvLyBJZiBzdGlsbCBvdmVyIGxpbWl0LCBkZWxldGUgb2xkZXN0IHNlc3Npb25zXG4gICAgY29uc3QgcmVtYWluaW5nU2Vzc2lvbnMgPSBPYmplY3QudmFsdWVzKHRoaXMuc3RvcmFnZS5zZXNzaW9ucyk7XG4gICAgaWYgKHJlbWFpbmluZ1Nlc3Npb25zLmxlbmd0aCA+IHRoaXMubWF4U2Vzc2lvbnMpIHtcbiAgICAgIGNvbnN0IHNvcnRlZFNlc3Npb25zID0gcmVtYWluaW5nU2Vzc2lvbnMuc29ydChcbiAgICAgICAgKGEsIGIpID0+IGEudXBkYXRlZEF0LmdldFRpbWUoKSAtIGIudXBkYXRlZEF0LmdldFRpbWUoKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc2Vzc2lvbnNUb0RlbGV0ZSA9IHNvcnRlZFNlc3Npb25zLnNsaWNlKFxuICAgICAgICAwLCBcbiAgICAgICAgcmVtYWluaW5nU2Vzc2lvbnMubGVuZ3RoIC0gdGhpcy5tYXhTZXNzaW9uc1xuICAgICAgKTtcblxuICAgICAgZm9yIChjb25zdCBzZXNzaW9uIG9mIHNlc3Npb25zVG9EZWxldGUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RvcmFnZS5zZXNzaW9uc1tzZXNzaW9uLmlkXTtcbiAgICAgICAgZGVsZXRlZENvdW50Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdG9yYWdlLm1ldGFkYXRhLmxhc3RDbGVhbnVwID0gbm93LnRvSVNPU3RyaW5nKCk7XG4gICAgdGhpcy5zdG9yYWdlLm1ldGFkYXRhLnRvdGFsU2Vzc2lvbnMgPSBPYmplY3Qua2V5cyh0aGlzLnN0b3JhZ2Uuc2Vzc2lvbnMpLmxlbmd0aDtcblxuICAgIGlmIChkZWxldGVkQ291bnQgPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLnNhdmVTZXNzaW9ucygpO1xuICAgIH1cblxuICAgIHJldHVybiB7IGRlbGV0ZWRDb3VudCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzZXNzaW9uIHN0YXRpc3RpY3NcbiAgICovXG4gIGdldFN0YXRpc3RpY3MoKToge1xuICAgIHRvdGFsU2Vzc2lvbnM6IG51bWJlcjtcbiAgICBsYXN0Q2xlYW51cDogc3RyaW5nO1xuICAgIHByb3ZpZGVyQnJlYWtkb3duOiBSZWNvcmQ8TExNUHJvdmlkZXIsIG51bWJlcj47XG4gICAgYXZlcmFnZU1lc3NhZ2VzUGVyU2Vzc2lvbjogbnVtYmVyO1xuICB9IHtcbiAgICBjb25zdCBzZXNzaW9ucyA9IE9iamVjdC52YWx1ZXModGhpcy5zdG9yYWdlLnNlc3Npb25zKTtcbiAgICBjb25zdCBwcm92aWRlckJyZWFrZG93bjogUmVjb3JkPExMTVByb3ZpZGVyLCBudW1iZXI+ID0ge1xuICAgICAgb3BlbmFpOiAwLFxuICAgICAgZGVlcHNlZWs6IDAsXG4gICAgICBvcGVucm91dGVyOiAwLFxuICAgIH07XG5cbiAgICBsZXQgdG90YWxNZXNzYWdlcyA9IDA7XG4gICAgc2Vzc2lvbnMuZm9yRWFjaChzZXNzaW9uID0+IHtcbiAgICAgIHByb3ZpZGVyQnJlYWtkb3duW3Nlc3Npb24ucHJvdmlkZXJdKys7XG4gICAgICB0b3RhbE1lc3NhZ2VzICs9IHNlc3Npb24ubWVzc2FnZXMubGVuZ3RoO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsU2Vzc2lvbnM6IHNlc3Npb25zLmxlbmd0aCxcbiAgICAgIGxhc3RDbGVhbnVwOiB0aGlzLnN0b3JhZ2UubWV0YWRhdGEubGFzdENsZWFudXAsXG4gICAgICBwcm92aWRlckJyZWFrZG93bixcbiAgICAgIGF2ZXJhZ2VNZXNzYWdlc1BlclNlc3Npb246IHNlc3Npb25zLmxlbmd0aCA+IDAgPyB0b3RhbE1lc3NhZ2VzIC8gc2Vzc2lvbnMubGVuZ3RoIDogMCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydCBjaGF0IGhpc3RvcnkgZm9yIGJhY2t1cFxuICAgKi9cbiAgYXN5bmMgZXhwb3J0Q2hhdEhpc3Rvcnkob3B0aW9uczoge1xuICAgIHNlc3Npb25JZHM/OiBzdHJpbmdbXTtcbiAgICBkYXRlRnJvbT86IERhdGU7XG4gICAgZGF0ZVRvPzogRGF0ZTtcbiAgICBpbmNsdWRlU3lzdGVtTWVzc2FnZXM/OiBib29sZWFuO1xuICB9ID0ge30pOiBQcm9taXNlPFNlc3Npb25FeHBvcnQ+IHtcbiAgICBjb25zdCB7IHNlc3Npb25JZHMsIGRhdGVGcm9tLCBkYXRlVG8sIGluY2x1ZGVTeXN0ZW1NZXNzYWdlcyA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIFxuICAgIGxldCBzZXNzaW9ucyA9IE9iamVjdC52YWx1ZXModGhpcy5zdG9yYWdlLnNlc3Npb25zKTtcbiAgICBcbiAgICAvLyBGaWx0ZXIgYnkgc2Vzc2lvbiBJRHMgaWYgc3BlY2lmaWVkXG4gICAgaWYgKHNlc3Npb25JZHMgJiYgc2Vzc2lvbklkcy5sZW5ndGggPiAwKSB7XG4gICAgICBzZXNzaW9ucyA9IHNlc3Npb25zLmZpbHRlcihzZXNzaW9uID0+IHNlc3Npb25JZHMuaW5jbHVkZXMoc2Vzc2lvbi5pZCkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBGaWx0ZXIgYnkgZGF0ZSByYW5nZVxuICAgIGlmIChkYXRlRnJvbSkge1xuICAgICAgc2Vzc2lvbnMgPSBzZXNzaW9ucy5maWx0ZXIoc2Vzc2lvbiA9PiBzZXNzaW9uLmNyZWF0ZWRBdCA+PSBkYXRlRnJvbSk7XG4gICAgfVxuICAgIFxuICAgIGlmIChkYXRlVG8pIHtcbiAgICAgIHNlc3Npb25zID0gc2Vzc2lvbnMuZmlsdGVyKHNlc3Npb24gPT4gc2Vzc2lvbi5jcmVhdGVkQXQgPD0gZGF0ZVRvKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmlsdGVyIG1lc3NhZ2VzIGlmIG5lZWRlZFxuICAgIGNvbnN0IGV4cG9ydFNlc3Npb25zID0gc2Vzc2lvbnMubWFwKHNlc3Npb24gPT4gKHtcbiAgICAgIC4uLnNlc3Npb24sXG4gICAgICBtZXNzYWdlczogaW5jbHVkZVN5c3RlbU1lc3NhZ2VzIFxuICAgICAgICA/IHNlc3Npb24ubWVzc2FnZXMgXG4gICAgICAgIDogc2Vzc2lvbi5tZXNzYWdlcy5maWx0ZXIobXNnID0+IG1zZy5yb2xlICE9PSAnc3lzdGVtJyksXG4gICAgfSkpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBtZXRhZGF0YVxuICAgIGNvbnN0IGRhdGVzID0gZXhwb3J0U2Vzc2lvbnMubWFwKHMgPT4gcy5jcmVhdGVkQXQpLnNvcnQoKTtcbiAgICBjb25zdCBlYXJsaWVzdCA9IGRhdGVzLmxlbmd0aCA+IDAgPyBkYXRlc1swXS50b0lTT1N0cmluZygpIDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIGNvbnN0IGxhdGVzdCA9IGRhdGVzLmxlbmd0aCA+IDAgPyBkYXRlc1tkYXRlcy5sZW5ndGggLSAxXS50b0lTT1N0cmluZygpIDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgZXhwb3J0RGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgc2Vzc2lvbnM6IGV4cG9ydFNlc3Npb25zLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgdG90YWxTZXNzaW9uczogZXhwb3J0U2Vzc2lvbnMubGVuZ3RoLFxuICAgICAgICBkYXRlUmFuZ2U6IHtcbiAgICAgICAgICBlYXJsaWVzdCxcbiAgICAgICAgICBsYXRlc3QsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW1wb3J0IGNoYXQgaGlzdG9yeSBmcm9tIGJhY2t1cFxuICAgKi9cbiAgYXN5bmMgaW1wb3J0Q2hhdEhpc3RvcnkoZXhwb3J0RGF0YTogU2Vzc2lvbkV4cG9ydCwgb3B0aW9uczoge1xuICAgIG92ZXJ3cml0ZUV4aXN0aW5nPzogYm9vbGVhbjtcbiAgICBnZW5lcmF0ZU5ld0lkcz86IGJvb2xlYW47XG4gIH0gPSB7fSk6IFByb21pc2U8eyBpbXBvcnRlZDogbnVtYmVyOyBza2lwcGVkOiBudW1iZXI7IGVycm9yczogc3RyaW5nW10gfT4ge1xuICAgIGNvbnN0IHsgb3ZlcndyaXRlRXhpc3RpbmcgPSBmYWxzZSwgZ2VuZXJhdGVOZXdJZHMgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgaW1wb3J0ZWQgPSAwO1xuICAgIGxldCBza2lwcGVkID0gMDtcbiAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGlmIChleHBvcnREYXRhLnZlcnNpb24gIT09ICcxLjAuMCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignVW5zdXBwb3J0ZWQgZXhwb3J0IHZlcnNpb24nKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBzZXNzaW9uIG9mIGV4cG9ydERhdGEuc2Vzc2lvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgc2Vzc2lvbklkID0gc2Vzc2lvbi5pZDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBHZW5lcmF0ZSBuZXcgSUQgaWYgcmVxdWVzdGVkIG9yIGlmIGNvbmZsaWN0IGV4aXN0c1xuICAgICAgICAgIGlmIChnZW5lcmF0ZU5ld0lkcyB8fCAodGhpcy5zdG9yYWdlLnNlc3Npb25zW3Nlc3Npb25JZF0gJiYgIW92ZXJ3cml0ZUV4aXN0aW5nKSkge1xuICAgICAgICAgICAgc2Vzc2lvbklkID0gdGhpcy5nZW5lcmF0ZVNlc3Npb25JZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTa2lwIGlmIHNlc3Npb24gZXhpc3RzIGFuZCBub3Qgb3ZlcndyaXRpbmdcbiAgICAgICAgICBpZiAodGhpcy5zdG9yYWdlLnNlc3Npb25zW3Nlc3Npb25JZF0gJiYgIW92ZXJ3cml0ZUV4aXN0aW5nKSB7XG4gICAgICAgICAgICBza2lwcGVkKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSW1wb3J0IHNlc3Npb24gd2l0aCBuZXcgSUQgaWYgbmVlZGVkXG4gICAgICAgICAgY29uc3QgaW1wb3J0ZWRTZXNzaW9uOiBDaGF0U2Vzc2lvbiA9IHtcbiAgICAgICAgICAgIC4uLnNlc3Npb24sXG4gICAgICAgICAgICBpZDogc2Vzc2lvbklkLFxuICAgICAgICAgICAgLy8gRW5zdXJlIGRhdGVzIGFyZSBEYXRlIG9iamVjdHNcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoc2Vzc2lvbi5jcmVhdGVkQXQpLFxuICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShzZXNzaW9uLnVwZGF0ZWRBdCksXG4gICAgICAgICAgICBtZXNzYWdlczogc2Vzc2lvbi5tZXNzYWdlcy5tYXAobXNnID0+ICh7XG4gICAgICAgICAgICAgIC4uLm1zZyxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShtc2cudGltZXN0YW1wKSxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXNzaW9uc1tzZXNzaW9uSWRdID0gaW1wb3J0ZWRTZXNzaW9uO1xuICAgICAgICAgIGltcG9ydGVkKys7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYEZhaWxlZCB0byBpbXBvcnQgc2Vzc2lvbiAke3Nlc3Npb24uaWR9OiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRoaXMuc3RvcmFnZS5tZXRhZGF0YS50b3RhbFNlc3Npb25zID0gT2JqZWN0LmtleXModGhpcy5zdG9yYWdlLnNlc3Npb25zKS5sZW5ndGg7XG4gICAgICBhd2FpdCB0aGlzLnNhdmVTZXNzaW9ucygpO1xuICAgICAgXG4gICAgICByZXR1cm4geyBpbXBvcnRlZCwgc2tpcHBlZCwgZXJyb3JzIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbXBvcnQgY2hhdCBoaXN0b3J5OicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBJbnRlcm5hbFNlcnZlckVycm9yKCdGYWlsZWQgdG8gaW1wb3J0IGNoYXQgaGlzdG9yeScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWN1cmUgY2xlYW51cCAtIHBlcm1hbmVudGx5IGRlbGV0ZSBzZXNzaW9ucyBhbmQgY2xlYXIgc2Vuc2l0aXZlIGRhdGFcbiAgICovXG4gIGFzeW5jIHNlY3VyZUNsZWFudXAob3B0aW9uczoge1xuICAgIG9sZGVyVGhhbkRheXM/OiBudW1iZXI7XG4gICAgc2Vzc2lvbklkcz86IHN0cmluZ1tdO1xuICAgIGNsZWFyQWxsU2Vuc2l0aXZlRGF0YT86IGJvb2xlYW47XG4gIH0gPSB7fSk6IFByb21pc2U8eyBkZWxldGVkU2Vzc2lvbnM6IG51bWJlcjsgY2xlYXJlZERhdGE6IGJvb2xlYW4gfT4ge1xuICAgIGNvbnN0IHsgb2xkZXJUaGFuRGF5cyA9IDMwLCBzZXNzaW9uSWRzLCBjbGVhckFsbFNlbnNpdGl2ZURhdGEgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBcbiAgICBsZXQgZGVsZXRlZFNlc3Npb25zID0gMDtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IG1heEFnZSA9IG9sZGVyVGhhbkRheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuICAgIFxuICAgIC8vIERlbGV0ZSBzcGVjaWZpYyBzZXNzaW9ucyBpZiBwcm92aWRlZFxuICAgIGlmIChzZXNzaW9uSWRzICYmIHNlc3Npb25JZHMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBzZXNzaW9uSWQgb2Ygc2Vzc2lvbklkcykge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlLnNlc3Npb25zW3Nlc3Npb25JZF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdG9yYWdlLnNlc3Npb25zW3Nlc3Npb25JZF07XG4gICAgICAgICAgZGVsZXRlZFNlc3Npb25zKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVsZXRlIG9sZCBzZXNzaW9uc1xuICAgICAgY29uc3Qgc2Vzc2lvbnMgPSBPYmplY3QudmFsdWVzKHRoaXMuc3RvcmFnZS5zZXNzaW9ucyk7XG4gICAgICBjb25zdCBvbGRTZXNzaW9ucyA9IHNlc3Npb25zLmZpbHRlcihzZXNzaW9uID0+IFxuICAgICAgICBub3cuZ2V0VGltZSgpIC0gc2Vzc2lvbi51cGRhdGVkQXQuZ2V0VGltZSgpID4gbWF4QWdlXG4gICAgICApO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHNlc3Npb24gb2Ygb2xkU2Vzc2lvbnMpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RvcmFnZS5zZXNzaW9uc1tzZXNzaW9uLmlkXTtcbiAgICAgICAgZGVsZXRlZFNlc3Npb25zKys7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFyIHNlbnNpdGl2ZSBkYXRhIGZyb20gcmVtYWluaW5nIHNlc3Npb25zIGlmIHJlcXVlc3RlZFxuICAgIGxldCBjbGVhcmVkRGF0YSA9IGZhbHNlO1xuICAgIGlmIChjbGVhckFsbFNlbnNpdGl2ZURhdGEpIHtcbiAgICAgIE9iamVjdC52YWx1ZXModGhpcy5zdG9yYWdlLnNlc3Npb25zKS5mb3JFYWNoKHNlc3Npb24gPT4ge1xuICAgICAgICBzZXNzaW9uLm1lc3NhZ2VzID0gc2Vzc2lvbi5tZXNzYWdlcy5tYXAobWVzc2FnZSA9PiAoe1xuICAgICAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICAgICAgLy8gUmVtb3ZlIGFueSBwb3RlbnRpYWwgc2Vuc2l0aXZlIGNvbnRlbnQgcGF0dGVybnNcbiAgICAgICAgICBjb250ZW50OiB0aGlzLnNhbml0aXplTWVzc2FnZUNvbnRlbnQobWVzc2FnZS5jb250ZW50KSxcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgICBjbGVhcmVkRGF0YSA9IHRydWU7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuc3RvcmFnZS5tZXRhZGF0YS50b3RhbFNlc3Npb25zID0gT2JqZWN0LmtleXModGhpcy5zdG9yYWdlLnNlc3Npb25zKS5sZW5ndGg7XG4gICAgdGhpcy5zdG9yYWdlLm1ldGFkYXRhLmxhc3RDbGVhbnVwID0gbm93LnRvSVNPU3RyaW5nKCk7XG4gICAgXG4gICAgYXdhaXQgdGhpcy5zYXZlU2Vzc2lvbnMoKTtcbiAgICBcbiAgICByZXR1cm4geyBkZWxldGVkU2Vzc2lvbnMsIGNsZWFyZWREYXRhIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHByaXZhY3kgYW5kIHNlY3VyaXR5IHN0YXRpc3RpY3NcbiAgICovXG4gIGdldFByaXZhY3lTdGF0aXN0aWNzKCk6IHtcbiAgICB0b3RhbFNlc3Npb25zOiBudW1iZXI7XG4gICAgdG90YWxNZXNzYWdlczogbnVtYmVyO1xuICAgIG9sZGVzdFNlc3Npb246IHN0cmluZyB8IG51bGw7XG4gICAgbmV3ZXN0U2Vzc2lvbjogc3RyaW5nIHwgbnVsbDtcbiAgICBhdmVyYWdlU2Vzc2lvbkFnZTogbnVtYmVyO1xuICAgIHNlc3Npb25zV2l0aFNlbnNpdGl2ZURhdGE6IG51bWJlcjtcbiAgICBsYXN0Q2xlYW51cDogc3RyaW5nO1xuICB9IHtcbiAgICBjb25zdCBzZXNzaW9ucyA9IE9iamVjdC52YWx1ZXModGhpcy5zdG9yYWdlLnNlc3Npb25zKTtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIFxuICAgIGlmIChzZXNzaW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvdGFsU2Vzc2lvbnM6IDAsXG4gICAgICAgIHRvdGFsTWVzc2FnZXM6IDAsXG4gICAgICAgIG9sZGVzdFNlc3Npb246IG51bGwsXG4gICAgICAgIG5ld2VzdFNlc3Npb246IG51bGwsXG4gICAgICAgIGF2ZXJhZ2VTZXNzaW9uQWdlOiAwLFxuICAgICAgICBzZXNzaW9uc1dpdGhTZW5zaXRpdmVEYXRhOiAwLFxuICAgICAgICBsYXN0Q2xlYW51cDogdGhpcy5zdG9yYWdlLm1ldGFkYXRhLmxhc3RDbGVhbnVwLFxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgc29ydGVkQnlEYXRlID0gc2Vzc2lvbnMuc29ydCgoYSwgYikgPT4gYS5jcmVhdGVkQXQuZ2V0VGltZSgpIC0gYi5jcmVhdGVkQXQuZ2V0VGltZSgpKTtcbiAgICBjb25zdCB0b3RhbE1lc3NhZ2VzID0gc2Vzc2lvbnMucmVkdWNlKChzdW0sIHNlc3Npb24pID0+IHN1bSArIHNlc3Npb24ubWVzc2FnZXMubGVuZ3RoLCAwKTtcbiAgICBcbiAgICBjb25zdCB0b3RhbEFnZSA9IHNlc3Npb25zLnJlZHVjZSgoc3VtLCBzZXNzaW9uKSA9PiBcbiAgICAgIHN1bSArIChub3cuZ2V0VGltZSgpIC0gc2Vzc2lvbi5jcmVhdGVkQXQuZ2V0VGltZSgpKSwgMFxuICAgICk7XG4gICAgY29uc3QgYXZlcmFnZVNlc3Npb25BZ2UgPSB0b3RhbEFnZSAvIHNlc3Npb25zLmxlbmd0aCAvICgyNCAqIDYwICogNjAgKiAxMDAwKTsgLy8gaW4gZGF5c1xuICAgIFxuICAgIC8vIENvdW50IHNlc3Npb25zIHRoYXQgbWlnaHQgY29udGFpbiBzZW5zaXRpdmUgZGF0YSAoQVBJIGtleXMsIHRva2VucywgZXRjLilcbiAgICBjb25zdCBzZW5zaXRpdmVQYXR0ZXJucyA9IFsvYXBpW18tXT9rZXkvaSwgL3Rva2VuL2ksIC9zZWNyZXQvaSwgL3Bhc3N3b3JkL2ldO1xuICAgIGNvbnN0IHNlc3Npb25zV2l0aFNlbnNpdGl2ZURhdGEgPSBzZXNzaW9ucy5maWx0ZXIoc2Vzc2lvbiA9PlxuICAgICAgc2Vzc2lvbi5tZXNzYWdlcy5zb21lKG1lc3NhZ2UgPT5cbiAgICAgICAgc2Vuc2l0aXZlUGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChtZXNzYWdlLmNvbnRlbnQpKVxuICAgICAgKVxuICAgICkubGVuZ3RoO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbFNlc3Npb25zOiBzZXNzaW9ucy5sZW5ndGgsXG4gICAgICB0b3RhbE1lc3NhZ2VzLFxuICAgICAgb2xkZXN0U2Vzc2lvbjogc29ydGVkQnlEYXRlWzBdLmNyZWF0ZWRBdC50b0lTT1N0cmluZygpLFxuICAgICAgbmV3ZXN0U2Vzc2lvbjogc29ydGVkQnlEYXRlW3NvcnRlZEJ5RGF0ZS5sZW5ndGggLSAxXS5jcmVhdGVkQXQudG9JU09TdHJpbmcoKSxcbiAgICAgIGF2ZXJhZ2VTZXNzaW9uQWdlLFxuICAgICAgc2Vzc2lvbnNXaXRoU2Vuc2l0aXZlRGF0YSxcbiAgICAgIGxhc3RDbGVhbnVwOiB0aGlzLnN0b3JhZ2UubWV0YWRhdGEubGFzdENsZWFudXAsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaHV0ZG93biB0aGUgc2Vzc2lvbiBtYW5hZ2VyXG4gICAqL1xuICBhc3luYyBzaHV0ZG93bigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5jbGVhbnVwVGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbGVhbnVwVGltZXIpO1xuICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuc2F2ZVNlc3Npb25zKCk7XG4gIH1cblxuICAvLyBQcml2YXRlIG1ldGhvZHNcblxuICBwcml2YXRlIGdlbmVyYXRlU2Vzc2lvbklkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBzZXNzaW9uXyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YDtcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVGYWxsYmFja1RpdGxlKHNlc3Npb246IENoYXRTZXNzaW9uKTogc3RyaW5nIHtcbiAgICBjb25zdCB1c2VyTWVzc2FnZXMgPSBzZXNzaW9uLm1lc3NhZ2VzLmZpbHRlcihtc2cgPT4gbXNnLnJvbGUgPT09ICd1c2VyJyk7XG4gICAgaWYgKHVzZXJNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBvcmlnaW5hbE1lc3NhZ2UgPSB1c2VyTWVzc2FnZXNbMF0uY29udGVudDtcbiAgICAgIGNvbnN0IHRydW5jYXRlZE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2Uuc3Vic3RyaW5nKDAsIDQwKTtcbiAgICAgIHJldHVybiBvcmlnaW5hbE1lc3NhZ2UubGVuZ3RoID4gNDAgPyBgJHt0cnVuY2F0ZWRNZXNzYWdlfS4uLmAgOiB0cnVuY2F0ZWRNZXNzYWdlO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBkYXRlID0gc2Vzc2lvbi5jcmVhdGVkQXQudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XG4gICAgcmV0dXJuIGBDaGF0IGZyb20gJHtkYXRlfWA7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGVuc3VyZVN0b3JhZ2VEaXJlY3RvcnkoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZzLm1rZGlyKHRoaXMuc3RvcmFnZURpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBJbnRlcm5hbFNlcnZlckVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHN0b3JhZ2UgZGlyZWN0b3J5OiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9hZFNlc3Npb25zKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZnMucmVhZEZpbGUodGhpcy5zdG9yYWdlRmlsZSwgJ3V0Zi04Jyk7XG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgXG4gICAgICAvLyBDb252ZXJ0IGRhdGUgc3RyaW5ncyBiYWNrIHRvIERhdGUgb2JqZWN0c1xuICAgICAgT2JqZWN0LnZhbHVlcyhwYXJzZWQuc2Vzc2lvbnMpLmZvckVhY2goKHNlc3Npb246IGFueSkgPT4ge1xuICAgICAgICBzZXNzaW9uLmNyZWF0ZWRBdCA9IG5ldyBEYXRlKHNlc3Npb24uY3JlYXRlZEF0KTtcbiAgICAgICAgc2Vzc2lvbi51cGRhdGVkQXQgPSBuZXcgRGF0ZShzZXNzaW9uLnVwZGF0ZWRBdCk7XG4gICAgICAgIHNlc3Npb24ubWVzc2FnZXMuZm9yRWFjaCgobWVzc2FnZTogYW55KSA9PiB7XG4gICAgICAgICAgbWVzc2FnZS50aW1lc3RhbXAgPSBuZXcgRGF0ZShtZXNzYWdlLnRpbWVzdGFtcCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHRoaXMuc3RvcmFnZSA9IHBhcnNlZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKChlcnJvciBhcyBhbnkpLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgIC8vIEZpbGUgZG9lc24ndCBleGlzdCwgc3RhcnQgd2l0aCBlbXB0eSBzdG9yYWdlXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHtcbiAgICAgICAgICBzZXNzaW9uczoge30sXG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIGxhc3RDbGVhbnVwOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB0b3RhbFNlc3Npb25zOiAwLFxuICAgICAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgICAgIGVuY3J5cHRlZDogZmFsc2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlU2Vzc2lvbnMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHNlc3Npb25zOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEludGVybmFsU2VydmVyRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHNlc3Npb24gZGF0YScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2F2ZVNlc3Npb25zKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5zdHJpbmdpZnkodGhpcy5zdG9yYWdlLCBudWxsLCAyKTtcbiAgICAgIGF3YWl0IGZzLndyaXRlRmlsZSh0aGlzLnN0b3JhZ2VGaWxlLCBkYXRhLCAndXRmLTgnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgc2Vzc2lvbnM6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsU2VydmVyRXJyb3IoJ0ZhaWxlZCB0byBzYXZlIHNlc3Npb24gZGF0YScpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhcnRDbGVhbnVwVGltZXIoKTogdm9pZCB7XG4gICAgdGhpcy5jbGVhbnVwVGltZXIgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmNsZWFudXBTZXNzaW9ucygpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQXV0b21hdGljIGNsZWFudXAgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmNsZWFudXBJbnRlcnZhbE1zKTtcbiAgfVxuXG4gIHByaXZhdGUgc2FuaXRpemVNZXNzYWdlQ29udGVudChjb250ZW50OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIFJlbW92ZSBwb3RlbnRpYWwgQVBJIGtleXMsIHRva2VucywgYW5kIG90aGVyIHNlbnNpdGl2ZSBkYXRhXG4gICAgY29uc3Qgc2Vuc2l0aXZlUGF0dGVybnMgPSBbXG4gICAgICAvc2stW2EtekEtWjAtOV17MjAsfS9nLCAvLyBPcGVuQUktc3R5bGUgQVBJIGtleXNcbiAgICAgIC9zay1vci1bYS16QS1aMC05XXszMCx9L2csIC8vIE9wZW5Sb3V0ZXIgQVBJIGtleXNcbiAgICAgIC9CZWFyZXJcXHMrW2EtekEtWjAtOV17MjAsfS9nLCAvLyBCZWFyZXIgdG9rZW5zXG4gICAgICAvW2EtekEtWjAtOV17MzIsfS9nLCAvLyBMb25nIGFscGhhbnVtZXJpYyBzdHJpbmdzIChwb3RlbnRpYWwgdG9rZW5zKVxuICAgIF07XG4gICAgXG4gICAgbGV0IHNhbml0aXplZCA9IGNvbnRlbnQ7XG4gICAgc2Vuc2l0aXZlUGF0dGVybnMuZm9yRWFjaChwYXR0ZXJuID0+IHtcbiAgICAgIHNhbml0aXplZCA9IHNhbml0aXplZC5yZXBsYWNlKHBhdHRlcm4sICdbUkVEQUNURURdJyk7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHNhbml0aXplZDtcbiAgfVxufVxuXG4vLyBTaW5nbGV0b24gaW5zdGFuY2VcbmxldCBzZXNzaW9uTWFuYWdlckluc3RhbmNlOiBTZXNzaW9uTWFuYWdlciB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Vzc2lvbk1hbmFnZXIoKTogU2Vzc2lvbk1hbmFnZXIge1xuICBpZiAoIXNlc3Npb25NYW5hZ2VySW5zdGFuY2UpIHtcbiAgICBzZXNzaW9uTWFuYWdlckluc3RhbmNlID0gbmV3IFNlc3Npb25NYW5hZ2VyKCk7XG4gIH1cbiAgcmV0dXJuIHNlc3Npb25NYW5hZ2VySW5zdGFuY2U7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplU2Vzc2lvbk1hbmFnZXIoKTogUHJvbWlzZTxTZXNzaW9uTWFuYWdlcj4ge1xuICBjb25zdCBtYW5hZ2VyID0gZ2V0U2Vzc2lvbk1hbmFnZXIoKTtcbiAgYXdhaXQgbWFuYWdlci5pbml0aWFsaXplKCk7XG4gIHJldHVybiBtYW5hZ2VyO1xufSJdLCJuYW1lcyI6WyJwcm9taXNlcyIsImZzIiwicGF0aCIsIk5vdEZvdW5kRXJyb3IiLCJJbnRlcm5hbFNlcnZlckVycm9yIiwiVmFsaWRhdGlvbkVycm9yIiwiZ2V0RW5jcnlwdGlvblNlcnZpY2UiLCJTZXNzaW9uTWFuYWdlciIsInN0b3JhZ2VEaXIiLCJtYXhTZXNzaW9ucyIsImNsZWFudXBJbnRlcnZhbE1zIiwiZW5jcnlwdGlvblNlcnZpY2UiLCJzdG9yYWdlRmlsZSIsImpvaW4iLCJzdG9yYWdlIiwic2Vzc2lvbnMiLCJtZXRhZGF0YSIsImxhc3RDbGVhbnVwIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidG90YWxTZXNzaW9ucyIsInZlcnNpb24iLCJlbmNyeXB0ZWQiLCJpbml0aWFsaXplIiwiZW5zdXJlU3RvcmFnZURpcmVjdG9yeSIsImxvYWRTZXNzaW9ucyIsInN0YXJ0Q2xlYW51cFRpbWVyIiwiZXJyb3IiLCJjb25zb2xlIiwiY3JlYXRlU2Vzc2lvbiIsInByb3ZpZGVyIiwibW9kZWwiLCJtY3BTZXJ2ZXJzIiwiaW5pdGlhbE1lc3NhZ2UiLCJzZXNzaW9uSWQiLCJnZW5lcmF0ZVNlc3Npb25JZCIsIm5vdyIsInNlc3Npb24iLCJpZCIsInRpdGxlIiwibWVzc2FnZXMiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwic2F2ZVNlc3Npb25zIiwiZ2V0U2Vzc2lvbiIsInVwZGF0ZVNlc3Npb24iLCJ1cGRhdGVzIiwiYWxsb3dlZFVwZGF0ZXMiLCJ1cGRhdGVkU2Vzc2lvbiIsImFkZE1lc3NhZ2UiLCJtZXNzYWdlIiwicHVzaCIsImRlbGV0ZVNlc3Npb24iLCJzZWFyY2hTZXNzaW9ucyIsIm9wdGlvbnMiLCJxdWVyeSIsImxpbWl0Iiwib2Zmc2V0Iiwic29ydEJ5Iiwic29ydE9yZGVyIiwidmFsdWVzIiwic2VhcmNoUXVlcnkiLCJ0b0xvd2VyQ2FzZSIsImZpbHRlciIsImluY2x1ZGVzIiwic29tZSIsIm1zZyIsImNvbnRlbnQiLCJzb3J0IiwiYSIsImIiLCJhVmFsdWUiLCJiVmFsdWUiLCJjb21wYXJpc29uIiwiZ2V0VGltZSIsIlN0cmluZyIsImxvY2FsZUNvbXBhcmUiLCJ0b3RhbCIsInBhZ2luYXRlZFNlc3Npb25zIiwic2xpY2UiLCJzZXNzaW9uU3VtbWFyaWVzIiwibWFwIiwibWVzc2FnZUNvdW50IiwiaGFzTW9yZSIsImdlbmVyYXRlU2Vzc2lvblRpdGxlIiwibGxtU2VydmljZSIsImdlbmVyYXRlRmFsbGJhY2tUaXRsZSIsImNvbnRleHRNZXNzYWdlcyIsInJvbGUiLCJzdWJzdHJpbmciLCJ0aXRsZVByb21wdCIsInJlc3BvbnNlIiwiZ2VuZXJhdGVDb21wbGV0aW9uIiwibWF4VG9rZW5zIiwidGVtcGVyYXR1cmUiLCJnZW5lcmF0ZWRUaXRsZSIsInRyaW0iLCJyZXBsYWNlIiwiY2xlYW51cFNlc3Npb25zIiwibWF4QWdlIiwiZGVsZXRlZENvdW50Iiwib2xkU2Vzc2lvbnMiLCJyZW1haW5pbmdTZXNzaW9ucyIsInNvcnRlZFNlc3Npb25zIiwic2Vzc2lvbnNUb0RlbGV0ZSIsImdldFN0YXRpc3RpY3MiLCJwcm92aWRlckJyZWFrZG93biIsIm9wZW5haSIsImRlZXBzZWVrIiwib3BlbnJvdXRlciIsInRvdGFsTWVzc2FnZXMiLCJmb3JFYWNoIiwiYXZlcmFnZU1lc3NhZ2VzUGVyU2Vzc2lvbiIsImV4cG9ydENoYXRIaXN0b3J5Iiwic2Vzc2lvbklkcyIsImRhdGVGcm9tIiwiZGF0ZVRvIiwiaW5jbHVkZVN5c3RlbU1lc3NhZ2VzIiwiZXhwb3J0U2Vzc2lvbnMiLCJkYXRlcyIsInMiLCJlYXJsaWVzdCIsImxhdGVzdCIsImV4cG9ydERhdGUiLCJkYXRlUmFuZ2UiLCJpbXBvcnRDaGF0SGlzdG9yeSIsImV4cG9ydERhdGEiLCJvdmVyd3JpdGVFeGlzdGluZyIsImdlbmVyYXRlTmV3SWRzIiwiaW1wb3J0ZWQiLCJza2lwcGVkIiwiZXJyb3JzIiwiaW1wb3J0ZWRTZXNzaW9uIiwidGltZXN0YW1wIiwic2VjdXJlQ2xlYW51cCIsIm9sZGVyVGhhbkRheXMiLCJjbGVhckFsbFNlbnNpdGl2ZURhdGEiLCJkZWxldGVkU2Vzc2lvbnMiLCJjbGVhcmVkRGF0YSIsInNhbml0aXplTWVzc2FnZUNvbnRlbnQiLCJnZXRQcml2YWN5U3RhdGlzdGljcyIsIm9sZGVzdFNlc3Npb24iLCJuZXdlc3RTZXNzaW9uIiwiYXZlcmFnZVNlc3Npb25BZ2UiLCJzZXNzaW9uc1dpdGhTZW5zaXRpdmVEYXRhIiwic29ydGVkQnlEYXRlIiwicmVkdWNlIiwic3VtIiwidG90YWxBZ2UiLCJzZW5zaXRpdmVQYXR0ZXJucyIsInBhdHRlcm4iLCJ0ZXN0Iiwic2h1dGRvd24iLCJjbGVhbnVwVGltZXIiLCJjbGVhckludGVydmFsIiwidW5kZWZpbmVkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwidXNlck1lc3NhZ2VzIiwib3JpZ2luYWxNZXNzYWdlIiwidHJ1bmNhdGVkTWVzc2FnZSIsImRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJta2RpciIsInJlY3Vyc2l2ZSIsImRhdGEiLCJyZWFkRmlsZSIsInBhcnNlZCIsIkpTT04iLCJwYXJzZSIsImNvZGUiLCJzdHJpbmdpZnkiLCJ3cml0ZUZpbGUiLCJzZXRJbnRlcnZhbCIsInNhbml0aXplZCIsInNlc3Npb25NYW5hZ2VySW5zdGFuY2UiLCJnZXRTZXNzaW9uTWFuYWdlciIsImluaXRpYWxpemVTZXNzaW9uTWFuYWdlciIsIm1hbmFnZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/services/SessionManager.ts\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "./work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "next/dist/shared/lib/no-fallback-error.external":
/*!******************************************************************!*\
  !*** external "next/dist/shared/lib/no-fallback-error.external" ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/no-fallback-error.external");

/***/ }),

/***/ "next/dist/shared/lib/router/utils/app-paths":
/*!**************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/app-paths" ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/app-paths");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/crypto-js"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fchat%2Froute&page=%2Fapi%2Fchat%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fchat%2Froute.ts&appDir=%2FUsers%2Fonebird%2Fgithub%2Febook-mcp%2Fmcp-chat-ui%2Fbackend%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fonebird%2Fgithub%2Febook-mcp%2Fmcp-chat-ui%2Fbackend&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!")));
module.exports = __webpack_exports__;

})();